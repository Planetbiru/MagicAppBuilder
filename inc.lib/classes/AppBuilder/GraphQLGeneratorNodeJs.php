<?php

namespace AppBuilder;

/**
 * The `GraphQLGeneratorNodeJs` class is designed to automatically generate a complete Node.js GraphQL API
 * from a JSON file that defines database entities. It uses Express.js as the web server,
 * `express-graphql` for the GraphQL endpoint, and Sequelize as the ORM for database interaction.
 * The generated code follows a modular structure, separating models, types, resolvers, and the main server logic.
 *
 * @package AppBuilder
 */
class GraphQLGeneratorNodeJs extends GraphQLGeneratorBase
{
    /**
     * Constructor for the `GraphQLGeneratorNodeJs` class.
     *
     * @param array $analyzedSchema The analyzed database schema.
     * @param string $displayField The default display field for entities.
     * @param string|null $activeField The field used to indicate active records, if any.
     * @param array $backendHandledColumns Columns that are managed by the backend.
     */
    private function mapDbTypeToSequelizeType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false) {
            return "DataTypes.STRING($length)";
        }
        if (strpos($dbType, 'text') !== false || strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false || strpos($dbType, 'date') !== false) {
            // Treat text and all date/time types as strings to preserve their original format from the database
            return 'DataTypes.STRING';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'double') !== false) {
            return 'DataTypes.DOUBLE';
        }
        if (strpos($dbType, 'float') !== false) {
            return 'DataTypes.FLOAT';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'DataTypes.BOOLEAN';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'DataTypes.INTEGER';
        }
        return 'DataTypes.STRING'; // Default
    }

    /**
     * Generates the complete set of files for the Node.js GraphQL API.
     *
     * @return array An array of files, each represented as an associative array with 'name' and 'content' keys.
     */
    public function generate()
    {
        $files = [];
        $files[] = ['name' => 'package.json', 'content' => $this->generatePackageJson()];
        $files[] = ['name' => '.env', 'content' => $this->generateEnvFile()];
        $files[] = ['name' => 'server.js', 'content' => $this->generateServerJs()];
        $files[] = ['name' => 'config/database.js', 'content' => $this->generateDatabaseJs()];
        $files[] = ['name' => 'schema/schema.js', 'content' => $this->generateSchemaJs()];
        $files[] = ['name' => 'schema/types.js', 'content' => $this->generateTypesJs()];
        $files[] = ['name' => 'schema/resolvers.js', 'content' => $this->generateResolversJs()];
        $files[] = ['name' => 'config/frontend-config.json', 'content' => $this->generateFrontendConfigJson()];

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $files[] = ['name' => "models/$pascalName.js", 'content' => $this->generateModelFile($tableName, $tableInfo)];
        }

        return $files;
    }

    /**
     * Generates the `package.json` file for the Node.js project.
     *
     * @return string The content of the `package.json` file.
     */
    private function generatePackageJson()
    {
        return <<<JSON
{
  "name": "graphql-nodejs-api",
  "version": "1.0.0",
  "description": "GraphQL API generated by MagicAppBuilder",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "multer": "^1.4.5-lts.1",
    "connect-session-sequelize": "^7.1.7",
    "cors": "^2.8.5",
    "dotenv": "^16.0.3",
    "express": "^4.18.2",
    "express-graphql": "^0.12.0",
    "graphql": "^15.8.0",
    "mysql2": "^3.2.0",
    "pg": "^8.10.0",
    "sequelize": "^6.29.3",
    "express-session": "^1.18.0",
    "sqlite3": "^5.1.6"
  },
  "devDependencies": {
    "nodemon": "^2.0.22"
  }
}
JSON;
    }

    /**
     * Generates the `.env` file for the Node.js project.
     * @return string The content of the `.env` file.
     */
    private function generateEnvFile()
    {
        return <<<ENV
# Database Configuration
# Supported dialects: 'mysql', 'postgres', 'sqlite', 'mariadb', 'mssql'
DB_DIALECT={DB_DIALECT}
DB_HOST={DB_HOST}
DB_PORT={DB_PORT}
DB_USER={DB_USER}
DB_PASS={DB_PASS}
DB_NAME={DB_NAME}

# Server Configuration
PORT=4000

# CORS Configuration
# Comma-separated list of allowed origins. Do not use spaces between origins.
CORS_ALLOWED_ORIGINS=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

REQUIRE_LOGIN=true
ENV;
    }

    /**
     * Generates the `server.js` file for the Node.js project.
     * @return string The content of the `server.js` file.
     */
    private function generateServerJs()
    {
        return <<<JS
require('dotenv').config();
const express = require('express');
const { graphqlHTTP } = require('express-graphql');
const cors = require('cors');
const schema = require('./schema/schema');
const fs = require('fs');
const path = require('path');
const { sequelize, models } = require('./config/database');
const session = require('express-session');
const SequelizeStore = require('connect-session-sequelize')(session.Store);
const crypto = require('crypto');
const multer = require('multer');
const conditionalAuth = require('./middleware/conditionalAuth');
const profileRoutes = require('./routes/profileRoutes');
const adminRoutes = require('./routes/adminRoutes');
const messageRoutes = require('./routes/messageRoutes');
const notificationRoutes = require('./routes/notificationRoutes');

const app = express();

// CORS configuration
const allowedOrigins = process.env.CORS_ALLOWED_ORIGINS ? process.env.CORS_ALLOWED_ORIGINS.split(',') : [];

const corsOptions = {
  origin: (origin, callback) => {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.length === 0 || allowedOrigins.indexOf(origin) !== -1) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true,
};

// Middleware to parse JSON bodies
app.use(express.json());

// Middleware to parse URL-encoded bodies (for form data)
app.use(express.urlencoded({ extended: true }));

// Apply CORS after body parsers
app.use(cors(corsOptions));

// Session configuration
const sessionStore = new SequelizeStore({
    db: sequelize,
    table: 'Session', // This should match the table name of the model
    modelKey: 'Session' // Tell the store to look for models.Session
});

app.use(
    session({
        secret: process.env.SESSION_SECRET || 'a-very-secret-key-for-development',
        store: sessionStore,
        resave: false,
        saveUninitialized: false,
        cookie: {
            maxAge: 24 * 60 * 60 * 1000, // 24 hours
            // secure: process.env.NODE_ENV === 'production', // Enable in production for HTTPS
            httpOnly: true
        },
    })
);

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Endpoint to serve frontend configuration
app.get('/frontend-config.json', conditionalAuth, (req, res) => {
    // Set headers to prevent browser caching
    res.set({
        'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
    });

    const configPath = path.join(__dirname, 'config', 'frontend-config.json');
    res.sendFile(configPath, (err) => {
        if (err) {
            console.error('Error sending frontend-config.json:', err);
            if (!res.headersSent) {
                res.status(500).send({ error: 'Could not load frontend configuration.' });
            }
        }
    });
});

// Endpoint to serve available languages configuration
app.get('/available-language.json', (req, res) => {
    const langPath = path.join(__dirname, 'public', 'langs', 'available-language.json');
    res.sendFile(langPath, (err) => {
        if (err) {
            console.error('Error sending available-language.json:', err);
            if (!res.headersSent) {
                res.status(404).send({ error: 'Available languages configuration not found.' });
            }
        }
    });
});

// Endpoint to serve available theme
app.get('/available-theme.json', (req, res) => {
    const themesPath = path.join(__dirname, 'public', 'assets', 'themes');
    fs.readdir(themesPath, { withFileTypes: true }, (err, dirents = []) => {
        if (err) {
            console.error('Error reading themes directory:', err);
            return res.status(500).send({ error: 'Could not read themes directory.' });
        }

        const themes = dirents
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name)
            .filter(themeName => {
                const stylePath = path.join(themesPath, themeName, 'style.min.css');
                return fs.existsSync(stylePath);
            })
            .map(themeName => ({
                name: themeName,
                title: themeName.replace(/[-_]/g, ' ').replace(/\b\w/g, char => char.toUpperCase())
            }));

        res.json(themes);
    });
});

// --- Auth Endpoints ---

// Initialize multer for parsing multipart/form-data
const upload = multer();

// POST /login
app.post('/login', upload.none(), async (req, res) => {
    const { username, password } = req.body;

    if (!username || !password) {
        return res.status(400).json({ success: false, message: 'Username and password are required.' });
    }

    try {
        // Ensure the admin model is loaded before attempting to use it
        if (!models.admin) {
            console.error('Error: Admin model (models.admin) is undefined. Please check if models/admin.js exists and is correctly defined.');
            return res.status(500).json({ success: false, message: 'Server configuration error: Admin model not found.' });
        }
        const user = await models.admin.findOne({ where: { username } });

        // Replicate the double sha1 hashing
        const hash1 = crypto.createHash('sha1').update(password).digest('hex');
        const passwordHash = crypto.createHash('sha1').update(hash1).digest('hex');

        if (user && passwordHash === user.password) {
            // Set session on successful login
            req.session.username = user.username;
            req.session.userId = user.admin_id;

            return res.json({ success: true });
        } else {
            return res.status(401).json({ success: false, message: 'Invalid credentials' });
        }
    } catch (error) {
        console.error('Login error:', error);
        return res.status(500).json({ success: false, message: 'An internal error occurred during login.' });
    }
});

// POST /logout
app.post('/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            console.error('Logout error:', err);
            return res.status(500).json({ success: false, message: 'Could not log out, please try again.' });
        }
        // Clear the cookie on the client side
        res.clearCookie('connect.sid'); // The default session cookie name
        return res.json({ success: true });
    });
});


// Use the profile routes
app.use('/', profileRoutes);
app.use('/', adminRoutes);
app.use('/', messageRoutes);
app.use('/', notificationRoutes);

app.use('/graphql', conditionalAuth, graphqlHTTP({ schema, graphiql: true }));

const PORT = process.env.PORT || 4000;

sequelize.authenticate()
    .then(() => {
        console.log('Database connection has been established successfully.');
        sequelize.sync(); // Sync all models, including the Session table
        app.listen(PORT, () => {
            console.log(`Server running on http://localhost:\${PORT}/graphql`);
        });
    })
    .catch(err => {
        console.error('Unable to connect to the database:', err);
    });
JS;
    }

    /**
     * Generates the `database.js` file for the Node.js project.
     * @return string The content of the `database.js` file.
     */
    private function generateDatabaseJs()
    {
        return <<<JS
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize(
    process.env.DB_NAME,
    process.env.DB_USER,
    process.env.DB_PASS,
    {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: process.env.DB_DIALECT,
        dialectOptions: {
            // Return date/time values as strings, not Date objects.
            dateStrings: true
        },
        logging: false, // Set to console.log to see SQL queries
        define: {
            timestamps: false, // Assuming no `createdAt` and `updatedAt` fields
            // This is important to prevent Sequelize from changing column names to camelCase
            quoteIdentifiers: false,
            freezeTableName: true // Prevent Sequelize from pluralizing table names
        }
    }
);

const models = {};

// Dynamically import all models
const fs = require('fs');
const path = require('path');
const modelsDir = path.join(__dirname, '../models');

// Define the Session model explicitly for connect-session-sequelize
models.Session = sequelize.define('Session', {
  sid: {
    type: Sequelize.STRING,
    primaryKey: true,
  },
  expires: Sequelize.DATE,
  data: Sequelize.TEXT,
});


const loadModels = (dir) => {
  fs.readdirSync(dir, { withFileTypes: true }).forEach(entry => {
    const fullPath = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      // Recurse into subdirectory
      loadModels(fullPath);
    } else if (entry.isFile() && entry.name.indexOf('.') !== 0 && entry.name.slice(-3) === '.js') {
      // Load the model file
      const model = require(fullPath)(sequelize, DataTypes);
      if (model && model.name) {
        models[model.name] = model;
      }
    }
  });
};

loadModels(modelsDir); // Start the recursive loading from the base models directory
// Set up associations
Object.keys(models).forEach(modelName => {
  if (models[modelName].associate) {
    models[modelName].associate(models);
  }
});

console.log('Models loaded from config/database.js:', Object.keys(models));

module.exports = { sequelize, models };
JS;
    }
    
    /**
     * Generates the model file for a specific table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The information about the table.
     * @return string The content of the model file.
     */
    private function generateModelFile($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $fields = "";

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $sequelizeType = $this->mapDbTypeToSequelizeType($colInfo['type'], $colInfo['length']);
            $fields .= "    '$colName': {\n"; // Use original column name as attribute
            $fields .= "      type: $sequelizeType,\n"; // No need for 'field' mapping anymore
            if ($colInfo['isPrimaryKey']) {
                $fields .= "      primaryKey: true,\n";
            }
            if ($colInfo['isAutoIncrement']) {
                $fields .= "      autoIncrement: true,\n";
            }
            $fields .= "    },\n";
        }

        $associations = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refPascalName = $this->pascalCase($refTableName);
                $associations .= "      $pascalName.belongsTo(models.$refPascalName, { foreignKey: '$colName', as: '$refTableName' });\n";
            }
        }

        return <<<JS
module.exports = (sequelize, DataTypes) => {
  const $pascalName = sequelize.define('$pascalName', {
{$fields}
  }, {
    tableName: '$tableName'
  });

  $pascalName.associate = (models) => {
{$associations}
  };

  return $pascalName;
};
JS;
    }

    /**
     * Generates the `schema.js` file for the Node.js project.
     * @return string The content of the `schema.js` file.
     */
    private function generateSchemaJs()
    {
        return <<<JS
const { GraphQLSchema, GraphQLObjectType } = require('graphql');
const { RootQuery } = require('./resolvers');
const { RootMutation } = require('./resolvers');

module.exports = new GraphQLSchema({
    query: RootQuery,
    mutation: RootMutation,
});
JS;
    }

    /**
     * Maps a database column type to a GraphQL type for Node.js.
     *
     * @param string $dbType The database column type.
     * @param int|null $length The length of the column, if applicable.
     * @return string The corresponding GraphQL type.
     */
    public function mapDbTypeToNodeJsGqlType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false || strpos($dbType, 'date') !== false || strpos($dbType, 'timestamp') !== false) {
            return 'GraphQLString';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'GraphQLFloat';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'GraphQLBoolean';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'GraphQLInt';
        }
        return 'GraphQLString'; // Default
    }

    /**
     * Generates the `types.js` file for the Node.js project.
     * @return string The content of the `types.js` file.
     */
    private function generateTypesJs()
    {
        $typeExports = "";
        $typeDefinitions = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $typeName = $pascalName . 'Type';
            $pageTypeName = $pascalName . 'PageType';
            $inputType = $pascalName . 'InputType';

            $typeExports .= "    $typeName,\n";
            $typeExports .= "    $pageTypeName,\n";
            $typeExports .= "    $inputType,\n";

            // --- Object Type ---
            $fields = "";
            foreach ($tableInfo['columns'] as $colName => $colInfo) {
                $gqlType = $this->mapDbTypeToNodeJsGqlType($colInfo['type'], $colInfo['length']);
                $fields .= "        $colName: { type: $gqlType },\n";

                if ($colInfo['isForeignKey']) {
                    $refTableName = $colInfo['references'];
                    $refPascalName = $this->pascalCase($refTableName);
                    $refTypeName = $refPascalName . 'Type';
                    $fields .= "        $refTableName: {\n";
                    $fields .= "            type: $refTypeName,\n";
                    $fields .= "            resolve(parent, args) {\n";
                    $fields .= "                return models.$refPascalName.findByPk(parent['$colName']);\n";
                    $fields .= "            }\n";
                    $fields .= "        },\n";
                }
            }

            $typeDefinitions .= "const $typeName = new GraphQLObjectType({\n";
            $typeDefinitions .= "    name: '$pascalName',\n";
            $typeDefinitions .= "    fields: () => ({\n";
            $typeDefinitions .= rtrim($fields, ",\n") . "\n";
            $typeDefinitions .= "    })\n";
            $typeDefinitions .= "});\n\n";

            // --- Page Type ---
            $typeDefinitions .= "const $pageTypeName = new GraphQLObjectType({\n";
            $typeDefinitions .= "    name: '$pageTypeName',\n";
            $typeDefinitions .= "    fields: () => ({\n";
            $typeDefinitions .= "        items: { type: new GraphQLList($typeName) },\n";
            $typeDefinitions .= "        total: { type: GraphQLInt },\n";
            $typeDefinitions .= "        limit: { type: GraphQLInt },\n";
            $typeDefinitions .= "        page: { type: GraphQLInt },\n";
            $typeDefinitions .= "        totalPages: { type: GraphQLInt },\n";
            $typeDefinitions .= "        hasNext: { type: GraphQLBoolean },\n";
            $typeDefinitions .= "        hasPrevious: { type: GraphQLBoolean },\n";
            $typeDefinitions .= "    })\n";
            $typeDefinitions .= "});\n\n";

            // --- Input Type ---
            $inputFields = "";
            foreach ($tableInfo['columns'] as $colName => $colInfo) {
                if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                    continue;
                }
                $gqlType = $this->mapDbTypeToNodeJsGqlType($colInfo['type'], $colInfo['length']);
                $inputFields .= "        $colName: { type: $gqlType },\n";
            }

            $typeDefinitions .= "const $inputType = new GraphQLInputObjectType({\n";
            $typeDefinitions .= "    name: '$inputType',\n";
            $typeDefinitions .= "    fields: () => ({\n";
            $typeDefinitions .= rtrim($inputFields, ",\n") . "\n";
            $typeDefinitions .= "    })\n";
            $typeDefinitions .= "});\n\n";
        }

        return <<<JS
const {
    GraphQLObjectType,
    GraphQLInputObjectType,
    GraphQLString,
    GraphQLInt,
    GraphQLFloat,
    GraphQLBoolean,
    GraphQLList,
    GraphQLNonNull,
    GraphQLEnumType,
    GraphQLScalarType,
    Kind
} = require('graphql');
const { models } = require('../config/database');

// Custom Scalar for generic Object
const ObjectScalar = new GraphQLScalarType({
    name: 'Object',
    description: 'Arbitrary object',
    parseValue: (value) => {
        return value;
    },
    serialize: (value) => {
        return value;
    },
    parseLiteral: (ast) => {
        switch (ast.kind) {
            case Kind.STRING:
                return ast.value;
            case Kind.BOOLEAN:
                return ast.value;
            case Kind.INT:
                return parseInt(ast.value, 10);
            case Kind.FLOAT:
                return parseFloat(ast.value);
            case Kind.OBJECT:
                const value = Object.create(null);
                ast.fields.forEach(field => {
                    value[field.name.value] = this.parseLiteral(field.value);
                });
                return value;
            case Kind.LIST:
                return ast.values.map(n => this.parseLiteral(n));
            default:
                return null;
        }
    }
});

const SortDirectionEnum = new GraphQLEnumType({
    name: 'SortDirection',
    values: {
        ASC: { value: 'ASC' },
        DESC: { value: 'DESC' },
    }
});

const FilterOperatorEnum = new GraphQLEnumType({
    name: 'FilterOperator',
    values: {
        EQUALS: { value: 'EQUALS' },
        NOT_EQUALS: { value: 'NOT_EQUALS' },
        CONTAINS: { value: 'CONTAINS' },
        GREATER_THAN: { value: 'GREATER_THAN' },
        GREATER_THAN_OR_EQUALS: { value: 'GREATER_THAN_OR_EQUALS' },
        LESS_THAN: { value: 'LESS_THAN' },
        LESS_THAN_OR_EQUALS: { value: 'LESS_THAN_OR_EQUALS' },
        IN: { value: 'IN' },
        NOT_IN: { value: 'NOT_IN' },
    }
});

const SortInputType = new GraphQLInputObjectType({
    name: 'SortInput',
    fields: {
        field: { type: new GraphQLNonNull(GraphQLString) },
        direction: { type: SortDirectionEnum, defaultValue: 'ASC' }
    }
});

const FilterInputType = new GraphQLInputObjectType({
    name: 'FilterInput',
    fields: {
        field: { type: new GraphQLNonNull(GraphQLString) },
        value: { type: ObjectScalar },
        operator: { type: FilterOperatorEnum, defaultValue: 'EQUALS' }
    }
});

$typeDefinitions

module.exports = {
$typeExports
    SortInputType,
    FilterInputType
};
JS;
    }

    /**
     * Generates the `resolvers.js` file for the Node.js project.
     * @return string The content of the `resolvers.js` file.
     */
    private function generateResolversJs()
    {
        $queryFields = "";
        $mutationFields = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pascalName = $this->pascalCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $primaryKey = $this->camelCase($tableInfo['primaryKey']);
            error_log(print_r($tableInfo, true));
            $hasActiveColumn = $tableInfo['hasActiveColumn'];
            $activeField = $this->activeField;
            $pkType = 'GraphQLString';
            foreach($tableInfo['columns'] as $col)
            {
                if($col['isPrimaryKey'])
                {
                    $pkType = $this->mapDbTypeToNodeJsGqlType($col['type'], $col['length']);
                    break;
                }
            }

            // --- Query Resolvers ---
            $queryFields .= "        $camelName: {\n";
            $queryFields .= "            type: types.{$pascalName}Type,\n";
            $queryFields .= "            args: { id: { type: new GraphQLNonNull($pkType) } },\n";
            $queryFields .= "            resolve(parent, args) {\n";
            $queryFields .= "                return models.$pascalName.findByPk(args.id);\n";
            $queryFields .= "            }\n";
            $queryFields .= "        },\n";

            $queryFields .= "        $pluralCamelName: {\n";
            $queryFields .= "            type: types.{$pascalName}PageType,\n";
            $queryFields .= "            args: {\n";
            $queryFields .= "                limit: { type: GraphQLInt },\n";
            $queryFields .= "                offset: { type: GraphQLInt },\n";
            $queryFields .= "                page: { type: GraphQLInt },\n";
            $queryFields .= "                orderBy: { type: new GraphQLList(types.SortInputType) },\n";
            $queryFields .= "                filter: { type: new GraphQLList(types.FilterInputType) },\n";
            $queryFields .= "            },\n";
            $queryFields .= "            async resolve(parent, args) {\n";
            $queryFields .= "                const limit = args.limit || 20;\n";
            $queryFields .= "                let offset = args.offset || 0;\n";
            $queryFields .= "                if (args.page) {\n";
            $queryFields .= "                    offset = (args.page - 1) * limit;\n";
            $queryFields .= "                }\n\n";
            $queryFields .= "                const order = args.orderBy ? args.orderBy.map(o => [o.field, o.direction || 'ASC']) : [];\n\n";
            $queryFields .= "                const where = {};\n";
            $queryFields .= "                if (args.filter) {\n";
            $queryFields .= "                    args.filter.forEach(f => {\n";
            $queryFields .= "                        const op = f.operator || 'EQUALS';\n";
            $queryFields .= "                        const field = f.field;\n";
            $queryFields .= "                        const value = f.value;\n";
            $queryFields .= "                        switch (op) {\n";
            $queryFields .= "                            case 'EQUALS': where[field] = { [Op.eq]: value }; break;\n";
            $queryFields .= "                            case 'NOT_EQUALS': where[field] = { [Op.ne]: value }; break;\n";
            $queryFields .= "                            case 'CONTAINS': where[field] = { [Op.like]: `% \${value}%` }; break;\n";
            $queryFields .= "                            case 'GREATER_THAN': where[field] = { [Op.gt]: value }; break;\n";
            $queryFields .= "                            case 'GREATER_THAN_OR_EQUALS': where[field] = { [Op.gte]: value }; break;\n";
            $queryFields .= "                            case 'LESS_THAN': where[field] = { [Op.lt]: value }; break;\n";
            $queryFields .= "                            case 'LESS_THAN_OR_EQUALS': where[field] = { [Op.lte]: value }; break;\n";
            $queryFields .= "                            case 'IN': where[field] = { [Op.in]: value.split(',') }; break;\n";
            $queryFields .= "                            case 'NOT_IN': where[field] = { [Op.notIn]: value.split(',') }; break;\n";
            $queryFields .= "                        }\n";
            $queryFields .= "                    });\n";
            $queryFields .= "                }\n\n";
            $queryFields .= "                const { count, rows } = await models.$pascalName.findAndCountAll({ where, limit, offset, order });\n\n";
            $queryFields .= "                return {\n";
            $queryFields .= "                    items: rows,\n";
            $queryFields .= "                    total: count,\n";
            $queryFields .= "                    limit: limit,\n";
            $queryFields .= "                    page: Math.floor(offset / limit) + 1,\n";
            $queryFields .= "                    totalPages: Math.ceil(count / limit),\n";
            $queryFields .= "                    hasNext: (offset + limit) < count,\n";
            $queryFields .= "                    hasPrevious: offset > 0,\n";
            $queryFields .= "                };\n";
            $queryFields .= "            }\n";
            $queryFields .= "        },\n";

            // --- Mutation Resolvers ---
            $mutationFields .= "        create$pascalName: {\n";
            $mutationFields .= "            type: types.{$pascalName}Type,\n";
            $mutationFields .= "            args: { input: { type: new GraphQLNonNull(types.{$pascalName}InputType) } },\n";
            $mutationFields .= "            resolve(parent, args) {\n";
            $mutationFields .= "                return models.$pascalName.create(args.input);\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";

            $mutationFields .= "        update$pascalName: {\n";
            $mutationFields .= "            type: types.{$pascalName}Type,\n";
            $mutationFields .= "            args: {\n";
            $mutationFields .= "                id: { type: new GraphQLNonNull($pkType) },\n";
            $mutationFields .= "                input: { type: new GraphQLNonNull(types.{$pascalName}InputType) }\n";
            $mutationFields .= "            },\n";
            $mutationFields .= "            async resolve(parent, args) {\n";
            $mutationFields .= "                const item = await models.$pascalName.findByPk(args.id);\n";
            $mutationFields .= "                if (!item) throw new Error('$pascalName not found');\n";
            $mutationFields .= "                await item.update(args.input);\n";
            $mutationFields .= "                return item;\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";

            if($hasActiveColumn)
            {
            $mutationFields .= "        toggle{$pascalName}Active: {\n";
            $mutationFields .= "            type: types.{$pascalName}Type,\n";
            $mutationFields .= "            args: {\n";
            $mutationFields .= "                id: { type: new GraphQLNonNull($pkType) },\n";
            $mutationFields .= "                $activeField: { type: new GraphQLNonNull(GraphQLBoolean) }\n";
            $mutationFields .= "            },\n";
            $mutationFields .= "            async resolve(parent, args) {\n";
            $mutationFields .= "                const item = await models.$pascalName.findByPk(args.id);\n";
            $mutationFields .= "                if (!item) throw new Error('$pascalName not found');\n";
            $mutationFields .= "                await item.update({ $activeField: args.$activeField });\n";
            $mutationFields .= "                return item;\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";
            }

            $mutationFields .= "        delete$pascalName: {\n";
            $mutationFields .= "            type: GraphQLBoolean,\n";
            $mutationFields .= "            args: { id: { type: new GraphQLNonNull($pkType) } },\n";
            $mutationFields .= "            async resolve(parent, args) {\n";
            $mutationFields .= "                const item = await models.$pascalName.findByPk(args.id);\n";
            $mutationFields .= "                if (!item) throw new Error('$pascalName not found');\n";
            $mutationFields .= "                await item.destroy();\n";
            $mutationFields .= "                return true;\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";
        }

        return <<<JS
const { GraphQLObjectType, GraphQLList, GraphQLNonNull, GraphQLString, GraphQLInt, GraphQLID, GraphQLBoolean } = require('graphql');
const { Op } = require('sequelize');
const { models } = require('../config/database');
const types = require('./types');

const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields: {
$queryFields
    }
});

const RootMutation = new GraphQLObjectType({
    name: 'Mutation',
    fields: {
$mutationFields
    }
});

module.exports = {
    RootQuery,
    RootMutation
};
JS;
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations.\r\n\r\n";
        
        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in `package.json`. Run `npm install` to install them.\r\n\r\n";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must create and configure a `.env` file in the root of the backend project. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```\r\n";
        $manualContent .= "# file: .env\r\n";
        $manualContent .= "\r\n# Database Configuration\r\n";
        $manualContent .= "# Supported dialects: 'mysql', 'postgres', 'sqlite', 'mariadb', 'mssql'\r\n";
        $manualContent .= "# Database Configuration
# Supported dialects: 'mysql', 'postgres', 'sqlite', 'mariadb', 'mssql'
DB_DIALECT={DB_DIALECT}
DB_HOST={DB_HOST}
DB_PORT={DB_PORT}
DB_USER={DB_USER}
DB_PASS={DB_PASS}
DB_NAME={DB_NAME}

# Server Configuration
PORT=4000

# CORS Configuration
# Comma-separated list of allowed origins. Do not use spaces between origins.
CORS_ALLOWED_ORIGINS=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

REQUIRE_LOGIN=true";
        $manualContent .= "```\r\n\r\n";
        $manualContent .= "Make sure to replace `your_database_name`, `your_username`, and `your_password` with your actual database credentials.\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pascalName = $this->pascalCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);

            $manualContent .= "## " . $pascalName . "\r\n\r\n";

            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true);

            $manualContent .= "### Queries\r\n\r\n";
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $pascalName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-" . $camelName . "-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            $manualContent .= "#### Get a list of " . $pluralCamelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $this->pascalCase($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(limit: 10, offset: 0) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString);
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            $manualContent .= "### Mutations\r\n\r\n";
            list($inputFieldsString, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $pascalName . " {\r\n";
            $manualContent .= "  create" . $pascalName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $pascalName . " {\r\n";
            $manualContent .= "  update" . $pascalName . "(id: \"your-" . $camelName . "-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $pascalName . " {\r\n";
            $manualContent .= "  delete" . $pascalName . "(id: \"your-" . $camelName . "-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        // --- API Reference Guide ---
        $manualContent .= "## API Reference Guide\r\n\r\n";
        $manualContent .= "This section provides a reference for common arguments used in list queries.\r\n\r\n";

        // Filtering
        $manualContent .= "### Filtering (`filter`)\r\n\r\n";
        $manualContent .= "The `filter` argument allows you to narrow down results based on field values. It accepts a list of filter objects, which are combined with `AND` logic.\r\n\r\n";
        $manualContent .= "| Operator       | Description                                      | Example                                                |\r\n";
        $manualContent .= "|----------------|--------------------------------------------------|--------------------------------------------------------|\r\n";
        $manualContent .= "| `EQUALS`       | Finds records where the field exactly matches the value. | `{field: \"status\", value: \"published\"}`                |\r\n";
        $manualContent .= "| `NOT_EQUALS`   | Finds records where the field does not match the value. | `{field: \"status\", value: \"archived\", operator: NOT_EQUALS}` |\r\n";
        $manualContent .= "| `CONTAINS`     | Finds records where the text field contains the value (`LIKE '%value%'`). | `{field: \"title\", value: \"love\", operator: CONTAINS}` |\r\n";
        $manualContent .= "| `GREATER_THAN_OR_EQUALS` | Finds records where the numeric/date field is greater than or equal to the value. | `{field: \"price\", value: \"99.99\", operator: GREATER_THAN_OR_EQUALS}` |\r\n";
        $manualContent .= "| `GREATER_THAN` | Finds records where the numeric/date field is greater than the value. | `{field: \"price\", value: \"100\", operator: GREATER_THAN}` |\r\n";
        $manualContent .= "| `LESS_THAN_OR_EQUALS`    | Finds records where the numeric/date field is less than or equal to the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN_OR_EQUALS}`   |\r\n";
        $manualContent .= "| `LESS_THAN`    | Finds records where the numeric/date field is less than the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN}`   |\r\n";
        $manualContent .= "| `IN` / `NOT_IN` | Finds records where the field value is in (or not in) a comma-separated list of values. | `{field: \"category_id\", value: \"1,2,3\", operator: IN}` |\r\n\r\n";

        // Sorting
        $manualContent .= "### Sorting (`orderBy`)\r\n\r\n";
        $manualContent .= "The `orderBy` argument sorts the results. It accepts a list of sort objects.\r\n\r\n";
        $manualContent .= "- `field`: The name of the field to sort by (e.g., `\"name\"`).\r\n";
        $manualContent .= "- `direction`: The sort direction. Can be `ASC` (ascending) or `DESC` (descending). Defaults to `ASC`.\r\n\r\n";
        $manualContent .= "**Example:** `orderBy: [{field: \"release_date\", direction: DESC}]`\r\n\r\n";

        // Pagination
        $manualContent .= "### Pagination (`limit` & `offset`)\r\n\r\n";
        $manualContent .= "- `limit`: Specifies the maximum number of records to return.\r\n";
        $manualContent .= "- `offset`: Specifies the number of records to skip from the beginning.\r\n\r\n";
        $manualContent .= "**Example:** To get the second page of 10 items: `limit: 10, offset: 10`\r\n\r\n";

        return $manualContent;
    }
}