<?php

namespace AppBuilder;

/**
 * The `GraphQLGeneratorNodeJs` class is designed to automatically generate a complete Node.js GraphQL API
 * from a JSON file that defines database entities. It uses Express.js as the web server,
 * `express-graphql` for the GraphQL endpoint, and Sequelize as the ORM for database interaction.
 * The generated code follows a modular structure, separating models, types, resolvers, and the main server logic.
 *
 * @package AppBuilder
 */
class GraphQLGeneratorNodeJs extends GraphQLGeneratorBase
{
    /**
     * Constructor for the `GraphQLGeneratorNodeJs` class.
     *
     * @param array $analyzedSchema The analyzed database schema.
     * @param string $displayField The default display field for entities.
     * @param string|null $activeField The field used to indicate active records, if any.
     * @param array $backendHandledColumns Columns that are managed by the backend.
     */
    private function mapDbTypeToSequelizeType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false) {
            return "DataTypes.STRING($length)";
        }
        if (strpos($dbType, 'text') !== false)
        {
            return 'DataTypes.STRING';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return "DataTypes.DATE,\r\n\t\t\tdateFormat: 'YYYY-MM-DD HH:mm:ss'";
        }
        if (strpos($dbType, 'date') !== false) {
            return "DataTypes.DATE,\r\n\t\t\tdateFormat: 'YYYY-MM-DD'";
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'double') !== false) {
            return 'DataTypes.DOUBLE';
        }
        if (strpos($dbType, 'float') !== false) {
            return 'DataTypes.FLOAT';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'DataTypes.BOOLEAN';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'DataTypes.INTEGER';
        }
        return 'DataTypes.STRING'; // Default
    }

    /**
     * Generates the complete set of files for the Node.js GraphQL API.
     *
     * @return array An array of files, each represented as an associative array with 'name' and 'content' keys.
     */
    public function generate()
    {
        $files = [];
        $files[] = ['name' => 'package.json', 'content' => $this->generatePackageJson()];
        $files[] = ['name' => '.env', 'content' => $this->generateEnvFile()];
        $files[] = ['name' => 'server.js', 'content' => $this->generateServerJs()];
        $files[] = ['name' => 'schema/schema.js', 'content' => $this->generateSchemaJs()];
        $files[] = ['name' => 'schema/types.js', 'content' => $this->generateTypesJs()];
        $files[] = ['name' => 'schema/resolvers.js', 'content' => $this->generateResolversJs()];
        $files[] = ['name' => 'config/frontend-config.json', 'content' => $this->generateFrontendConfigJson()];

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $files[] = ['name' => "models/$pascalName.js", 'content' => $this->generateModelFile($tableName, $tableInfo)];
        }

        return $files;
    }

    /**
     * Generates the `package.json` file for the Node.js project.
     *
     * @return string The content of the `package.json` file.
     */
    private function generatePackageJson()
    {
        return <<<JSON
{
    "name": "graphql-nodejs-api",
    "version": "1.0.0",
    "description": "GraphQL API generated by MagicAppBuilder",
    "main": "server.js",
    "scripts": {
        "start": "node server.js",
        "dev": "nodemon server.js"
    },
    "dependencies": {
        "multer": "^1.4.5-lts.1",
        "connect-session-sequelize": "^7.1.7",
        "cors": "^2.8.5",
        "dotenv": "^16.0.3",
        "express": "^4.18.2",
        "express-graphql": "^0.12.0",
        "graphql": "^15.8.0",
        "mysql2": "^3.2.0",
        "pg": "^8.10.0",
        "sequelize": "^6.29.3",
        "express-session": "^1.18.0",
        "sqlite3": "^5.1.6"
    },
    "devDependencies": {
        "nodemon": "^2.0.22"
    }
}
JSON;
    }

    /**
     * Generates the `.env` file for the Node.js project.
     * @return string The content of the `.env` file.
     */
    private function generateEnvFile()
    {
        return <<<ENV
# Database Configuration
# Supported dialects: 'mysql', 'postgres', 'sqlite', 'mariadb', 'mssql'
DB_DIALECT={DB_DIALECT}
DB_HOST={DB_HOST}
DB_PORT={DB_PORT}
DB_USER={DB_USER}
DB_PASS={DB_PASS}
DB_NAME={DB_NAME}
DB_FILE={DB_FILE}

# Server Configuration
PORT=4000

# CORS Configuration
# Comma-separated list of allowed origins. Do not use spaces between origins.
CORS_ALLOWED_ORIGINS=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

REQUIRE_LOGIN=true
ENV;
    }

    /**
     * Generates the `server.js` file for the Node.js project.
     * @return string The content of the `server.js` file.
     */
    private function generateServerJs()
    {
        return <<<JS
require('dotenv').config();
const express = require('express');
const { graphqlHTTP } = require('express-graphql');
const cors = require('cors');
const schema = require('./schema/schema');
const fs = require('fs');
const path = require('path');
const { sequelize, models } = require('./config/database');
const session = require('express-session');
const SequelizeStore = require('connect-session-sequelize')(session.Store);
const crypto = require('crypto');
const multer = require('multer');
const conditionalAuth = require('./middleware/conditionalAuth');
const profileRoutes = require('./routes/profileRoutes');
const adminRoutes = require('./routes/adminRoutes');
const messageRoutes = require('./routes/messageRoutes');
const notificationRoutes = require('./routes/notificationRoutes');

const app = express();

// CORS configuration
const allowedOrigins = process.env.CORS_ALLOWED_ORIGINS ? process.env.CORS_ALLOWED_ORIGINS.split(',') : [];

const corsOptions = {
    origin: (origin, callback) => {
        // Allow requests with no origin (like mobile apps or curl requests)
        if (!origin) return callback(null, true);
    
        if (allowedOrigins.length === 0 || allowedOrigins.indexOf(origin) !== -1) {
            callback(null, true);
        } else {
            callback(new Error('Not allowed by CORS'));
        }
    },
    credentials: true,
};

// Middleware to parse JSON bodies
app.use(express.json());

// Middleware to parse URL-encoded bodies (for form data)
app.use(express.urlencoded({ extended: true }));

// Apply CORS after body parsers
app.use(cors(corsOptions));

// Session configuration
const sessionStore = new SequelizeStore({
    db: sequelize,
    table: 'Session', // This should match the table name of the model
    modelKey: 'Session' // Tell the store to look for models.Session
});

app.use(
    session({
        secret: process.env.SESSION_SECRET || 'a-very-secret-key-for-development',
        store: sessionStore,
        resave: false,
        saveUninitialized: false,
        cookie: {
            maxAge: 24 * 60 * 60 * 1000, // 24 hours
            // secure: process.env.NODE_ENV === 'production', // Enable in production for HTTPS
            httpOnly: true
        },
    })
);

// Serve static files from the 'public' directory
app.use(express.static(path.join(__dirname, 'public')));

// Endpoint to serve frontend configuration
app.get('/frontend-config.json', conditionalAuth, (req, res) => {
    // Set headers to prevent browser caching
    res.set({
        'Cache-Control': 'no-store, no-cache, must-revalidate, proxy-revalidate',
        'Pragma': 'no-cache',
        'Expires': '0'
    });

    const configPath = path.join(__dirname, 'config', 'frontend-config.json');
    res.sendFile(configPath, (err) => {
        if (err) {
            console.error('Error sending frontend-config.json:', err);
            if (!res.headersSent) {
                res.status(500).send({ error: 'Could not load frontend configuration.' });
            }
        }
    });
});

// Endpoint to serve available languages configuration
app.get('/available-language.json', (req, res) => {
    const langPath = path.join(__dirname, 'public', 'langs', 'available-language.json');
    res.sendFile(langPath, (err) => {
        if (err) {
            console.error('Error sending available-language.json:', err);
            if (!res.headersSent) {
                res.status(404).send({ error: 'Available languages configuration not found.' });
            }
        }
    });
});

// Endpoint to serve available theme
app.get('/available-theme.json', (req, res) => {
    const themesPath = path.join(__dirname, 'public', 'assets', 'themes');
    fs.readdir(themesPath, { withFileTypes: true }, (err, dirents = []) => {
        if (err) {
            console.error('Error reading themes directory:', err);
            return res.status(500).send({ error: 'Could not read themes directory.' });
        }

        const themes = dirents
            .filter(dirent => dirent.isDirectory())
            .map(dirent => dirent.name)
            .filter(themeName => {
                const stylePath = path.join(themesPath, themeName, 'style.min.css');
                return fs.existsSync(stylePath);
            })
            .map(themeName => ({
                name: themeName,
                title: themeName.replace(/[-_]/g, ' ').replace(/\b\w/g, char => char.toUpperCase())
            }));

        res.json(themes);
    });
});

// --- Auth Endpoints ---

// Initialize multer for parsing multipart/form-data
const upload = multer();

// POST /login
app.post('/login', upload.none(), async (req, res) => {
    const { username, password } = req.body;

    if (!username || !password) {
        return res.status(400).json({ success: false, message: 'Username and password are required.' });
    }

    try {
        // Ensure the admin model is loaded before attempting to use it
        if (!models.admin) {
            console.error('Error: Admin model (models.admin) is undefined. Please check if models/admin.js exists and is correctly defined.');
            return res.status(500).json({ success: false, message: 'Server configuration error: Admin model not found.' });
        }
        const user = await models.admin.findOne({ where: { username } });

        // Replicate the double sha1 hashing
        const hash1 = crypto.createHash('sha1').update(password).digest('hex');
        const passwordHash = crypto.createHash('sha1').update(hash1).digest('hex');

        if (user && passwordHash === user.password) {
            // Set session on successful login
            req.session.username = user.username;
            req.session.userId = user.admin_id;
            req.session.password = hash1;

            return res.json({ success: true });
        } else {
            return res.status(401).json({ success: false, message: 'Invalid credentials' });
        }
    } catch (error) {
        console.error('Login error:', error);
        return res.status(500).json({ success: false, message: 'An internal error occurred during login.' });
    }
});

// POST /logout
app.post('/logout', (req, res) => {
    req.session.destroy(err => {
        if (err) {
            console.error('Logout error:', err);
            return res.status(500).json({ success: false, message: 'Could not log out, please try again.' });
        }
        // Clear the cookie on the client side
        res.clearCookie('connect.sid'); // The default session cookie name
        return res.json({ success: true });
    });
});


// Use the profile routes
app.use('/', profileRoutes);
app.use('/', adminRoutes);
app.use('/', messageRoutes);
app.use('/', notificationRoutes);

app.use('/graphql', conditionalAuth, graphqlHTTP((req) => ({
    schema: schema,
    graphiql: {
        headerEditorEnabled: true,
    },
    context: { req: req }
})));

const PORT = process.env.PORT || 4000;

sequelize.authenticate()
    .then(() => {
        console.log('Database connection has been established successfully.');
        sequelize.sync(); // Sync all models, including the Session table
        app.listen(PORT, () => {
            console.log(`Server running on http://localhost:\${PORT}/graphql`);
        });
    })
    .catch(err => {
        console.error('Unable to connect to the database:', err);
    });
JS;
    }

    /**
     * Generates the `database.js` file for the Node.js project.
     * @return string The content of the `database.js` file.
     */
    private function generateDatabaseJs()
    {
        return <<<JS
const { Sequelize, DataTypes } = require('sequelize');

const sequelize = new Sequelize(
    process.env.DB_NAME,
    process.env.DB_USER,
    process.env.DB_PASS,
    {
        host: process.env.DB_HOST,
        port: process.env.DB_PORT,
        dialect: process.env.DB_DIALECT,
        dialectOptions: {
            // Return date/time values as strings, not Date objects.
            dateStrings: true
        },
        logging: false, // Set to console.log to see SQL queries
        define: {
            timestamps: false, // Assuming no `createdAt` and `updatedAt` fields
            // This is important to prevent Sequelize from changing column names to camelCase
            quoteIdentifiers: false,
            freezeTableName: true // Prevent Sequelize from pluralizing table names
        }
    }
);

const models = {};

// Dynamically import all models
const fs = require('fs');
const path = require('path');
const modelsDir = path.join(__dirname, '../models');

// Define the Session model explicitly for connect-session-sequelize
models.Session = sequelize.define('Session', {
    sid: {
        type: Sequelize.STRING,
        primaryKey: true,
    },
    expires: Sequelize.DATE,
    data: Sequelize.TEXT,
});


const loadModels = (dir) => {
    fs.readdirSync(dir, { withFileTypes: true }).forEach(entry => {
        const fullPath = path.join(dir, entry.name);
        if (entry.isDirectory()) {
            // Recurse into subdirectory
            loadModels(fullPath);
        } else if (entry.isFile() && entry.name.indexOf('.') !== 0 && entry.name.slice(-3) === '.js') {
            // Load the model file
            const model = require(fullPath)(sequelize, DataTypes);
            if (model && model.name) {
                models[model.name] = model;
            }
        }
    });
};

loadModels(modelsDir); // Start the recursive loading from the base models directory
// Set up associations
Object.keys(models).forEach(modelName => {
    if (models[modelName].associate) {
        models[modelName].associate(models);
    }
});

console.log('Models loaded from config/database.js:', Object.keys(models));

module.exports = { sequelize, models };
JS;
    }
    
    /**
     * Generates the model file for a specific table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The information about the table.
     * @return string The content of the model file.
     */
    private function generateModelFile($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $fields = "";

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $sequelizeType = $this->mapDbTypeToSequelizeType($colInfo['type'], $colInfo['length']);
            $fields .= "\t\t'$colName': {\n"; // Use original column name as attribute
            $fields .= "\t\t\ttype: $sequelizeType,\n"; // No need for 'field' mapping anymore
            if ($colInfo['isPrimaryKey']) {
                $fields .= "\t\t\tprimaryKey: true,\n";
            }
            if ($colInfo['isAutoIncrement']) {
                $fields .= "\t\t\tautoIncrement: true,\n";
            }
            $fields .= "\t\t},\n";
        }

        $associations = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refPascalName = $this->pascalCase($refTableName);
                $associations .= "\t\t$pascalName.belongsTo(models.$refPascalName, { foreignKey: '$colName', as: '$refTableName' });\n";
            }
        }

        return <<<JS
/**
 * {$pascalName} Model Definition
 *
 * This model represents the `{$tableName}` table and defines
 * its columns, primary keys, and associations.
 *
 * @param {import('sequelize').Sequelize} sequelize
 * @param {import('sequelize').DataTypes} DataTypes
 * @returns {import('sequelize').Model} SalesDetail
 */
function define{$pascalName}Model(sequelize, DataTypes) {
    const $pascalName = sequelize.define('$pascalName', {
{$fields}
    }, {
        tableName: '$tableName'
    });

    $pascalName.associate = (models) => {
{$associations}
    };

    return $pascalName;
}

module.exports = define{$pascalName}Model;
JS;
    }

    /**
     * Generates the `schema.js` file for the Node.js project.
     * @return string The content of the `schema.js` file.
     */
    private function generateSchemaJs()
    {
        return <<<JS
const { GraphQLSchema, GraphQLObjectType } = require('graphql');
const { RootQuery } = require('./resolvers');
const { RootMutation } = require('./resolvers');

module.exports = new GraphQLSchema({
    query: RootQuery,
    mutation: RootMutation,
});
JS;
    }

    /**
     * Maps a database column type to a GraphQL type for Node.js.
     *
     * @param string $dbType The database column type.
     * @param int|null $length The length of the column, if applicable.
     * @return string The corresponding GraphQL type.
     */
    public function mapDbTypeToNodeJsGqlType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false || strpos($dbType, 'date') !== false || strpos($dbType, 'timestamp') !== false) {
            return 'GraphQLString';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'GraphQLFloat';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'GraphQLBoolean';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'GraphQLInt';
        }
        return 'GraphQLString'; // Default
    }

    /**
     * Generates GraphQL field definitions for the given table information.
     *
     * This method iterates through each column in the provided table metadata
     * and maps its database type to the corresponding Node.js GraphQL type.
     * For columns that represent foreign keys, it also generates a resolver
     * to fetch the referenced entity using Sequelize's `findByPk` method.
     *
     * @param array $tableInfo  An associative array containing table metadata,
     *                          including a 'columns' array where each key is
     *                          a column name and each value contains details
     *                          such as type, length, and foreign key information.
     *
     * @return string  A formatted string representing GraphQL field definitions
     *                 that can be injected into a GraphQL object type.
     */
    private function generateField($tableInfo)
    {
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapDbTypeToNodeJsGqlType($colInfo['type'], $colInfo['length']);
            $fields .= "        $colName: { type: $gqlType },\n";

            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refPascalName = $this->pascalCase($refTableName);
                $refTypeName = $refPascalName . 'Type';
                $fields .= "        $refTableName: {\n";
                $fields .= "            type: $refTypeName,\n";
                $fields .= "            resolve(parent, args) {\n";
                $fields .= "                return models.$refPascalName.findByPk(parent['$colName']);\n";
                $fields .= "            }\n";
                $fields .= "        },\n";
            }
        }
        return $fields;
    }

    /**
     * Generates the `types.js` file for the Node.js project.
     * @return string The content of the `types.js` file.
     */
    private function generateTypesJs()
    {
        $typeExports = "";
        $typeDefinitions = "";

        $backendHandledColumnNames = $this->getBackendHandledColumnNames();

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $typeName = $pascalName . 'Type';
            $pageTypeName = $pascalName . 'PageType';
            $inputType = $pascalName . 'InputType';

            $typeExports .= "    $typeName,\n";
            $typeExports .= "    $pageTypeName,\n";
            $typeExports .= "    $inputType,\n";

            // --- Object Type ---
            $fields = $this->generateField($tableInfo);        

            $typeDefinitions .= "const $typeName = new GraphQLObjectType({\n";
            $typeDefinitions .= "    name: '$pascalName',\n";
            $typeDefinitions .= "    fields: () => ({\n";
            $typeDefinitions .= rtrim($fields, ",\n") . "\n";
            $typeDefinitions .= "    })\n";
            $typeDefinitions .= "});\n\n";

            // --- Page Type ---
            $typeDefinitions .= "const $pageTypeName = new GraphQLObjectType({\n";
            $typeDefinitions .= "    name: '$pageTypeName',\n";
            $typeDefinitions .= "    fields: () => ({\n";
            $typeDefinitions .= "        items: { type: new GraphQLList($typeName) },\n";
            $typeDefinitions .= "        total: { type: GraphQLInt },\n";
            $typeDefinitions .= "        limit: { type: GraphQLInt },\n";
            $typeDefinitions .= "        page: { type: GraphQLInt },\n";
            $typeDefinitions .= "        totalPages: { type: GraphQLInt },\n";
            $typeDefinitions .= "        hasNext: { type: GraphQLBoolean },\n";
            $typeDefinitions .= "        hasPrevious: { type: GraphQLBoolean },\n";
            $typeDefinitions .= "    })\n";
            $typeDefinitions .= "});\n\n";

            // --- Input Type ---
            $inputFields = "";
            foreach ($tableInfo['columns'] as $colName => $colInfo) {
                if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                    continue;
                }
                if(in_array($colName, $backendHandledColumnNames))
                {
                    continue;
                }
                $gqlType = $this->mapDbTypeToNodeJsGqlType($colInfo['type'], $colInfo['length']);
                $inputFields .= "        $colName: { type: $gqlType },\n";
            }

            $typeDefinitions .= "const $inputType = new GraphQLInputObjectType({\n";
            $typeDefinitions .= "    name: '$inputType',\n";
            $typeDefinitions .= "    fields: () => ({\n";
            $typeDefinitions .= rtrim($inputFields, ",\n") . "\n";
            $typeDefinitions .= "    })\n";
            $typeDefinitions .= "});\n\n";
        }

        return <<<JS
const {
    GraphQLObjectType,
    GraphQLInputObjectType,
    GraphQLString,
    GraphQLInt,
    GraphQLFloat,
    GraphQLBoolean,
    GraphQLList,
    GraphQLNonNull,
    GraphQLEnumType,
    GraphQLScalarType,
    Kind
} = require('graphql');
const { models } = require('../config/database');

// Custom Scalar for generic Object
const ObjectScalar = new GraphQLScalarType({
    name: 'Object',
    description: 'Arbitrary object',
    parseValue: (value) => {
        return value;
    },
    serialize: (value) => {
        return value;
    },
    parseLiteral: (ast) => {
        switch (ast.kind) {
            case Kind.STRING:
                return ast.value;
            case Kind.BOOLEAN:
                return ast.value;
            case Kind.INT:
                return parseInt(ast.value, 10);
            case Kind.FLOAT:
                return parseFloat(ast.value);
            case Kind.OBJECT:
                const value = Object.create(null);
                ast.fields.forEach(field => {
                    value[field.name.value] = this.parseLiteral(field.value);
                });
                return value;
            case Kind.LIST:
                return ast.values.map(n => this.parseLiteral(n));
            default:
                return null;
        }
    }
});

const SortDirectionEnum = new GraphQLEnumType({
    name: 'SortDirection',
    values: {
        ASC: { value: 'ASC' },
        DESC: { value: 'DESC' },
    }
});

const FilterOperatorEnum = new GraphQLEnumType({
    name: 'FilterOperator',
    values: {
        EQUALS: { value: 'EQUALS' },
        NOT_EQUALS: { value: 'NOT_EQUALS' },
        CONTAINS: { value: 'CONTAINS' },
        GREATER_THAN: { value: 'GREATER_THAN' },
        GREATER_THAN_OR_EQUALS: { value: 'GREATER_THAN_OR_EQUALS' },
        LESS_THAN: { value: 'LESS_THAN' },
        LESS_THAN_OR_EQUALS: { value: 'LESS_THAN_OR_EQUALS' },
        IN: { value: 'IN' },
        NOT_IN: { value: 'NOT_IN' },
    }
});

const SortInputType = new GraphQLInputObjectType({
    name: 'SortInput',
    fields: {
        field: { type: new GraphQLNonNull(GraphQLString) },
        direction: { type: SortDirectionEnum, defaultValue: 'ASC' }
    }
});

const FilterInputType = new GraphQLInputObjectType({
    name: 'FilterInput',
    fields: {
        field: { type: new GraphQLNonNull(GraphQLString) },
        value: { type: ObjectScalar },
        operator: { type: FilterOperatorEnum, defaultValue: 'EQUALS' }
    }
});

$typeDefinitions

module.exports = {
$typeExports
    SortInputType,
    FilterInputType
};
JS;
    }

    /**
     * Generates the `resolvers.js` file for the Node.js project.
     * @return string The content of the `resolvers.js` file.
     */
    private function generateResolversJs()
    {
        $queryFields = "";
        $mutationFields = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pascalName = $this->pascalCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $primaryKey = $this->camelCase($tableInfo['primaryKey']);
            $hasActiveColumn = $tableInfo['hasActiveColumn'];
            $activeField = $this->activeField;
            $pkType = 'GraphQLString';
            $pkCol = null;
            $pkColName = null;
            $inputColumns = [];
            $skippedColumns = [];
            $backendHandledColumnNames = $this->getBackendHandledColumnNames();
            foreach($tableInfo['columns'] as $colName => $col)
            {
                $inputColumns[] = $colName;
                if(in_array($colName, $backendHandledColumnNames))
                {
                    $skippedColumns[] = $colName;
                }
            }
            foreach($tableInfo['columns'] as $colName => $col)
            {
                if($col['isPrimaryKey'])
                {
                    $pkCol = $col;
                    $pkColName = $colName;
                    $pkType = $this->mapDbTypeToNodeJsGqlType($col['type'], $col['length']);
                    break;
                }
            }

            $auditTrailInsert = "";
            $auditTrailUpdate = "";
            $auditTrailToggle = "";

            foreach($this->backendHandledColumns as $key=>$col)
            {
                
                $colName = $col['columnName'];
                if(in_array($colName, $inputColumns) || in_array($colName, $skippedColumns))
                {
                    if($key == 'timeCreate')
                    {
                        $auditTrailInsert .= "                args.input.$colName = now;\n";
                    }
                    if($key == 'adminCreate')
                    {
                        $auditTrailInsert .= "                args.input.$colName = adminId;\n";
                    }
                    if($key == 'ipCreate')
                    {
                        $auditTrailInsert .= "                args.input.$colName = ip;\n";
                    }
                    
                    if($key == 'timeEdit')
                    {
                        $auditTrailInsert .= "                args.input.$colName = now;\n";
                        $auditTrailUpdate .= "                args.input.$colName = now;\n";
                        $auditTrailToggle .= "                toggle.$colName = now;\n";
                    }
                    if($key == 'adminEdit')
                    {
                        $auditTrailInsert .= "                args.input.$colName = adminId;\n";
                        $auditTrailUpdate .= "                args.input.$colName = adminId;\n";
                        $auditTrailToggle .= "                toggle.$colName = adminId;\n";
                    }
                    if($key == 'ipEdit')
                    {
                        $auditTrailInsert .= "                args.input.$colName = ip;\n";
                        $auditTrailUpdate .= "                args.input.$colName = ip;\n";
                        $auditTrailToggle .= "                toggle.$colName = ip;\n";
                    }

                }
            }

            // --- Query Resolvers ---
            $queryFields .= "        $camelName: {\n";
            $queryFields .= "            type: types.{$pascalName}Type,\n";
            $queryFields .= "            args: { id: { type: new GraphQLNonNull($pkType) } },\n";
            $queryFields .= "            resolve: async (parent, args, context) => {\n";
            $queryFields .= "                const t = getTranslator(context.req);\n";
            $queryFields .= "                const data = await models.{$pascalName}.findByPk(args.id);\n";
            $queryFields .= "                if (!data) {\n";
            $queryFields .= "                    throw new Error(t('item_not_found', '$pascalName'));\n";
            $queryFields .= "                }\n";
            $queryFields .= "                return formatItemDates(data);\n";
            $queryFields .= "            }\n";
            $queryFields .= "        },\n";

            $queryFields .= "        $pluralCamelName: {\n";
            $queryFields .= "            type: types.{$pascalName}PageType,\n";
            $queryFields .= "            args: {\n";
            $queryFields .= "                limit: { type: GraphQLInt },\n";
            $queryFields .= "                offset: { type: GraphQLInt },\n";
            $queryFields .= "                page: { type: GraphQLInt },\n";
            $queryFields .= "                orderBy: { type: new GraphQLList(types.SortInputType) },\n";
            $queryFields .= "                filter: { type: new GraphQLList(types.FilterInputType) },\n";
            $queryFields .= "            },\n";
            $queryFields .= "            async resolve(parent, args) {\n";
            $queryFields .= "                const limit = args.limit || 20;\n";
            $queryFields .= "                let offset = args.offset || 0;\n";
            $queryFields .= "                if (args.page) {\n";
            $queryFields .= "                    offset = (args.page - 1) * limit;\n";
            $queryFields .= "                }\n\n";
            $queryFields .= "                const order = args.orderBy ? args.orderBy.map(o => [o.field, o.direction || 'ASC']) : [];\n\n";
            $queryFields .= "                const where = buildWhereClause(args.filter);\n\n";
            $queryFields .= "                const { count, rows } = await models.$pascalName.findAndCountAll({ where, limit, offset, order });\n\n";
            $queryFields .= "                return {\n";
            $queryFields .= "                    items: rows.map(formatItemDates),\n";
            $queryFields .= "                    total: count,\n";
            $queryFields .= "                    limit: limit,\n";
            $queryFields .= "                    page: Math.floor(offset / limit) + 1,\n";
            $queryFields .= "                    totalPages: Math.ceil(count / limit),\n";
            $queryFields .= "                    hasNext: (offset + limit) < count,\n";
            $queryFields .= "                    hasPrevious: offset > 0,\n";
            $queryFields .= "                };\n";
            $queryFields .= "            }\n";
            $queryFields .= "        },\n";

            // --- Mutation Resolvers ---
            $mutationFields .= "        create$pascalName: {\n";
            $mutationFields .= "            type: types.{$pascalName}Type,\n";
            $mutationFields .= "            args: { input: { type: new GraphQLNonNull(types.{$pascalName}InputType) } },\n";
            $mutationFields .= "            async resolve(parent, args, context) {\n";
            $mutationFields .= "                const { session } = context.req;\n";
            $mutationFields .= "                const ip = getIp(context.req);\n";
            $mutationFields .= "                const adminId = session.userId;\n";
            $mutationFields .= "                const now = toMySqlDateTime();\n";
            

            if(isset($pkCol))
            {
                if(isset($pkCol['primaryKeyValue']) && $pkCol['primaryKeyValue'] == 'autogenerated')
                {
                    $mutationFields .= "                args.input.{$pkColName} = uuidv4();\r\n";
                }
            }

            $mutationFields .= $auditTrailInsert;


            $mutationFields .= "                let newItem = await models.$pascalName.create(args.input);\n";
            $mutationFields .= "                return formatItemDates(newItem);\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";

            $mutationFields .= "        update$pascalName: {\n";
            $mutationFields .= "            type: types.{$pascalName}Type,\n";
            $mutationFields .= "            args: {\n";
            $mutationFields .= "                id: { type: new GraphQLNonNull($pkType) },\n";
            $mutationFields .= "                input: { type: new GraphQLNonNull(types.{$pascalName}InputType) }\n";
            $mutationFields .= "            },\n";
            $mutationFields .= "            async resolve(parent, args, context) {\n";
            $mutationFields .= "                const t = getTranslator(context.req);\n";
            $mutationFields .= "                const { session } = context.req;\n";
            $mutationFields .= "                const ip = getIp(context.req);\n";
            $mutationFields .= "                const adminId = session.userId;\n";
            $mutationFields .= "                const now = toMySqlDateTime();\n";
            $mutationFields .= "                const item = await models.$pascalName.findByPk(args.id);\n";
            $mutationFields .= "                if (!item) throw new Error(t('item_not_found', '$pascalName'));\n";
            $mutationFields .= $auditTrailUpdate;
            $mutationFields .= "                await item.update(args.input);\n";
            $mutationFields .= "                return formatItemDates(item);\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";

            if($hasActiveColumn)
            {
            $mutationFields .= "        toggle{$pascalName}Active: {\n";
            $mutationFields .= "            type: types.{$pascalName}Type,\n";
            $mutationFields .= "            args: {\n";
            $mutationFields .= "                id: { type: new GraphQLNonNull($pkType) },\n";
            $mutationFields .= "                $activeField: { type: new GraphQLNonNull(GraphQLBoolean) }\n";
            $mutationFields .= "            },\n";
            $mutationFields .= "            async resolve(parent, args, context) {\n";
            $mutationFields .= "                const t = getTranslator(context.req);\n";
            $mutationFields .= "                const { session } = context.req;\n";
            $mutationFields .= "                const ip = getIp(context.req);\n";
            $mutationFields .= "                const adminId = session.userId;\n";
            $mutationFields .= "                const now = toMySqlDateTime();\n";
            $mutationFields .= "                const item = await models.$pascalName.findByPk(args.id);\n";
            $mutationFields .= "                if (!item) throw new Error(t('item_not_found', '$pascalName'));\n";
            $mutationFields .= "                let toggle = { $activeField: args.$activeField };\n";
            $mutationFields .= $auditTrailToggle;
            $mutationFields .= "                await item.update(toggle);\n";
            $mutationFields .= "                return formatItemDates(item);\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";
            }

            $mutationFields .= "        delete$pascalName: {\n";
            $mutationFields .= "            type: GraphQLBoolean,\n";
            $mutationFields .= "            args: { id: { type: new GraphQLNonNull($pkType) } },\n";
            $mutationFields .= "            async resolve(parent, args, context) {\n";
            $mutationFields .= "                const t = getTranslator(context.req);\n";
            $mutationFields .= "                const item = await models.$pascalName.findByPk(args.id);\n";
            $mutationFields .= "                if (!item) throw new Error(t('item_not_found', '$pascalName'));\n";
            $mutationFields .= "                await item.destroy();\n";
            $mutationFields .= "                return true;\n";
            $mutationFields .= "            }\n";
            $mutationFields .= "        },\n";
        }

        return <<<JS
const { buildWhereClause } = require('./utils');
const { GraphQLObjectType, GraphQLList, GraphQLNonNull, GraphQLString, GraphQLInt, GraphQLID, GraphQLBoolean } = require('graphql');
const { getTranslator } = require('../utils/i18n');
const { models } = require('../config/database');
const { toMySqlDateTime, formatDate } = require('../utils/date');
const types = require('./types');
const { v4: uuidv4 } = require('uuid');

const getIp = (req) => {
    let ip = req.ip;
    if (ip?.startsWith('::ffff:')) {
        return ip.slice(7);
    }
    return ip;
}

const formatItemDates = (item) => {
    if (!item) return null;

    const newItem = { ...item.get({ plain: true }) };
    const attributes = item.constructor.rawAttributes;

    for (const key in newItem) {
        if (Object.hasOwn(newItem, key) && attributes[key] && newItem[key]) {
            if (attributes[key].dateFormat) {
                newItem[key] = formatDate(new Date(newItem[key]), attributes[key].dateFormat);
            }
        }
    }
    return newItem;
};


const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields: {
$queryFields
    }
});

const RootMutation = new GraphQLObjectType({
    name: 'Mutation',
    fields: {
$mutationFields
    }
});

module.exports = {
    RootQuery,
    RootMutation
};
JS;
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations.\r\n\r\n";
        
        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in `package.json`. 

To install all dependencies, run:

```
npm install

```

To start the application, run:

```
npm run dev

```

";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must create and configure a `.env` file in the root of the backend project. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```\r\n";
        $manualContent .= "# file: .env\r\n";
        $manualContent .= "\r\n# Database Configuration\r\n";
        $manualContent .= "# Supported dialects: 'mysql', 'postgres', 'sqlite', 'mariadb', 'mssql'\r\n";
        $manualContent .= "# Database Configuration
# Supported dialects: 'mysql', 'postgres', 'sqlite', 'mariadb', 'mssql'
DB_DIALECT={DB_DIALECT}
DB_HOST={DB_HOST}
DB_PORT={DB_PORT}
DB_USER={DB_USER}
DB_PASS={DB_PASS}
DB_NAME={DB_NAME}

# Server Configuration
PORT=4000

# CORS Configuration
# Comma-separated list of allowed origins. Do not use spaces between origins.
CORS_ALLOWED_ORIGINS=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

REQUIRE_LOGIN=true
";
        $manualContent .= "```\r\n\r\n";
        $manualContent .= "Make sure to replace `your_database_name`, `your_username`, and `your_password` with your actual database credentials.\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        $manualContent .= $this->generateExample();

        return $manualContent;
    }
}