<?php

namespace AppBuilder;

use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorGo` class is a tool to automatically generate a complete Go (Golang) GraphQL API 
 * from a JSON file that defines database entities. It inspects the schema to understand tables, columns, 
 * primary keys, and foreign key relationships. Based on this analysis, it produces Go code for models (structs), 
 * data access logic using GORM, GraphQL resolvers, and schema files, along with a comprehensive API manual.
 * This class streamlines the process of scaffolding a GraphQL API in Go, reducing manual effort and ensuring 
 * consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorGoCopy extends GraphQLGeneratorBase
{
    /**
     * @var array<string, string> Project configuration for go.mod and package structure.
     */
    private $projectConfig = array();

    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use caching (placeholder for Go).
     * @param array $projectConfig Project configuration details.
     * @param bool $requireLogin Whether the generated application should require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'moduleName' => 'github.com/magicapp-io/generated-app',
            'goVersion' => '1.21',
            'appName' => 'GraphQL App',
            'appDescription' => 'GraphQL API generated by MagicAppBuilder',
            'requireLogin' => $requireLogin
        ), $projectConfig);

        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int';
        }
        return 'string'; // Default fallback
    }

    /**
     * Main function to generate all files for the Go project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();

        // 1. Go Module file
        $files[] = ['name' => 'go.mod', 'content' => $this->generateGoMod()];

        // 2. Main application file
        $files[] = ['name' => 'main.go', 'content' => $this->generateMainGo()];

        // 3. Config
        $files[] = ['name' => 'config/config.go', 'content' => $this->generateConfigGo()];

        // 4. Database
        $files[] = ['name' => 'database/database.go', 'content' => $this->generateDatabaseGo()];

        // 5. GraphQL setup
        $files[] = ['name' => 'graph/schema.graphqls', 'content' => $this->generateCombinedSchema()];
        $files[] = ['name' => 'graph/generated/generated.go', 'content' => $this->generateGqlgenDummy()];
        $files[] = ['name' => 'graph/resolver.go', 'content' => $this->generateResolverGo()];
        $files[] = ['name' => 'graph/schema.resolvers.go', 'content' => $this->generateSchemaResolversGo()];
        $files[] = ['name' => 'gqlgen.yml', 'content' => $this->generateGqlgenYml()];

        // 6. Models (Entities and DTOs)
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $files[] = ['name' => 'graph/model/' . $this->camelCaseToSnakeCase($tableName) . '.go', 'content' => $this->generateModelFile($tableName, $tableInfo)];
        }
        $files[] = ['name' => 'graph/model/models_gen.go', 'content' => $this->generateModelsGenGo()];

        // 7. Security and Auth
        $files[] = ['name' => 'auth/auth.go', 'content' => $this->generateAuthGo()];
        $files[] = ['name' => 'auth/middleware.go', 'content' => $this->generateAuthMiddlewareGo()];
        $files[] = ['name' => 'graph/model/admin.go', 'content' => $this->generateAdminModelGo()];

        // 8. Utility
        $files[] = ['name' => 'util/util.go', 'content' => $this->generateUtilGo()];

        // 9. Server
        $files[] = ['name' => 'server.go', 'content' => $this->generateServerGo()];

        // 10. Manual
        $files[] = ['name' => 'manual.md', 'content' => $this->generateManual()];

        return $files;
    }

    /**
     * Generates the content for the go.mod file.
     *
     * @return string The content for go.mod.
     */
    public function generateGoMod()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $goVersion = $this->projectConfig['goVersion'];

        return <<<MOD
module $moduleName

go $goVersion

require (
	github.com/99designs/gqlgen v0.17.45
	github.com/gin-contrib/sessions v1.0.1
	github.com/gin-gonic/gin v1.9.1
	github.com/joho/godotenv v1.5.1
	github.com/vektah/gqlparser/v2 v2.5.11
	github.com/agnivade/levenshtein v1.1.1 // indirect
	github.com/bytedance/sonic v1.11.3 // indirect
	github.com/chenzhuoyu/base64x v0.0.0-20230717121745-296ad89f973d // indirect
	github.com/chenzhuoyu/iasm v0.9.1 // indirect
	github.com/gabriel-vasile/mimetype v1.4.3 // indirect
	github.com/gin-contrib/sse v0.1.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.19.0 // indirect
	github.com/go-sql-driver/mysql v1.7.0 // indirect
	github.com/goccy/go-json v0.10.2 // indirect
	github.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 // indirect
	github.com/golang-sql/sqlexp v0.1.0 // indirect
	github.com/google/go-cmp v0.6.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/context v1.1.2 // indirect
	github.com/gorilla/securecookie v1.1.2 // indirect
	github.com/gorilla/sessions v1.2.2 // indirect
	github.com/gorilla/websocket v1.5.0 // indirect
	github.com/hashicorp/golang-lru/v2 v2.0.7 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgx/v5 v5.4.3 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.7 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-sqlite3 v1.14.17 // indirect
	github.com/microsoft/go-mssqldb v1.6.0 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.0 // indirect
	github.com/rogpeppe/go-internal v1.14.1 // indirect
	github.com/sosodev/duration v1.2.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect

	golang.org/x/arch v0.7.0 // indirect
	golang.org/x/crypto v0.44.0 // indirect
	golang.org/x/net v0.47.0 // indirect
	golang.org/x/sys v0.38.0 // indirect
	golang.org/x/text v0.31.0 // indirect

	google.golang.org/protobuf v1.33.0 // indirect

	gopkg.in/yaml.v3 v3.0.1 // indirect

	gorm.io/driver/mysql v1.5.6
	gorm.io/driver/postgres v1.5.7
	gorm.io/driver/sqlite v1.5.5
	gorm.io/driver/sqlserver v1.5.3
	gorm.io/gorm v1.25.9

)
MOD;
    }

    /**
     * Generates the main.go file.
     *
     * @return string The content of main.go.
     */
    public function generateMainGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package main

import (
	"log"

	"{$moduleName}/config"
	"{$moduleName}/database"
	"github.com/joho/godotenv"
)

func main() {
	// Load .env file
	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using environment variables")
	}

	// Initialize configuration
	cfg := config.NewConfig()

	// Initialize database
	db, err := database.InitDatabase(cfg)
	if err != nil {
		log.Fatalf("failed to connect database: %v", err)
	}

	// Start the server
	startServer(cfg, db)
}
GO;
    }

    /**
     * Generates the config.go file.
     *
     * @return string The content of config.go.
     */
    public function generateConfigGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $requireLogin = $this->requireLogin ? 'true' : 'false';
        return <<<GO
package config

import (
	"os"
	"strconv"
)

// Config holds the application configuration
type Config struct {
	DBHost         string
	DBPort         string
	DBUser         string
	DBPassword     string
	DBName         string
	DBDriver       string
	ServerPort     string
	SessionSecret  string
	RequireLogin   bool
}

// NewConfig creates a new Config object from environment variables
func NewConfig() *Config {
	requireLogin, _ := strconv.ParseBool(getEnv("REQUIRE_LOGIN", "true"))

	return &Config{
		DBHost:        getEnv("DB_HOST", "localhost"),
		DBPort:        getEnv("DB_PORT", "3306"),
		DBUser:        getEnv("DB_USER", "root"),
		DBPassword:    getEnv("DB_PASS", ""),
		DBName:        getEnv("DB_NAME", "test"),
		DBDriver:      getEnv("DB_DRIVER", "mysql"),
		ServerPort:    getEnv("SERVER_PORT", "8080"),
		SessionSecret: getEnv("SESSION_SECRET", "a-very-secret-key"),
		RequireLogin:  requireLogin,
	}
}

// Helper function to get an environment variable or return a default value
func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}
GO;
    }

    /**
     * Generates the database.go file for GORM setup.
     *
     * @return string The content of database.go.
     */
    public function generateDatabaseGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package database

import (
	"fmt"
	"log"

	"{$moduleName}/config"
	"gorm.io/driver/mysql"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/driver/sqlserver"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

// InitDatabase initializes and returns a GORM database instance
func InitDatabase(cfg *config.Config) (*gorm.DB, error) {
	var dsn string
	var dialector gorm.Dialector

	switch cfg.DBDriver {
	case "mysql":
		dsn = fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local",
			cfg.DBUser, cfg.DBPassword, cfg.DBHost, cfg.DBPort, cfg.DBName)
		dialector = mysql.Open(dsn)
	case "postgres":
		dsn = fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=disable TimeZone=Asia/Shanghai",
			cfg.DBHost, cfg.DBUser, cfg.DBPassword, cfg.DBName, cfg.DBPort)
		dialector = postgres.Open(dsn)
	case "sqlite":
		dialector = sqlite.Open(cfg.DBName + ".db")
	case "sqlserver":
		dsn = fmt.Sprintf("sqlserver://%s:%s@%s:%s?database=%s",
			cfg.DBUser, cfg.DBPassword, cfg.DBHost, cfg.DBPort, cfg.DBName)
		dialector = sqlserver.Open(dsn)
	default:
		return nil, fmt.Errorf("unsupported database driver: %s", cfg.DBDriver)
	}

	db, err := gorm.Open(dialector, &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true, // use singular table name, e.g., user for users table
		},
	})

	if err != nil {
		return nil, err
	}

	log.Println("Database connection established")
	return db, nil
}
GO;
    }

    /**
     * Generates the server.go file to set up the Gin server and routes.
     *
     * @return string The content of server.go.
     */
    public function generateServerGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package main

import (
	"log"

	"{$moduleName}/auth"
	"{$moduleName}/config"
	"{$moduleName}/graph"
	"{$moduleName}/graph/generated"
	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/99designs/gqlgen/graphql/playground"
	"github.com/gin-contrib/sessions"
	"github.com/gin-contrib/sessions/cookie"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

func startServer(cfg *config.Config, db *gorm.DB) {
	r := gin.Default()

	// Session middleware
	store := cookie.NewStore([]byte(cfg.SessionSecret))
	r.Use(sessions.Sessions("mysession", store))

	// Auth routes
	authController := auth.NewAuthController(db)
	r.POST("/login", authController.Login)
	r.POST("/logout", authController.Logout)

	// GraphQL handlers
	graphqlHandler := graphqlHandler(db, cfg)
	playgroundHandler := playgroundHandler()

	// GraphQL endpoint
	gqlGroup := r.Group("/graphql")
	if cfg.RequireLogin {
		gqlGroup.Use(auth.Middleware(db))
	}
	gqlGroup.POST("", graphqlHandler)

	// Playground endpoint (always public)
	r.GET("/", playgroundHandler)

	// Serve static files for frontend
	r.Static("/assets", "./static/assets")
    r.StaticFile("/favicon.ico", "./static/favicon.ico")

	log.Printf("connect to http://localhost:%s/ for GraphQL playground", cfg.ServerPort)
	log.Fatal(r.Run(":" + cfg.ServerPort))
}

func graphqlHandler(db *gorm.DB, cfg *config.Config) gin.HandlerFunc {
	resolver := &graph.Resolver{DB: db, Cfg: cfg}
	srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: resolver}))

	return func(c *gin.Context) {
		srv.ServeHTTP(c.Writer, c.Request)
	}
}

func playgroundHandler() gin.HandlerFunc {
	h := playground.Handler("GraphQL", "/graphql")

	return func(c *gin.Context) {
		h.ServeHTTP(c.Writer, c.Request)
	}
}
GO;
    }

    private function goName($name)
    {
        $name = $this->pascalCase($name);
        if(PicoStringUtil::endsWith($name, 'Id'))
        {
            $name = substr($name, 0, strlen($name) - 2).'ID';
        }
        return $name;
    }

    /**
     * Generates a model file (struct) for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the model file.
     */
    private function generateModelFile($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $structFields = "";
        $imports = array();

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $goType = $this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->goName($colName);
            $jsonTag = $this->camelCase($colName);

            if (strpos($goType, 'time.Time') !== false) {
                $imports['time'] = true;
            }

            $gormTags = "column:" . $colName;
            if ($colInfo['isPrimaryKey']) {
                $gormTags .= ";primaryKey";
            }

            $structFields .= "    $fieldName $goType `json:\"$jsonTag\" gorm:\"$gormTags\"`\n";

            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refPascalName = $this->pascalCase($refTableName);
                $refFieldName = $refPascalName;
                $structFields .= "    $refFieldName *$refPascalName `json:\"" . $this->camelCase($refTableName) . "\" gorm:\"foreignKey:" . $fieldName . "\"`\n";
            }
        }

        $importStr = "";
        if (!empty($imports)) {
            $importStr = "import (\n";
            foreach (array_keys($imports) as $pkg) {
                $importStr .= "    \"" . $pkg . "\"\n";
            }
            $importStr .= ")\n\n";
        }

        return <<<GO
package model

$importStr
// $pascalName represents the $tableName table.
type $pascalName struct {
$structFields}
GO;
    }

    /**
     * Generates the models_gen.go file for GraphQL input structs and pagination.
     *
     * @return string The content of models_gen.go.
     */
    private function generateModelsGenGo()
    {
        $allInputStructs = "";
        $allPageStructs = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $inputName = "New" . $pascalName;
            $inputFields = "";
            $backendHandledColumnNames = $this->getBackendHandledColumnNames();

            foreach ($tableInfo['columns'] as $colName => $colInfo) {
                if ($colInfo['isPrimaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                    continue;
                }
                if (in_array($colName, $backendHandledColumnNames)) {
                    continue;
                }

                $goType = $this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']);
                // For inputs, use pointers to distinguish between zero values and omitted fields
                $goType = "*" . $goType;
                $fieldName = $this->goName($colName);
                $jsonTag = $this->camelCase($colName);
                $inputFields .= "    $fieldName $goType `json:\"$jsonTag\"`\n";
            }

            $allInputStructs .= "// $inputName is the input for creating a new $pascalName.\n";
            $allInputStructs .= "type $inputName struct {\n$inputFields}\n\n";

            $allPageStructs .= "// {$pascalName}Page represents a paginated list of {$pascalName}s.\n";
            $allPageStructs .= "type {$pascalName}Page struct {\n";
            $allPageStructs .= "    Items      []*$pascalName `json:\"items\"`\n";
            $allPageStructs .= "    Total      int          `json:\"total\"`\n";
            $allPageStructs .= "    Page       int          `json:\"page\"`\n";
            $allPageStructs .= "    Limit      int          `json:\"limit\"`\n";
            $allPageStructs .= "    TotalPages int          `json:\"totalPages\"`\n";
            $allPageStructs .= "    HasNext    bool         `json:\"hasNext\"`\n";
            $allPageStructs .= "    HasPrev    bool         `json:\"hasPrev\"`\n";
            $allPageStructs .= "}\n\n";
        }

        return <<<GO
package model

import (
	"time"
)

type FilterInput struct {
	Field    string      `json:"field"`
	Value    interface{} `json:"value"`
	Operator *string     `json:"operator"`
}

type SortInput struct {
	Field     string  `json:"field"`
	Direction *string `json:"direction"`
}

$allInputStructs
$allPageStructs
GO;
    }

    /**
     * Generates the resolver.go file.
     *
     * @return string The content of resolver.go.
     */
    public function generateResolverGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package graph

import (
    "{$moduleName}/config"
    "gorm.io/gorm"
)

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

type Resolver struct{
    DB *gorm.DB
    Cfg *config.Config
}
GO;
    }

    /**
     * Generates the schema.resolvers.go file with CRUD logic.
     *
     * @return string The content of schema.resolvers.go.
     */
    public function generateSchemaResolversGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $mutationFuncs = "";
        $queryFuncs = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $pkGoType = 'string'; // Default
            foreach ($tableInfo['columns'] as $col) {
                if ($col['isPrimaryKey']) {
                    $pkGoType = $this->mapDbTypeToGoType($col['type'], $col['length']);
                    break;
                }
            }

            // Create Mutation
            $mutationFuncs .= $this->generateCreateResolver($tableName, $tableInfo);
            // Update Mutation
            $mutationFuncs .= $this->generateUpdateResolver($tableName, $tableInfo);
            // Delete Mutation
            $mutationFuncs .= $this->generateDeleteResolver($tableName, $tableInfo);

            // Get One Query
            $queryFuncs .= <<<GO
func (r *QueryResolver) {$pascalName}(ctx context.Context, id {$pkGoType}) (*model.{$pascalName}, error) {
	var result model.{$pascalName}
	if err := r.DB.First(&result, "{$tableInfo['primaryKey']} = ?", id).Error; err != nil {
		return nil, err
	}
	return &result, nil
}

GO;
            // Get List Query
            $queryFuncs .= <<<GO
func (r *QueryResolver) {$pluralCamelName}(ctx context.Context, limit *int, offset *int, page *int, orderBy []*model.SortInput, filter []*model.FilterInput) (*model.{$pascalName}Page, error) {
	var items []*model.{$pascalName}
	var total int64

	db := r.DB.Model(&model.{$pascalName}{})

	// Apply filters
	if filter != nil {
		for _, f := range filter {
			db = util.ApplyFilter(db, *f)
		}
	}

	// Get total count
	if err := db.Count(&total).Error; err != nil {
		return nil, err
	}

	// Apply sorting
	if orderBy != nil {
		for _, s := range orderBy {
			db = util.ApplyOrderBy(db, *s)
		}
	}

	// Apply pagination
	pg := util.NewPaginator(limit, offset, page)
	db = db.Limit(pg.Limit).Offset(pg.Offset)

	if err := db.Find(&items).Error; err != nil {
		return nil, err
	}

	return &model.{$pascalName}Page{
		Items:      items,
		Total:      int(total),
		Page:       pg.Page,
		Limit:      pg.Limit,
		TotalPages: pg.TotalPages(int(total)),
		HasNext:    pg.HasNext(int(total)),
		HasPrev:    pg.HasPrev(),
	}, nil
}

GO;
        }

        return <<<GO
package graph

import (
	"context"
	"fmt"

	"{$moduleName}/graph/generated"
	"{$moduleName}/graph/model"
	"{$moduleName}/util"
)

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver { return &MutationResolver{r} }

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver { return &QueryResolver{r} }

type MutationResolver struct{ *Resolver }
type QueryResolver struct{ *Resolver }

$mutationFuncs
$queryFuncs
GO;
    }

    /**
     * Generates the create resolver function for a table.
     */
    private function generateCreateResolver($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $inputName = "New" . $pascalName;
        $pkGoType = 'string';
        $pkColName = $tableInfo['primaryKey'];
        $pkFieldName = $this->pascalCase($pkColName);
        if(PicoStringUtil::endsWith($pkFieldName, 'Id'))
        {
            // Remove suffix `Id` with `ID`
            $pkFieldName = substr($pkFieldName, 0, strlen($pkFieldName) - 2). 'ID';
        }
        $pkIsAutogenerated = false;

        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGoType = $this->mapDbTypeToGoType($col['type'], $col['length']);
                $pkIsAutogenerated = $col['isAutoIncrement'] || $col['primaryKeyValue'] == 'autogenerated';
                break;
            }
        }

        $pkValidation = "";
        if (!$pkIsAutogenerated) {
            $pkValidation = <<<GO
    if input.{$pkFieldName} == nil || *input.{$pkFieldName} == "" {
        return nil, fmt.Errorf("primary key '{$this->camelCase($pkColName)}' is required")
    }
GO;
        }

        return <<<GO
func (r *MutationResolver) Create{$pascalName}(ctx context.Context, input model.{$inputName}) (*model.{$pascalName}, error) {
$pkValidation
	newRecord := model.{$pascalName}{}

    // Map input to model
    util.MapInputToModel(input, &newRecord)

    // Set audit fields
    util.SetAuditFieldsForCreate(&newRecord, ctx)

	if err := r.DB.Create(&newRecord).Error; err != nil {
		return nil, err
	}
	return &newRecord, nil
}

GO;
    }

    /**
     * Generates the update resolver function for a table.
     */
    private function generateUpdateResolver($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $inputName = "New" . $pascalName;
        $pkGoType = 'string';
        $pkColName = $tableInfo['primaryKey'];

        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGoType = $this->mapDbTypeToGoType($col['type'], $col['length']);
                break;
            }
        }

        return <<<GO
func (r *MutationResolver) Update{$pascalName}(ctx context.Context, id {$pkGoType}, input model.{$inputName}) (*model.{$pascalName}, error) {
	var existingRecord model.{$pascalName}
	if err := r.DB.First(&existingRecord, "{$pkColName} = ?", id).Error; err != nil {
		return nil, fmt.Errorf("{$pascalName} with id %v not found", id)
	}

    // Map input to model
    util.MapInputToModel(input, &existingRecord)

    // Set audit fields
    util.SetAuditFieldsForUpdate(&existingRecord, ctx)

	if err := r.DB.Save(&existingRecord).Error; err != nil {
		return nil, err
	}
	return &existingRecord, nil
}

GO;
    }

    /**
     * Generates the delete resolver function for a table.
     */
    private function generateDeleteResolver($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $pkGoType = 'string';
        $pkColName = $tableInfo['primaryKey'];

        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGoType = $this->mapDbTypeToGoType($col['type'], $col['length']);
                break;
            }
        }

        return <<<GO
func (r *MutationResolver) Delete{$pascalName}(ctx context.Context, id {$pkGoType}) (bool, error) {
	if err := r.DB.Delete(&model.{$pascalName}{}, "{$pkColName} = ?", id).Error; err != nil {
		return false, err
	}
	return true, nil
}

GO;
    }

    /**
     * Generates the combined GraphQL schema file.
     *
     * @return string The content of schema.graphqls.
     */
    private function generateCombinedSchema()
    {
        $allTypes = "";
        $allQueries = "";
        $allMutations = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allTypes .= $schemaParts['types'] . "\n";
            $allQueries .= $schemaParts['queries'] . "\n";
            $allMutations .= $schemaParts['mutations'] . "\n";
        }

        return <<<GQL
scalar Time

enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: String
    operator: FilterOperator
}

$allTypes

type Query {
$allQueries
}

type Mutation {
$allMutations
}
GQL;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $camelName = $this->camelCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $typeFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $this->camelCase($colName);
            $typeFields .= "    $fieldName: $gqlType\n";

            if ($colInfo['isForeignKey']) {
                $refPascalName = $this->pascalCase($colInfo['references']);
                $refFieldName = $this->camelCase($colInfo['references']);
                $typeFields .= "    $refFieldName: $refPascalName\n";
            }
        }

        // Input fields
        $inputFields = "";
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            $gqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $this->camelCase($colName);
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $pkGqlType = 'String!';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToGoType($col['type'], $col['length'])) . '!';
                break;
            }
        }

        $types = <<<GQL
type $pascalName {
$typeFields}

input New$pascalName {
$inputFields}

type {$pascalName}Page {
    items: [$pascalName]
    total: Int!
    page: Int!
    limit: Int!
    totalPages: Int!
    hasNext: Boolean!
    hasPrev: Boolean!
}
GQL;
        $camelMethodName = 'get'.ucfirst($camelName);
        $pluralMethodName = 'get'.ucfirst($pluralCamelName);

        $queries = "    $camelMethodName(id: $pkGqlType): $pascalName\n";
        $queries .= "    $pluralMethodName(limit: Int, offset: Int, page: Int, orderBy: [SortInput], filter: [FilterInput]): {$pascalName}Page\n";

        $mutations = "    create{$pascalName}(input: New{$pascalName}!): $pascalName\n";
        $mutations .= "    update{$pascalName}(id: $pkGqlType, input: New{$pascalName}!): $pascalName\n";
        $mutations .= "    delete{$pascalName}(id: $pkGqlType): Boolean!\n";

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Generates the gqlgen.yml configuration file.
     *
     * @return string The content of gqlgen.yml.
     */
    public function generateGqlgenYml()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<YML
# Where are all the schema files located?
schema:
  - graph/*.graphqls

# Where should the generated server code go?
exec:
  filename: graph/generated/generated.go
  package: generated

# Uncomment to enable federation
# federation:
#   filename: graph/generated/federation.go
#   package: generated

# Where should any generated models go?
model:
  filename: graph/model/models_gen.go
  package: model

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: graph
  package: graph
  filename_template: "{name}.resolvers.go"

# Optional: turn on use `gqlgen:"fieldName"` tags in your models
# struct_tag: json

# Optional: turn on to use []Thing instead of []*Thing
# omit_slice_element_pointers: false

# Optional: set to speed up generation time by not performing a final validation pass.
# skip_validation: true

# gqlgen will search for any type names in the schema in these go packages
# if they match it will use them, otherwise it will generate them.
autobind:
  - "{$moduleName}/graph/model"

# This section declares type mapping between the GraphQL and Go type systems
#
# The first line in each type will be used as defaults for resolver arguments and
# modelgen, the others will be allowed when binding to fields. Configure
models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Int:
    model:
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Time:
    model:
      - github.com/99designs/gqlgen/graphql.Time
YML;
    }

    /**
     * Generates a dummy generated.go file.
     *
     * @return string The content of the dummy file.
     */
    public function generateGqlgenDummy()
    {
        return "// This file is intentionally left empty. It will be generated by gqlgen.\n// Run `go run github.com/99designs/gqlgen generate` to generate the contents.\npackage generated\n";
    }

    /**
     * Generates the auth.go file for login/logout logic.
     *
     * @return string The content of auth.go.
     */
    public function generateAuthGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package auth

import (
	"crypto/sha1"
	"encoding/hex"
	"net/http"

	"{$moduleName}/graph/model"
	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type AuthController struct {
	DB *gorm.DB
}

func NewAuthController(db *gorm.DB) *AuthController {
	return &AuthController{DB: db}
}

type LoginRequest struct {
	Username string `json:"username" form:"username" binding:"required"`
	Password string `json:"password" form:"password" binding:"required"`
}

func (ac *AuthController) Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBind(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var admin model.Admin
	if err := ac.DB.Where("username = ?", req.Username).First(&admin).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"success": false, "message": "Invalid credentials"})
		return
	}

	// MagicAppBuilder uses sha1(sha1(password))
	hashedPassword := doubleSha1(req.Password)

	if admin.Password != hashedPassword {
		c.JSON(http.StatusUnauthorized, gin.H{"success": false, "message": "Invalid credentials"})
		return
	}

	session := sessions.Default(c)
	session.Set("adminId", admin.AdminID)
	session.Set("username", admin.Username)
	if err := session.Save(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save session"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"success": true, "message": "Login successful"})
}

func (ac *AuthController) Logout(c *gin.Context) {
	session := sessions.Default(c)
	session.Clear()
	if err := session.Save(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save session"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "Logout successful"})
}

func doubleSha1(s string) string {
	h1 := sha1.New()
	h1.Write([]byte(s))
	firstHash := hex.EncodeToString(h1.Sum(nil))

	h2 := sha1.New()
	h2.Write([]byte(firstHash))
	return hex.EncodeToString(h2.Sum(nil))
}
GO;
    }

    /**
     * Generates the auth middleware.go file.
     *
     * @return string The content of middleware.go.
     */
    public function generateAuthMiddlewareGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package auth

import (
	"context"
	"net/http"

	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type contextKey string

const AdminIDKey contextKey = "adminId"

func Middleware(db *gorm.DB) gin.HandlerFunc {
	return func(c *gin.Context) {
		session := sessions.Default(c)
		adminId := session.Get("adminId")

		if adminId == nil {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Unauthorized"})
			c.Abort()
			return
		}

		// Add adminId to the context for use in resolvers
		ctx := context.WithValue(c.Request.Context(), AdminIDKey, adminId)
		c.Request = c.Request.WithContext(ctx)

		c.Next()
	}
}
GO;
    }

    /**
     * Generates the Admin model struct.
     *
     * @return string The content of admin.go.
     */
    public function generateAdminModelGo()
    {
        return <<<GO
package model

// Admin represents the admin table.
type Admin struct {
	AdminID      string `json:"adminId" gorm:"column:admin_id;primaryKey"`
	Username     string `json:"username" gorm:"column:username"`
	Password     string `json:"password" gorm:"column:password"`
	Name         string `json:"name" gorm:"column:name"`
	Email        string `json:"email" gorm:"column:email"`
	AdminLevelID string `json:"adminLevelId" gorm:"column:admin_level_id"`
	Active       bool   `json:"active" gorm:"column:active"`
}
GO;
    }

    /**
     * Generates the util.go file with helper functions.
     *
     * @return string The content of util.go.
     */
    public function generateUtilGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $backendHandledColumns = $this->getBackendHandledColumnNames();
        $timeCreateCol = isset($this->backendHandledColumns['timeCreate']) ? $this->pascalCase($this->backendHandledColumns['timeCreate']['columnName']) : '';
        $adminCreateCol = isset($this->backendHandledColumns['adminCreate']) ? $this->pascalCase($this->backendHandledColumns['adminCreate']['columnName']) : '';
        $timeEditCol = isset($this->backendHandledColumns['timeEdit']) ? $this->pascalCase($this->backendHandledColumns['timeEdit']['columnName']) : '';
        $adminEditCol = isset($this->backendHandledColumns['adminEdit']) ? $this->pascalCase($this->backendHandledColumns['adminEdit']['columnName']) : '';

        $setCreateFields = "";
        if ($timeCreateCol) $setCreateFields .= "    setField(model, \"{$timeCreateCol}\", time.Now())\n";
        if ($adminCreateCol) $setCreateFields .= "    setField(model, \"{$adminCreateCol}\", adminID)\n";

        $setUpdateFields = "";
        if ($timeEditCol) $setUpdateFields .= "    setField(model, \"{$timeEditCol}\", time.Now())\n";
        if ($adminEditCol) $setUpdateFields .= "    setField(model, \"{$adminEditCol}\", adminID)\n";

        return <<<GO
package util

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"time"

	"{$moduleName}/auth"
	"{$moduleName}/graph/model"
	"gorm.io/gorm"
)

// Paginator holds pagination data
type Paginator struct {
	Limit  int
	Offset int
	Page   int
}

// NewPaginator creates a Paginator from GraphQL arguments
func NewPaginator(limit, offset, page *int) *Paginator {
	p := &Paginator{Limit: 20, Page: 1} // Defaults

	if limit != nil {
		p.Limit = *limit
	}
	if page != nil && *page > 0 {
		p.Page = *page
		p.Offset = (*page - 1) * p.Limit
	} else if offset != nil {
		p.Offset = *offset
		if p.Limit > 0 {
			p.Page = (*offset / p.Limit) + 1
		}
	}
	return p
}

func (p *Paginator) TotalPages(total int) int {
	if p.Limit == 0 {
		return 0
	}
	return (total + p.Limit - 1) / p.Limit
}

func (p *Paginator) HasNext(total int) bool {
	return p.Page < p.TotalPages(total)
}

func (p *Paginator) HasPrev() bool {
	return p.Page > 1
}

// ApplyFilter applies a single filter to a GORM query
func ApplyFilter(db *gorm.DB, filter model.FilterInput) *gorm.DB {
	op := " = ?" // Default operator
	var val interface{} = filter.Value

	if filter.Operator != nil {
		switch strings.ToUpper(string(*filter.Operator)) {
		case "NOT_EQUALS":
			op = " <> ?"
		case "CONTAINS":
			op = " LIKE ?"
			val = fmt.Sprintf("%%%s%%", filter.Value)
		case "GREATER_THAN":
			op = " > ?"
		case "GREATER_THAN_OR_EQUALS":
			op = " >= ?"
		case "LESS_THAN":
			op = " < ?"
		case "LESS_THAN_OR_EQUALS":
			op = " <= ?"
		case "IN":
			op = " IN (?)"
			val = strings.Split(fmt.Sprintf("%v", filter.Value), ",")
		case "NOT_IN":
			op = " NOT IN (?)"
			val = strings.Split(fmt.Sprintf("%v", filter.Value), ",")
		}
	}
	return db.Where(ToSnakeCase(filter.Field)+op, val)
}

// ApplyOrderBy applies sorting to a GORM query
func ApplyOrderBy(db *gorm.DB, sort model.SortInput) *gorm.DB {
	direction := "ASC"
	if sort.Direction != nil && strings.ToUpper(string(*sort.Direction)) == "DESC" {
		direction = "DESC"
	}
	return db.Order(fmt.Sprintf("%s %s", ToSnakeCase(sort.Field), direction))
}

// ToSnakeCase converts a string from camelCase to snake_case.
func ToSnakeCase(str string) string {
	var result []rune
	for i, r := range str {
		if r >= 'A' && r <= 'Z' {
			if i > 0 {
				result = append(result, '_')
			}
			result = append(result, r+('a'-'A'))
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}

// MapInputToModel maps fields from an input struct to a model struct.
func MapInputToModel(input interface{}, model interface{}) {
	inputValue := reflect.ValueOf(input)
	modelValue := reflect.ValueOf(model).Elem()

	for i := 0; i < inputValue.NumField(); i++ {
		inputField := inputValue.Field(i)
		if inputField.IsNil() {
			continue
		}

		fieldName := inputValue.Type().Field(i).Name
		modelField := modelValue.FieldByName(fieldName)

		if modelField.IsValid() && modelField.CanSet() {
			modelField.Set(inputField.Elem())
		}
	}
}

// SetAuditFieldsForCreate sets creation audit fields on a model.
func SetAuditFieldsForCreate(model interface{}, ctx context.Context) {
	adminID := ctx.Value(auth.AdminIDKey)
$setCreateFields
}

// SetAuditFieldsForUpdate sets update audit fields on a model.
func SetAuditFieldsForUpdate(model interface{}, ctx context.Context) {
	adminID := ctx.Value(auth.AdminIDKey)
$setUpdateFields
}

func setField(obj interface{}, fieldName string, value interface{}) {
    v := reflect.ValueOf(obj).Elem()
    field := v.FieldByName(fieldName)
    if field.IsValid() && field.CanSet() {
        field.Set(reflect.ValueOf(value))
    }
}
GO;
    }

    /**
     * Maps a Java type to a GraphQL type for schema generation.
     *
     * @param string $goType The Go type.
     * @return string The corresponding GraphQL type.
     */
    private function mapJavaTypeToGqlType($goType)
    {
        switch ($goType) {
            case 'int':
            case 'int32':
            case 'int64':
                return 'Int';
            case 'float32':
            case 'float64':
                return 'Float';
            case 'bool':
                return 'Boolean';
            case 'time.Time':
                return 'Time';
            case 'string':
            default:
                return 'String';
        }
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        // This is a simplified version. A full implementation would be similar to the Java one.
        $manualContent = "# GraphQL API Manual (Go)\r\n\r\n";
        $manualContent .= "This document provides examples for your Go GraphQL API.\r\n\r\n";
        $manualContent .= "## How to Run\r\n\r\n";
        $manualContent .= "1.  Ensure you have Go " . $this->projectConfig['goVersion'] . " or later installed.\n";
        $manualContent .= "2.  Create a `.env` file in the root directory and configure your database connection:\n\n";
        $manualContent .= "    ```\n";
        $manualContent .= "    DB_HOST=localhost\n";
        $manualContent .= "    DB_PORT=3306\n";
        $manualContent .= "    DB_USER=your_user\n";
        $manualContent .= "    DB_PASS=your_password\n";
        $manualContent .= "    DB_NAME=your_database\n";
        $manualContent .= "    DB_DRIVER=mysql\n";
        $manualContent .= "    SERVER_PORT=8080\n";
        $manualContent .= "    SESSION_SECRET=change-this-to-a-random-string\n";
        $manualContent .= "    REQUIRE_LOGIN=" . ($this->requireLogin ? 'true' : 'false') . "\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "3.  Install dependencies:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go mod tidy\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "4.  Generate GraphQL code:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go run github.com/99designs/gqlgen generate\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "5.  Run the application:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go run main.go\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "The GraphQL playground will be available at `http://localhost:8080/`.\n";

        // Add query/mutation examples similar to the Java generator
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pascalName = $this->pascalCase($tableName);

            $manualContent .= "\r\n## " . $pascalName . "\r\n\r\n";
            $manualContent .= "### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $pascalName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-id\") {\r\n";
            $manualContent .= "    # ... fields\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        return $manualContent;
    }
}