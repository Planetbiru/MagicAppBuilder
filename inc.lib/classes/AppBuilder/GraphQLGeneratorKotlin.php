<?php

namespace AppBuilder;

/**
 * The `GraphQLGeneratorKotlin` class is a powerful tool designed to automatically generate a complete Spring Boot GraphQL API in Kotlin from a JSON file that defines database entities.
 * It inspects the schema to understand tables, columns, primary keys, and foreign key relationships.
 * Based on this analysis, it produces Kotlin code for entities, repositories, DTOs, and GraphQL controllers, along with GraphQL schema files, and a comprehensive API manual in Markdown format.
 * This class streamlines the process of scaffolding a GraphQL API, reducing manual effort and ensuring consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorKotlin extends GraphQLGeneratorBase
{
    
    /**
     * @var array<string, string> Project configuration for pom.xml and package structure.
     */
    private $projectConfig = array();
    
    /**
     * @var bool Whether to enable verbose logging in the generated application.
     */
    private $verboseLogging = false;
    
    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use in-memory caching for queries.
     * @param array $projectConfig Project configuration details.
     * @param bool $verboseLogging Whether to enable verbose logging.
     * @param bool $requireLogin Whether the generated application should require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $verboseLogging = false, $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'groupId' => 'io.magicapp.generated',
            'artifactId' => 'graphql-app',
            'version' => '0.0.1-SNAPSHOT',
            'name' => 'GraphQL App',
            'description' => 'GraphQL API generated by MagicAppBuilder',
            'kotlinVersion' => '1.9.23', // Kotlin version
            'javaVersion' => '21',
            'packageName' => 'io.magicapp.generated.graphqlapp',
            'verboseLogging' => $verboseLogging,
            'requireLogin' => $requireLogin
        ), $projectConfig);
        
        $this->verboseLogging = $verboseLogging;
        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Kotlin type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Kotlin type string.
     */
    private function mapDbTypeToKotlinType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'String';
        }
        if (strpos($dbType, 'timestamp') !== false) {
            return 'java.time.LocalDateTime';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'java.time.LocalDate';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'Double';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'Boolean';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'Int'; // Use Kotlin's Int
        }
        return 'String'; // Default fallback
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations for your Spring Boot application.\r\n\r\n";
        
        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in the `build.gradle.kts` file. Gradle will handle downloading them automatically.\r\n\r\n";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must configure the `src/main/resources/application.properties` file. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```properties\r\n";
        $manualContent .= "spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name\r\n";
        $manualContent .= "spring.datasource.username=your_username\r_n";
        $manualContent .= "spring.datasource.password=your_password\r\n";
        $manualContent .= "```\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        $manualContent .= $this->generateExample();

        return $manualContent;
    }
    
    
    /**
     * Main function to generate all files for the Spring Boot project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();
        $packagePath = 'src/main/kotlin/' . str_replace('.', '/', $this->projectConfig['packageName']);

        $files[] = ['name' => 'pom.xml', 'content' => $this->generatePom()];
        $files[] = ['name' => 'mvnw.cmd', 'content' => $this->generateMvnwCmd()];
        $files[] = ['name' => 'mvnw', 'content' => $this->generateMvnw()];
        $files[] = ['name' => '.mvn/wrapper\maven-wrapper.properties', 'content' => 'wrapperVersion=3.3.4
distributionType=only-script
distributionUrl=https://repo.maven.apache.org/maven2/org/apache/maven/apache-maven/3.9.11/apache-maven-3.9.11-bin.zip
'];

        // 2. Main Application Class
        $files[] = ['name' => $packagePath . '/' . $this->pascalCase($this->projectConfig['artifactId']) . 'Application.kt', 'content' => $this->generateMainAppClass()];

        // 3. GraphQL Schema, Entities, Repositories, DTOs, Controllers
        $allSchemaParts = array();
        $allQueryFields = array();
        $allMutationFields = array();

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $files[] = ['name' => $packagePath . '/model/entity/' . $pascalName . '.kt', 'content' => $this->generateEntityClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/repository/' . $pascalName . 'Repository.kt', 'content' => $this->generateRepositoryInterface($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/dto/' . $pascalName . 'Input.kt', 'content' => $this->generateDtoClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/controller/' . $pascalName . 'Controller.kt', 'content' => $this->generateControllerClass($tableName, $tableInfo)];

            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];
        }

        // 4. Combined GraphQL Schema
        $files[] = ['name' => 'src/main/resources/graphql/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        $staticFiles = $this->generateStaticFiles($files, $packagePath);
        return array_merge($files, $staticFiles);

    }

    private function generateStaticFiles($files, $packagePath)
    {
        $baseDir = dirname(dirname(dirname(__DIR__))) . '/inc.graphql-resources/backend/kotlin/';

        // 5. Utility and DTO classes (converted to Kotlin)
        $files[] = ['name' => $packagePath . '/model/dto/core/FilterInput.kt', 
                    'content' => $this->getKotlinFileTemplate('model/dto/core/FilterInput.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/dto/core/SortInput.kt', 
                    'content' => $this->getKotlinFileTemplate('model/dto/core/SortInput.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/SpecificationBuilder.kt', 
                    'content' => $this->getKotlinFileTemplate('util/SpecificationBuilder.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/FilterCriteria.kt', 
                    'content' => $this->getKotlinFileTemplate('util/FilterCriteria.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/SearchOperation.kt', 
                    'content' => $this->getKotlinFileTemplate('util/SearchOperation.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/GenericSpecification.kt', 
                    'content' => $this->getKotlinFileTemplate('util/GenericSpecification.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/QueryUtil.kt', 
                    'content' => $this->getKotlinFileTemplate('util/QueryUtil.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/AuditTrailUtil.kt', 
                    'content' => $this->getKotlinFileTemplate('util/AuditTrailUtil.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/ValueUtil.kt', 
                    'content' => $this->getKotlinFileTemplate('util/ValueUtil.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/ScalarValueUtil.kt', 
                    'content' => $this->getKotlinFileTemplate('util/ScalarValueUtil.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/util/I18nUtil.kt', 
                    'content' => $this->getKotlinFileTemplate('util/I18nUtil.kt', $this->projectConfig, $baseDir)];


        // 6. Security and Auth files
        $files[] = ['name' => $packagePath . '/config/SecurityConfig.kt', 
                    'content' => $this->getKotlinFileTemplate('config/SecurityConfig.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/config/CorsConfig.kt', 
                    'content' => $this->getKotlinFileTemplate('config/CorsConfig.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/config/Sha1PasswordEncoder.kt', 
                    'content' => $this->getKotlinFileTemplate('config/Sha1PasswordEncoder.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/config/ObjectScalar.kt', 
                    'content' => $this->getKotlinFileTemplate('config/ObjectScalar.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/config/GraphQlConfig.kt', 
                    'content' => $this->getKotlinFileTemplate('config/GraphQlConfig.kt', $this->projectConfig, $baseDir)];


        // Entities
        $files[] = ['name' => $packagePath . '/model/entity/core/Admin.kt',
                    'content' => $this->getKotlinFileTemplate('model/entity/core/Admin.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/entity/core/AdminLevel.kt',
                    'content' => $this->getKotlinFileTemplate('model/entity/core/AdminLevel.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/entity/core/Message.kt',
                    'content' => $this->getKotlinFileTemplate('model/entity/core/Message.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/entity/core/MessageFolder.kt',
                    'content' => $this->getKotlinFileTemplate('model/entity/core/MessageFolder.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/entity/core/Notification.kt',
                    'content' => $this->getKotlinFileTemplate('model/entity/core/Notification.kt', $this->projectConfig, $baseDir)];


        // Repositories
        $files[] = ['name' => $packagePath . '/model/repository/core/AdminLevelRepository.kt', 
                    'content' => $this->getKotlinFileTemplate('model/repository/core/AdminLevelRepository.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/repository/core/AdminRepository.kt', 
                    'content' => $this->getKotlinFileTemplate('model/repository/core/AdminRepository.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/repository/core/MessageFolderRepository.kt', 
                    'content' => $this->getKotlinFileTemplate('model/repository/core/MessageFolderRepository.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/repository/core/MessageRepository.kt', 
                    'content' => $this->getKotlinFileTemplate('model/repository/core/MessageRepository.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/model/repository/core/NotificationRepository.kt', 
                    'content' => $this->getKotlinFileTemplate('model/repository/core/NotificationRepository.kt', $this->projectConfig, $baseDir)];


        // Services & DTOs
        $files[] = ['name' => $packagePath . '/service/JpaUserDetailsService.kt', 
                    'content' => $this->getKotlinFileTemplate('service/JpaUserDetailsService.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/dto/LoginRequest.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/dto/LoginRequest.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/dto/LoginResponse.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/dto/LoginResponse.kt', $this->projectConfig, $baseDir)];


        // Controllers
        $files[] = ['name' => $packagePath . '/controller/core/AdminController.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/core/AdminController.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/core/AuthController.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/core/AuthController.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/core/FrontendConfigController.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/core/FrontendConfigController.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/core/MessageController.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/core/MessageController.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/core/NotificationController.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/core/NotificationController.kt', $this->projectConfig, $baseDir)];

        $files[] = ['name' => $packagePath . '/controller/core/UserProfileController.kt', 
                    'content' => $this->getKotlinFileTemplate('controller/core/UserProfileController.kt', $this->projectConfig, $baseDir)];

        return $files;
    }

    /**
     * Loads a Kotlin template file, applies package prefix detection,
     * replaces placeholders using projectConfig, and returns the processed content.
     *
     * @param string $path           Path relative to "templates/kotlin/" (e.g. "util/QueryUtil.kt")
     * @param array  $projectConfig  Configuration array for placeholder replacement
     *
     * @return string Processed Kotlin content
     * @throws Exception If template file is not found
     */
    public function getKotlinFileTemplate($path, $projectConfig, $baseDir)
    {
        
        $templateFile = $baseDir . $path;

        if (!file_exists($templateFile)) {
            throw new \Exception("Template not found: " . $templateFile);
        }

        // Load file
        $content = file_get_contents($templateFile);

        $content = str_replace('com.planetbiru.graphqlapplication', $projectConfig['packageName'], $content);

        return $content;
    }

    /**
     * Generates the content of the Maven Wrapper script (`mvnw`) for Unix-based systems.
     *
     * This method returns the full shell script required to bootstrap the Maven Wrapper.
     * The generated script includes:
     * - License information and header comments
     * - Environment variable handling (JAVA_HOME, MVNW_REPOURL, MVNW_VERBOSE, etc.)
     * - Automatic download of the correct Maven distribution if it is not already installed
     * - Support for checksum validation
     * - Extraction and setup of the Maven distribution
     * - Execution of the Maven command with passed arguments
     *
     * @return string The complete Maven Wrapper shell script.
     */
    private function generateMvnw()
    {
        return <<<CMD
#!/bin/sh
# ----------------------------------------------------------------------------
# Licensed to the Apache Software Foundation (ASF) under one
# or more contributor license agreements.  See the NOTICE file
# distributed with this work for additional information
# regarding copyright ownership.  The ASF licenses this file
# to you under the Apache License, Version 2.0 (the
# "License"); you may not use this file except in compliance
# with the License.  You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing,
# software distributed under the License is distributed on an
# "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
# KIND, either express or implied.  See the License for the
# specific language governing permissions and limitations
# under the License.
# ----------------------------------------------------------------------------

# ----------------------------------------------------------------------------
# Apache Maven Wrapper startup batch script, version 3.3.4
#
# Optional ENV vars
# -----------------
#   JAVA_HOME - location of a JDK home dir, required when download maven via java source
#   MVNW_REPOURL - repo url base for downloading maven distribution
#   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
#   MVNW_VERBOSE - true: enable verbose log; debug: trace the mvnw script; others: silence the output
# ----------------------------------------------------------------------------

set -euf
[ "\${MVNW_VERBOSE-}" != debug ] || set -x

# OS specific support.
native_path() { printf %s\\n "\$1"; }
case "\$(uname)" in
CYGWIN* | MINGW*)
  [ -z "\${JAVA_HOME-}" ] || JAVA_HOME="\$(cygpath --unix "\$JAVA_HOME")"
  native_path() { cygpath --path --windows "\$1"; }
  ;;
esac

# set JAVACMD and JAVACCMD
set_java_home() {
  # For Cygwin and MinGW, ensure paths are in Unix format before anything is touched
  if [ -n "\${JAVA_HOME-}" ]; then
    if [ -x "\$JAVA_HOME/jre/sh/java" ]; then
      # IBM's JDK on AIX uses strange locations for the executables
      JAVACMD="\$JAVA_HOME/jre/sh/java"
      JAVACCMD="\$JAVA_HOME/jre/sh/javac"
    else
      JAVACMD="\$JAVA_HOME/bin/java"
      JAVACCMD="\$JAVA_HOME/bin/javac"

      if [ ! -x "\$JAVACMD" ] || [ ! -x "\$JAVACCMD" ]; then
        echo "The JAVA_HOME environment variable is not defined correctly, so mvnw cannot run." >&2
        echo "JAVA_HOME is set to \"\$JAVA_HOME\", but \"\\\$JAVA_HOME/bin/java\" or \"\\\$JAVA_HOME/bin/javac\" does not exist." >&2
        return 1
      fi
    fi
  else
    JAVACMD="\$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v java
    )" || :
    JAVACCMD="\$(
      'set' +e
      'unset' -f command 2>/dev/null
      'command' -v javac
    )" || :

    if [ ! -x "\${JAVACMD-}" ] || [ ! -x "\${JAVACCMD-}" ]; then
      echo "The java/javac command does not exist in PATH nor is JAVA_HOME set, so mvnw cannot run." >&2
      return 1
    fi
  fi
}

# hash string like Java String::hashCode
hash_string() {
  str="\${1:-}" h=0
  while [ -n "\$str" ]; do
    char="\${str%"\${str#?}"}"
    h=\$(((h * 31 + \$(LC_CTYPE=C printf %d "'\$char")) % 4294967296))
    str="\${str#?}"
  done
  printf %x\\n \$h
}

verbose() { :; }
[ "\${MVNW_VERBOSE-}" != true ] || verbose() { printf %s\\n "\${1-}"; }

die() {
  printf %s\\n "\$1" >&2
  exit 1
}

trim() {
  # MWRAPPER-139:
  #   Trims trailing and leading whitespace, carriage returns, tabs, and linefeeds.
  #   Needed for removing poorly interpreted newline sequences when running in more
  #   exotic environments such as mingw bash on Windows.
  printf "%s" "\${1}" | tr -d '[:space:]'
}

scriptDir="\$(dirname "\$0")"
scriptName="\$(basename "\$0")"

# parse distributionUrl and optional distributionSha256Sum, requires .mvn/wrapper/maven-wrapper.properties
while IFS="=" read -r key value; do
  case "\${key-}" in
  distributionUrl) distributionUrl=\$(trim "\${value-}") ;;
  distributionSha256Sum) distributionSha256Sum=\$(trim "\${value-}") ;;
  esac
done <"\$scriptDir/.mvn/wrapper/maven-wrapper.properties"
[ -n "\${distributionUrl-}" ] || die "cannot read distributionUrl property in \$scriptDir/.mvn/wrapper/maven-wrapper.properties"

case "\${distributionUrl##*/}" in
maven-mvnd-*bin.*)
  MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/
  case "\${PROCESSOR_ARCHITECTURE-}\${PROCESSOR_ARCHITEW6432-}:\$(uname -a)" in
  *AMD64:CYGWIN* | *AMD64:MINGW*) distributionPlatform=windows-amd64 ;;
  :Darwin*x86_64) distributionPlatform=darwin-amd64 ;;
  :Darwin*arm64) distributionPlatform=darwin-aarch64 ;;
  :Linux*x86_64*) distributionPlatform=linux-amd64 ;;
  *)
    echo "Cannot detect native platform for mvnd on \$(uname)-\$(uname -m), use pure java version" >&2
    distributionPlatform=linux-amd64
    ;;
  esac
  distributionUrl="\${distributionUrl%-bin.*}-\$distributionPlatform.zip"
  ;;
maven-mvnd-*) MVN_CMD=mvnd.sh _MVNW_REPO_PATTERN=/maven/mvnd/ ;;
*) MVN_CMD="mvn\${scriptName#mvnw}" _MVNW_REPO_PATTERN=/org/apache/maven/ ;;
esac

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
[ -z "\${MVNW_REPOURL-}" ] || distributionUrl="\$MVNW_REPOURL\$_MVNW_REPO_PATTERN\${distributionUrl#*"\$_MVNW_REPO_PATTERN"}"
distributionUrlName="\${distributionUrl##*/}"
distributionUrlNameMain="\${distributionUrlName%.*}"
distributionUrlNameMain="\${distributionUrlNameMain%-bin}"
MAVEN_USER_HOME="\${MAVEN_USER_HOME:-\${HOME}/.m2}"
MAVEN_HOME="\${MAVEN_USER_HOME}/wrapper/dists/\${distributionUrlNameMain-}/\$(hash_string "\$distributionUrl")"

exec_maven() {
  unset MVNW_VERBOSE MVNW_USERNAME MVNW_PASSWORD MVNW_REPOURL || :
  exec "\$MAVEN_HOME/bin/\$MVN_CMD" "\$@" || die "cannot exec \$MAVEN_HOME/bin/\$MVN_CMD"
}

if [ -d "\$MAVEN_HOME" ]; then
  verbose "found existing MAVEN_HOME at \$MAVEN_HOME"
  exec_maven "\$@"
fi

case "\${distributionUrl-}" in
*?-bin.zip | *?maven-mvnd-?*-?*.zip) ;;
*) die "distributionUrl is not valid, must match *-bin.zip or maven-mvnd-*.zip, but found '\${distributionUrl-}'" ;;
esac

# prepare tmp dir
if TMP_DOWNLOAD_DIR="\$(mktemp -d)" && [ -d "\$TMP_DOWNLOAD_DIR" ]; then
  clean() { rm -rf -- "\$TMP_DOWNLOAD_DIR"; }
  trap clean HUP INT TERM EXIT
else
  die "cannot create temp dir"
fi

mkdir -p -- "\${MAVEN_HOME%/*}"

# Download and Install Apache Maven
verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
verbose "Downloading from: \$distributionUrl"
verbose "Downloading to: \$TMP_DOWNLOAD_DIR/\$distributionUrlName"

# select .zip or .tar.gz
if ! command -v unzip >/dev/null; then
  distributionUrl="\${distributionUrl%.zip}.tar.gz"
  distributionUrlName="\${distributionUrl##*/}"
fi

# verbose opt
__MVNW_QUIET_WGET=--quiet __MVNW_QUIET_CURL=--silent __MVNW_QUIET_UNZIP=-q __MVNW_QUIET_TAR=''
[ "\${MVNW_VERBOSE-}" != true ] || __MVNW_QUIET_WGET='' __MVNW_QUIET_CURL='' __MVNW_QUIET_UNZIP='' __MVNW_QUIET_TAR=v

# normalize http auth
case "\${MVNW_PASSWORD:+has-password}" in
'') MVNW_USERNAME='' MVNW_PASSWORD='' ;;
has-password) [ -n "\${MVNW_USERNAME-}" ] || MVNW_USERNAME='' MVNW_PASSWORD='' ;;
esac

if [ -z "\${MVNW_USERNAME-}" ] && command -v wget >/dev/null; then
  verbose "Found wget ... using wget"
  wget \${__MVNW_QUIET_WGET:+"\$__MVNW_QUIET_WGET"} "\$distributionUrl" -O "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" || die "wget: Failed to fetch \$distributionUrl"
elif [ -z "\${MVNW_USERNAME-}" ] && command -v curl >/dev/null; then
  verbose "Found curl ... using curl"
  curl \${__MVNW_QUIET_CURL:+"\$__MVNW_QUIET_CURL"} -f -L -o "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" "\$distributionUrl" || die "curl: Failed to fetch \$distributionUrl"
elif set_java_home; then
  verbose "Falling back to use Java to download"
  javaSource="\$TMP_DOWNLOAD_DIR/Downloader.java"
  targetZip="\$TMP_DOWNLOAD_DIR/\$distributionUrlName"
  cat >"\$javaSource" <<-END
	public class Downloader extends java.net.Authenticator
	{
	  protected java.net.PasswordAuthentication getPasswordAuthentication()
	  {
	    return new java.net.PasswordAuthentication( System.getenv( "MVNW_USERNAME" ), System.getenv( "MVNW_PASSWORD" ).toCharArray() );
	  }
	  public static void main( String[] args ) throws Exception
	  {
	    setDefault( new Downloader() );
	    java.nio.file.Files.copy( java.net.URI.create( args[0] ).toURL().openStream(), java.nio.file.Paths.get( args[1] ).toAbsolutePath().normalize() );
	  }
	}
	END
  # For Cygwin/MinGW, switch paths to Windows format before running javac and java
  verbose " - Compiling Downloader.java ..."
  "\$(native_path "\$JAVACCMD")" "\$(native_path "\$javaSource")" || die "Failed to compile Downloader.java"
  verbose " - Running Downloader.java ..."
  "\$(native_path "\$JAVACMD")" -cp "\$(native_path "\$TMP_DOWNLOAD_DIR")" Downloader "\$distributionUrl" "\$(native_path "\$targetZip")"
fi

# If specified, validate the SHA-256 sum of the Maven distribution zip file
if [ -n "\${distributionSha256Sum-}" ]; then
  distributionSha256Result=false
  if [ "\$MVN_CMD" = mvnd.sh ]; then
    echo "Checksum validation is not supported for maven-mvnd." >&2
    echo "Please disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  elif command -v sha256sum >/dev/null; then
    if echo "\$distributionSha256Sum  \$TMP_DOWNLOAD_DIR/\$distributionUrlName" | sha256sum -c - >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  elif command -v shasum >/dev/null; then
    if echo "\$distributionSha256Sum  \$TMP_DOWNLOAD_DIR/\$distributionUrlName" | shasum -a 256 -c >/dev/null 2>&1; then
      distributionSha256Result=true
    fi
  else
    echo "Checksum validation was requested but neither 'sha256sum' or 'shasum' are available." >&2
    echo "Please install either command, or disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties." >&2
    exit 1
  fi
  if [ \$distributionSha256Result = false ]; then
    echo "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised." >&2
    echo "If you updated your Maven version, you need to update the specified distributionSha256Sum property." >&2
    exit 1
  fi
fi

# unzip and move
if command -v unzip >/dev/null; then
  unzip \${__MVNW_QUIET_UNZIP:+"\$__MVNW_QUIET_UNZIP"} "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -d "\$TMP_DOWNLOAD_DIR" || die "failed to unzip"
else
  tar xzf\${__MVNW_QUIET_TAR:+"\$__MVNW_QUIET_TAR"} "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -C "\$TMP_DOWNLOAD_DIR" || die "failed to untar"
fi

# Find the actual extracted directory name (handles snapshots where filename != directory name)
actualDistributionDir=""

# First try the expected directory name (for regular distributions)
if [ -d "\$TMP_DOWNLOAD_DIR/\$distributionUrlNameMain" ]; then
  if [ -f "\$TMP_DOWNLOAD_DIR/\$distributionUrlNameMain/bin/\$MVN_CMD" ]; then
    actualDistributionDir="\$distributionUrlNameMain"
  fi
fi

# If not found, search for any directory with the Maven executable (for snapshots)
if [ -z "\$actualDistributionDir" ]; then
  # enable globbing to iterate over items
  set +f
  for dir in "\$TMP_DOWNLOAD_DIR"/*; do
    if [ -d "\$dir" ]; then
      if [ -f "\$dir/bin/\$MVN_CMD" ]; then
        actualDistributionDir="\$(basename "\$dir")"
        break
      fi
    fi
  done
  set -f
fi

if [ -z "\$actualDistributionDir" ]; then
  verbose "Contents of \$TMP_DOWNLOAD_DIR:"
  verbose "\$(ls -la "\$TMP_DOWNLOAD_DIR")"
  die "Could not find Maven distribution directory in extracted archive"
fi

verbose "Found extracted Maven distribution directory: \$actualDistributionDir"
printf %s\\n "\$distributionUrl" >"\$TMP_DOWNLOAD_DIR/\$actualDistributionDir/mvnw.url"
mv -- "\$TMP_DOWNLOAD_DIR/\$actualDistributionDir" "\$MAVEN_HOME" || [ -d "\$MAVEN_HOME" ] || die "fail to move MAVEN_HOME"

clean || :
exec_maven "\$@"
CMD;
    }

    /**
     * Generates the contents of the Maven `pom.xml` file for the generated project.
     *
     * This method builds and returns a complete POM definition configured for:
     * - Spring Boot 3.2.x using the official starter parent
     * - Kotlin (including stdlib, reflect, and compiler plugins)
     * - GraphQL, JPA, Validation, Web, Security, Redis, and Session modules
     * - Multiple database drivers (MySQL, MariaDB, PostgreSQL, SQL Server, SQLite)
     * - Spring Boot testing dependencies for JUnit, WebFlux, GraphQL, and Security
     *
     * The generated POM also:
     * - Sets Java version to 21
     * - Sets Kotlin version to 1.9.23
     * - Defines `src/main/kotlin` and `src/test/kotlin` as the source directories
     * - Configures the Kotlin Maven plugin with:
     *      - strict nullability (`-Xjsr305=strict`)
     *      - all-open plugin (Spring annotations made open)
     *      - no-arg plugin (JPA entities)
     *
     * The returned XML string is intended to be written directly as
     * `pom.xml` in the root of the generated project directory.
     *
     * @return string
     *         The full Maven POM XML content.
     */
    private function generatePom()
    {
        $package = $this->projectConfig['packageName'];
        return <<<POM
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.5</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <groupId>com.planetbiru.graphqlapplication</groupId>
    <artifactId>graphql-application</artifactId>
    <version>0.0.1-SNAPSHOT</version>
    <name>GraphQL Application</name>
    <description>GraphQL Application</description>
    <properties>
        <java.version>21</java.version>
        <kotlin.version>1.9.23</kotlin.version>
    </properties>
    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-graphql</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.module</groupId>
            <artifactId>jackson-module-kotlin</artifactId>
        </dependency>
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-reflect</artifactId>
        </dependency>
        <dependency>
            <groupId>org.jetbrains.kotlin</groupId>
            <artifactId>kotlin-stdlib</artifactId>
        </dependency>

        <dependency>
            <groupId>com.mysql</groupId>
            <artifactId>mysql-connector-j</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.mariadb.jdbc</groupId>
            <artifactId>mariadb-java-client</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.postgresql</groupId>
            <artifactId>postgresql</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>com.microsoft.sqlserver</groupId>
            <artifactId>mssql-jdbc</artifactId>
            <scope>runtime</scope>
        </dependency>
        <dependency>
            <groupId>org.xerial</groupId>
            <artifactId>sqlite-jdbc</artifactId>
            <scope>runtime</scope>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework</groupId>
            <artifactId>spring-webflux</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.graphql</groupId>
            <artifactId>spring-graphql-test</artifactId>
            <scope>test</scope>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <sourceDirectory>\${project.basedir}/src/main/kotlin</sourceDirectory>
        <testSourceDirectory>\${project.basedir}/src/test/kotlin</testSourceDirectory>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
            </plugin>
            <plugin>
                <groupId>org.jetbrains.kotlin</groupId>
                <artifactId>kotlin-maven-plugin</artifactId>
                <version>\${kotlin.version}</version>
                <executions>
                    <execution>
                        <id>compile</id>
                        <phase>compile</phase>
                        <goals>
                            <goal>compile</goal>
                        </goals>
                    </execution>
                    <execution>
                        <id>test-compile</id>
                        <phase>test-compile</phase>
                        <goals> <goal>test-compile</goal> </goals>
                    </execution>
                </executions>
                <configuration>
                    <args>
                        <arg>-Xjsr305=strict</arg>
                    </args>
                    <compilerPlugins>
                        <plugin>all-open</plugin>
                        <plugin>no-arg</plugin>
                    </compilerPlugins>
                    <pluginOptions>
                        <option>all-open:annotation=org.springframework.stereotype.Component</option>
                        <option>all-open:annotation=org.springframework.transaction.annotation.Transactional</option>
                        <option>all-open:annotation=org.springframework.scheduling.annotation.Async</option>
                        <option>all-open:annotation=org.springframework.cache.annotation.Cacheable</option>
                        <option>all-open:annotation=org.springframework.boot.test.context.SpringBootTest</option>
                        <option>all-open:annotation=org.springframework.validation.annotation.Validated</option>
                        <option>no-arg:annotation=jakarta.persistence.Entity</option>
                    </pluginOptions>
                </configuration>
                <dependencies>
                    <dependency>
                        <groupId>org.jetbrains.kotlin</groupId>
                        <artifactId>kotlin-maven-allopen</artifactId>
                        <version>\${kotlin.version}</version>
                    </dependency>
                    <dependency>
                        <groupId>org.jetbrains.kotlin</groupId>
                        <artifactId>kotlin-maven-noarg</artifactId>
                        <version>\${kotlin.version}</version>
                    </dependency>
                </dependencies>
            </plugin>
        </plugins>
    </build>

</project>
POM;
    }

    /**
     * Generates the full contents of the Windows Maven Wrapper script (`mvnw.cmd`).
     *
     * This method returns a large heredoc string representing the official
     * Apache Maven Wrapper batch script, including both the Batch and PowerShell
     * portions required for bootstrapping Maven on Windows systems.
     *
     * The generated script:
     * - Reads Maven Wrapper configuration from `.mvn/wrapper/maven-wrapper.properties`
     * - Supports MVND (Maven Daemon) when applicable
     * - Downloads the required Maven distribution automatically if not available
     * - Validates SHA-256 checksums when configured
     * - Extracts and installs the Maven distribution into the userâ€™s `~/.m2` directory
     * - Outputs the correct command path (`MVN_CMD`) for execution
     *
     * The script is returned verbatim and is intended to be written directly to
     * a file named `mvnw.cmd` in a generated project structure.
     *
     * @return string
     *         The full contents of the Windows Maven Wrapper script.
     */
    private function generateMvnwCmd()
    {
        return <<<CMD
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.4
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {\$scriptDir='%~dp0'; \$script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" ("%__MVNW_CMD__%" %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

\$ErrorActionPreference = "Stop"
if (\$env:MVNW_VERBOSE -eq "true") {
  \$VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
\$distributionUrl = (Get-Content -Raw "\$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!\$distributionUrl) {
  Write-Error "cannot read distributionUrl property in \$scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( \$(\$distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    \$USE_MVND = \$true
    \$distributionUrl = \$distributionUrl -replace '-bin\.[^.]*\$',"-windows-amd64.zip"
    \$MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    \$USE_MVND = \$false
    \$MVN_CMD = \$script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if (\$env:MVNW_REPOURL) {
  \$MVNW_REPO_PATTERN = if (\$USE_MVND -eq \$False) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  \$distributionUrl = "\$env:MVNW_REPOURL\$MVNW_REPO_PATTERN\$(\$distributionUrl -replace "^.*\$MVNW_REPO_PATTERN",'')"
}
\$distributionUrlName = \$distributionUrl -replace '^.*/',''
\$distributionUrlNameMain = \$distributionUrlName -replace '\.[^.]*\$','' -replace '-bin\$',''

\$MAVEN_M2_PATH = "\$HOME/.m2"
if (\$env:MAVEN_USER_HOME) {
  \$MAVEN_M2_PATH = "\$env:MAVEN_USER_HOME"
}

if (-not (Test-Path -Path \$MAVEN_M2_PATH)) {
    New-Item -Path \$MAVEN_M2_PATH -ItemType Directory | Out-Null
}

\$MAVEN_WRAPPER_DISTS = \$null
if ((Get-Item \$MAVEN_M2_PATH).Target[0] -eq \$null) {
  \$MAVEN_WRAPPER_DISTS = "\$MAVEN_M2_PATH/wrapper/dists"
} else {
  \$MAVEN_WRAPPER_DISTS = (Get-Item \$MAVEN_M2_PATH).Target[0] + "/wrapper/dists"
}

\$MAVEN_HOME_PARENT = "\$MAVEN_WRAPPER_DISTS/\$distributionUrlNameMain"
\$MAVEN_HOME_NAME = ([System.Security.Cryptography.SHA256]::Create().ComputeHash([byte[]][char[]]\$distributionUrl) | ForEach-Object {\$_.ToString("x2")}) -join ''
\$MAVEN_HOME = "\$MAVEN_HOME_PARENT/\$MAVEN_HOME_NAME"

if (Test-Path -Path "\$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at \$MAVEN_HOME"
  Write-Output "MVN_CMD=\$MAVEN_HOME/bin/\$MVN_CMD"
  exit \$?
}

if (! \$distributionUrlNameMain -or (\$distributionUrlName -eq \$distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found \$distributionUrl"
}

# prepare tmp dir
\$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
\$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "\$TMP_DOWNLOAD_DIR_HOLDER.dir"
\$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if (\$TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item \$TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove \$TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "\$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: \$distributionUrl"
Write-Verbose "Downloading to: \$TMP_DOWNLOAD_DIR/\$distributionUrlName"

\$webclient = New-Object System.Net.WebClient
if (\$env:MVNW_USERNAME -and \$env:MVNW_PASSWORD) {
  \$webclient.Credentials = New-Object System.Net.NetworkCredential(\$env:MVNW_USERNAME, \$env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
\$webclient.DownloadFile(\$distributionUrl, "\$TMP_DOWNLOAD_DIR/\$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
\$distributionSha256Sum = (Get-Content -Raw "\$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if (\$distributionSha256Sum) {
  if (\$USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module \$PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne \$distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -DestinationPath "\$TMP_DOWNLOAD_DIR" | Out-Null

# Find the actual extracted directory name (handles snapshots where filename != directory name)
\$actualDistributionDir = ""

# First try the expected directory name (for regular distributions)
\$expectedPath = Join-Path "\$TMP_DOWNLOAD_DIR" "\$distributionUrlNameMain"
\$expectedMvnPath = Join-Path "\$expectedPath" "bin/\$MVN_CMD"
if ((Test-Path -Path \$expectedPath -PathType Container) -and (Test-Path -Path \$expectedMvnPath -PathType Leaf)) {
  \$actualDistributionDir = \$distributionUrlNameMain
}

# If not found, search for any directory with the Maven executable (for snapshots)
if (!\$actualDistributionDir) {
  Get-ChildItem -Path "\$TMP_DOWNLOAD_DIR" -Directory | ForEach-Object {
    \$testPath = Join-Path \$_.FullName "bin/\$MVN_CMD"
    if (Test-Path -Path \$testPath -PathType Leaf) {
      \$actualDistributionDir = \$_.Name
    }
  }
}

if (!\$actualDistributionDir) {
  Write-Error "Could not find Maven distribution directory in extracted archive"
}

Write-Verbose "Found extracted Maven distribution directory: \$actualDistributionDir"
Rename-Item -Path "\$TMP_DOWNLOAD_DIR/\$actualDistributionDir" -NewName \$MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "\$TMP_DOWNLOAD_DIR/\$MAVEN_HOME_NAME" -Destination \$MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "\$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item \$TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove \$TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=\$MAVEN_HOME/bin/\$MVN_CMD"
CMD;
    }

    /**
     * Generates the application.properties file.
     * @return string The content of application.properties.
     */
    public function generateApplicationProperties() {
        $requireLoginValue = $this->requireLogin ? 'true' : 'false';
        return <<<PROPERTIES
############################################
# 1. APPLICATION
############################################

# The name of the Spring Boot application.
spring.application.name={$this->projectConfig['name']}

spring.main.allow-bean-definition-overriding=true

# Default language used for internationalization (i18n).
app.i18n.default-language=en


############################################
# 2. SECURITY SETTINGS
############################################

# Whether user login is required to access protected endpoints.
app.security.require-login=false

# Enables CORS (Cross-Origin Resource Sharing).
app.security.cors.enabled=true

# List of allowed origins for CORS requests.
app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

# Additional global override to allow all origins (*). Not recommended for production.
app.cors.origins="*"


############################################
# 3. SESSION MANAGEMENT
############################################

# Session store type. "none" means using default servlet container session.
spring.session.store-type=none

# Disables Redis repository auto-configuration.
spring.data.redis.repositories.enabled=false

# Excludes Redis auto-configuration since Redis is not used.
spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration

# Session timeout duration.
server.servlet.session.timeout=30m

# Maximum lifetime for the session cookie.
server.servlet.session.cookie.max-age=30m


############################################
# 4. DATABASE CONFIGURATION
############################################

# JDBC connection URL for the MySQL database.
spring.datasource.url={DB_URL}

# Database username.
spring.datasource.username={DB_USER}

# Database password. Should be moved to environment variables for security.
spring.datasource.password={DB_PASS}

# MySQL JDBC driver class name.
spring.datasource.driver-class-name={DB_DRIVER_CLASS}


############################################
# 5. JPA / HIBERNATE
############################################

# Whether Hibernate should show executed SQL statements in logs.
spring.jpa.show-sql=false

# Hibernate SQL dialect for MySQL.
spring.jpa.properties.hibernate.dialect={DB_DIALECT}

# Uses the same column names as in the database without name conversion.
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl


############################################
# 6. GRAPHQL CONFIGURATION
############################################

# Enables GraphiQL web interface for testing GraphQL queries.
spring.graphql.graphiql.enabled=true

# Folder where GraphQL schema files are located.
spring.graphql.schema.locations=classpath:graphql/

# File extension for GraphQL schema definition files.
spring.graphql.schema.file-extensions=.graphqls


############################################
# 7. CACHING (Optional)
############################################

# Enables Caffeine caching if uncommented.
# spring.cache.type=caffeine


############################################
# 8. REDIS CONFIG (FOR application-redis.properties)
############################################

# Enables Redis session store when using Redis profile.
# spring.session.store-type=redis

# Redis server hostname.
# spring.data.redis.host=localhost

# Redis server port.
# spring.data.redis.port=6379

# Session timeout when using Redis-backed sessions.
# spring.session.timeout=30m

PROPERTIES;
    }

    /**
     * Generates the main Spring Boot application class in Kotlin.
     *
     * @return string The content of the main application class.
     */
    private function generateMainAppClass() {
        $className = $this->pascalCase($this->projectConfig['artifactId']) . 'Application';
        $packageName = $this->projectConfig['packageName'];
        $cacheImport = $this->useCache ? "import org.springframework.cache.annotation.EnableCaching\n" : "";
        $cacheAnnotation = $this->useCache ? "@EnableCaching\n" : "";

        return <<<KOTLIN
package $packageName

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
$cacheImport
$cacheAnnotation
@SpringBootApplication
class $className

fun main(args: Array<String>) {
    runApplication<$className>(*args)
}
KOTLIN;
    }

    /**
     * Generates the Kotlin entity data class for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the entity class.
     */
    private function generateEntityClass($tableName, $tableInfo) {
        $className = $this->pascalCase($tableName);
        $packageName = $this->projectConfig['packageName'];
        
        $imports = "import jakarta.persistence.*\nimport java.io.Serializable\n";
        $fields = "";
        $importSet = array();

        $nCols = count($tableInfo['columns']);
        $i = 1;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);
            
            if (strpos($kotlinType, 'LocalDateTime') !== false) {
                $importSet['java.time.LocalDateTime'] = "import java.time.LocalDateTime";
                $importSet['JsonFormat'] = "import com.fasterxml.jackson.annotation.JsonFormat";
                $fields .= "    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd HH:mm:ss\")\n";
            } else if (strpos($kotlinType, 'LocalDate') !== false) {
                $importSet['java.time.LocalDate'] = "import java.time.LocalDate";
                $importSet['JsonFormat'] = "import com.fasterxml.jackson.annotation.JsonFormat";
                $fields .= "    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd\")\n";
            }
            
            if ($colInfo['isPrimaryKey']) {
                $fields .= "    @Id\n";
                if ($colInfo['isAutoIncrement']) {
                    if($colInfo['primaryKeyValue'] == 'autogenerated') {
                        $fields .= "    @GeneratedValue(strategy = GenerationType.IDENTITY)\n";
                    }
                }
            }
            
            if ($colInfo['isForeignKey']) {
                $importSet['JsonIgnore'] = "import com.fasterxml.jackson.annotation.JsonIgnore";
                $importSet['NotFound'] = "import org.hibernate.annotations.NotFound";
                $importSet['NotFoundAction'] = "import org.hibernate.annotations.NotFoundAction";
                
                $refTableName = $colInfo['references'];
                $refClassName = $this->pascalCase($refTableName);
                $refFieldName = $this->camelCase($refTableName);

                // Foreign key column
                $fields .= "    @Column(name = \"$colName\")\n";
                $fields .= "    var $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n\n";
                
                // Relationship
                $fields .= "    @JsonIgnore\n";
                $fields .= "    @ManyToOne(fetch = FetchType.LAZY)\n";
                $fields .= "    @NotFound(action = NotFoundAction.IGNORE)\n";
                $fields .= "    @JoinColumn(name = \"$colName\", insertable = false, updatable = false)\n";
                $fields .= "    var $refFieldName: $refClassName? = null,\n\n";
                continue;
            } else if ($fieldName !== $colName) {
                $fields .= "    @Column(name = \"$colName\")\n";
            }
            
            $fields .= "    var $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n\n";
            
        }
        
        $imports .= implode("\n", $importSet);

        // Use 'class' instead of 'data class' if there are no fields to avoid compilation errors.
        $classType = !empty(trim($fields)) ? 'data class' : 'class';
        $fields = rtrim($fields);
        $fields = rtrim($fields, ", ");

        return <<<KOTLIN
package $packageName.model.entity;

$imports

@Entity
@Table(name = "$tableName")
$classType $className(
$fields
) : Serializable
KOTLIN;
    }

    /**
     * Generates the Kotlin repository interface for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the repository interface.
     */
    private function generateRepositoryInterface($tableName, $tableInfo) {
        $className = $this->pascalCase($tableName);
        $packageName = $this->projectConfig['packageName'];
        $pkKotlinType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkKotlinType = $this->mapDbTypeToKotlinType($col['type'], $col['length']);
                break;
            }
        }

        $imports = "import org.springframework.data.jpa.repository.JpaRepository\n";
        $imports .= "import org.springframework.data.jpa.repository.JpaSpecificationExecutor\n";
        $imports .= "import org.springframework.stereotype.Repository\n";
        $imports .= "import $packageName.model.entity.$className\n";

        $modifying = "";

        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        if ($pkInfo) {
            $pkCamelCase = $this->camelCase($pkInfo['name']);
            $pkUpperCamelCase = $this->pascalCase($pkInfo['name']);
            $pkKotlinType = $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']);

            if (!$pkInfo['isAutoIncrement'] && $pkInfo['primaryKeyValue'] != 'autogenerated') {
                $imports .= "import org.springframework.data.jpa.repository.Modifying\n";
                $imports .= "import org.springframework.data.jpa.repository.Query\n";
                $imports .= "import org.springframework.data.repository.query.Param\n";
                $imports .= "import org.springframework.transaction.annotation.Transactional\n";
                $modifying = "\n    @Modifying\n";
                $modifying .= "    @Transactional\n";
                $modifying .= "    @Query(\"UPDATE $className a SET a.$pkCamelCase = :newId WHERE a.$pkCamelCase = :oldId\")\n";
                $modifying .= "    fun update{$pkUpperCamelCase}(@Param(\"oldId\") oldId: $pkKotlinType, @Param(\"newId\") newId: $pkKotlinType): Int\n";
            }
        }

        return <<<KOTLIN
package $packageName.model.repository

{$imports}

@Repository
interface {$className}Repository : JpaRepository<$className, $pkKotlinType>, JpaSpecificationExecutor<$className> {
    {$modifying}
}
KOTLIN;
    }

    /**
     * Generates the DTO data class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the DTO class.
     */
    private function generateDtoClass($tableName, $tableInfo) {
        $className = $this->pascalCase($tableName) . "Input";
        $packageName = $this->projectConfig['packageName'];

        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        $fields = "";
        $importSet = array();

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if(in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);

            if (strpos($kotlinType, 'LocalDateTime') !== false) {
                $importSet['java.time.LocalDateTime'] = "import java.time.LocalDateTime";
            } else if (strpos($kotlinType, 'LocalDate') !== false) {
                $importSet['java.time.LocalDate'] = "import java.time.LocalDate";
            }

            $fields .= "    val $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n";
        }
        
        $imports = implode("\n", $importSet);
        $trimmedFields = rtrim(trim($fields), ',');

        return <<<KOTLIN
package $packageName.model.dto

$imports

data class $className(
$trimmedFields
)
KOTLIN;
    }

    /**
     * Generates the Controller class for a given table in Kotlin.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the Controller class.
     */
    private function generateControllerClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);
        $package = $this->projectConfig['packageName'];
        
        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        $pkKotlinType = 'String';
        $pkAutogenerated = false;
        if ($pkInfo) {
            $pkKotlinType = $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']);
            $pkAutogenerated = $pkInfo['isAutoIncrement'] || $pkInfo['primaryKeyValue'] == 'autogenerated';
        }
        $pkKotlinType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkKotlinType = $this->mapDbTypeToKotlinType($col['type'], $col['length']);
                break;
            }
        }

        $fieldResolvers = $this->generateFieldResolversKt($tableName, $tableInfo);
        $importScalarValueUtil = strpos($fieldResolvers, 'ScalarValueUtil') !== false ? "\nimport $package.util.ScalarValueUtil" : "";

        $returnUpdate = "        return {$camelName}Repository.save(entity)\n";
        if (!$pkAutogenerated && $pkInfo) {
            $pkCamelCase = $this->camelCase($pkInfo['name']);
            $pkUpperCamelCase = $this->pascalCase($pkInfo['name']);
            $returnUpdate = "        {$camelName}Repository.save(entity)\n";
            $returnUpdate .= "        // Update $pkCamelCase\n";
            $returnUpdate .= "        dtoInput.$pkCamelCase?.let {\n";
            $returnUpdate .= "            val rowsAffected = {$camelName}Repository.update{$pkUpperCamelCase}(entity.$pkCamelCase!!, it)\n";
            $returnUpdate .= "            if (rowsAffected > 0) {\n";
            $returnUpdate .= "                entity.$pkCamelCase = it\n";
            $returnUpdate .= "            }\n";
            $returnUpdate .= "        }\n";
            $returnUpdate .= "        return entity\n";
        }

        $relatedEntityImports = "";
        foreach ($tableInfo['columns'] as $colInfo) {
            if ($colInfo['isForeignKey']) {
                $refClassName = $this->pascalCase($colInfo['references']);
                $relatedEntityImports .= "\nimport $package.model.entity.$refClassName";
            }
        }

        return <<<KOTLIN
package $package.controller

import $package.model.dto.core.FilterInput
import $package.model.dto.core.SortInput
import $package.model.dto.{$ucCamelName}Input
import $package.model.entity.$ucCamelName
import $package.model.repository.{$ucCamelName}Repository
import $package.model.repository.core.AdminRepository
import $package.util.I18nUtil
import $package.util.QueryUtil
import $package.util.ValueUtil
import $package.util.AuditTrailUtil$importScalarValueUtil$relatedEntityImports

import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.graphql.data.method.annotation.SchemaMapping

import org.springframework.stereotype.Controller
import org.springframework.transaction.annotation.Transactional
import org.springframework.web.bind.annotation.RequestHeader

import graphql.schema.DataFetchingEnvironment

import java.util.Optional

@Controller
class {$ucCamelName}Controller(
    private val {$camelName}Repository: {$ucCamelName}Repository,
    private val i18n: I18nUtil
) {

    @QueryMapping
    fun {$camelName}(@Argument id: $pkKotlinType): $ucCamelName? {
        return {$camelName}Repository.findById(id).orElse(null)
    }

    @QueryMapping
    fun {$pluralCamelName}(
        @Argument limit: Int?,
        @Argument offset: Int?,
        @Argument page: Int?,
        @Argument size: Int?,
        @Argument orderBy: List<SortInput>?,
        @Argument filter: List<FilterInput>?
    ): Map<String, Any> {
        val pageable = QueryUtil.createPageable(limit, offset, page, size, orderBy)
        val specification = QueryUtil.createSpecification<$ucCamelName>(filter)
        val resultPage = {$camelName}Repository.findAll(specification, pageable)
        return QueryUtil.createPageResultMap(resultPage)
    }

    @MutationMapping
    @Transactional
    fun create{$ucCamelName}(
        @Argument input: Map<String, Any>
    ): $ucCamelName {
        val lang = AuditTrailUtil.getLanguageId()
        val dtoInput = ValueUtil.convertSnakeCaseToDto(input, {$ucCamelName}Input::class.java)
        val entity = {$ucCamelName}()
{$this->generateDtoToEntityMappingKt($tableName, $tableInfo, 'entity', 'dtoInput', 'create')}
        return {$camelName}Repository.save(entity)
    }

    @MutationMapping
    @Transactional
    fun update{$ucCamelName}(
        @Argument id: $pkKotlinType,
        @Argument input: Map<String, Any>
    ): $ucCamelName {
        val lang = AuditTrailUtil.getLanguageId()
        val dtoInput = ValueUtil.convertSnakeCaseToDto(input, {$ucCamelName}Input::class.java)
        val entity = {$camelName}Repository.findById(id)
            .orElseThrow { RuntimeException(i18n.t("no_item_found_with_id", lang, "$tableName", id)) }
{$this->generateDtoToEntityMappingKt($tableName, $tableInfo, 'entity', 'dtoInput', 'update')}
$returnUpdate
    }

    @MutationMapping
    @Transactional
    fun delete{$ucCamelName}(@Argument id: $pkKotlinType): Boolean {
        {$camelName}Repository.deleteById(id)
        return true
    }
{$this->generateToggleActiveMutationKt($tableName, $tableInfo)}
$fieldResolvers
}
KOTLIN;
    }

    /**
     * Maps Kotlin types to GraphQL types.
     *
     * @param string $kotlinType The Kotlin type.
     * @return string The corresponding GraphQL type.
     */
    private function mapKotlinTypeToGqlType($kotlinType) {
        $baseType = basename(str_replace('\\', '/', $kotlinType));
        switch ($baseType) {
            case 'Int':
                return 'Int';
            case 'Double':
            case 'Float':
                return 'Float';
            case 'Boolean':
                return 'Boolean';
            case 'String':
            case 'LocalDate':
            case 'LocalDateTime':
                return 'String'; // Or custom scalars
            default:
                return 'String';
        }
    }
    
    /**
     * Get project configuration.
     */
    public function getProjectConfig()
    {
        return $this->projectConfig;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information including columns and primary key.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);
        
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();

        // Type fields
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapKotlinTypeToGqlType($this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original snake_case name
            if ($colInfo['isForeignKey']) {
                $refUcCamelName = $this->pascalCase($colInfo['references']);
                $fields .= "    $fieldName: $gqlType\n"; // Keep the ID field
                $fields .= "    {$colInfo['references']}: $refUcCamelName\n"; // Use original table name for relation
            } else {
                $fields .= "    $fieldName: $gqlType\n";
            }
        }

        // Input fields
        $inputFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if(in_array($colName, $backendHandledColumnNames))
            {
                continue;
            }
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $gqlType = $this->mapKotlinTypeToGqlType($this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original snake_case name
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $types = <<<GQL
type $ucCamelName {
$fields}

input {$ucCamelName}Input {
$inputFields}

type {$ucCamelName}Page {
    items: [$ucCamelName],
    total: Int,
    limit: Int,
    page: Int,
    totalPages: Int,
    hasNext: Boolean,
    hasPrevious: Boolean
}
GQL;
        $pkType = $this->mapKotlinTypeToGqlType($this->mapDbTypeToKotlinType($tableInfo['columns'][$tableInfo['primaryKey']]['type'], $tableInfo['columns'][$tableInfo['primaryKey']]['length']));

        $queries = "    {$camelName}(id: {$pkType}!): $ucCamelName\n";
        $queries .= "    {$pluralCamelName}(limit: Int, offset: Int, page: Int, size: Int, orderBy: [SortInput], filter: [FilterInput]): {$ucCamelName}Page\n";

        $mutations = "    create{$ucCamelName}(input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    update{$ucCamelName}(id: {$pkType}!, input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    delete{$ucCamelName}(id: {$pkType}!): Boolean\n";
        
        if ($tableInfo['hasActiveColumn']) {
            $activeField = $this->camelCase($this->activeField);
            $mutations .= "    toggle{$ucCamelName}Active(id: {$pkType}!, $activeField: Boolean!): $ucCamelName\n";
        }

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Combines all schema parts into a single GraphQL schema string.
     *
     * @param array $allSchemaParts Array of type definitions.
     * @param array $allQueryFields Array of query definitions.
     * @param array $allMutationFields Array of mutation definitions.
     * @return string The complete GraphQL schema.
     */
    private function generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields) {
        $typesString = implode("\n", $allSchemaParts);
        $queriesString = implode("", $allQueryFields);
        $mutationsString = implode("", $allMutationFields);

        return <<<GQL
enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Object
    operator: FilterOperator
}

$typesString

type Query {
$queriesString}

scalar Object

type Mutation {
$mutationsString}
GQL;
    }

    /**
     * Get whether to enable verbose logging in the generated application.
     *
     * @return bool True if verbose logging is enabled, false otherwise.
     */ 
    public function getVerboseLogging()
    {
        return $this->verboseLogging;
    }

    /**
     * Retrieves metadata information about the primary key column from the table definition.
     *
     * This method scans all columns in the provided table metadata and returns the full
     * column information for the one marked as the primary key. The returned array
     * includes all properties from the column definition plus an additional `name`
     * field representing the column name.
     *
     * Example returned structure:
     * [
     *     'name' => 'id',
     *     'type' => 'varchar',
     *     'length' => 40,
     *     'isPrimaryKey' => true,
     *     'isAutoIncrement' => false,
     *     'primaryKeyValue' => 'autogenerated'
     * ]
     *
     * @param array $tableInfo
     *        Table metadata containing a `columns` array with column definitions.
     *
     * @return array|null
     *         The primary key column information, or null if no primary key exists.
     */
    private function findPrimaryKeyInfo($tableInfo)
    {
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey']) {
                return array_merge($colInfo, ['name' => $colName]);
            }
        }
        return null;
    }

    /**
     * Generates Kotlin code for mapping DTO input fields into an entity instance.
     *
     * The generated mapping logic respects several rules:
     * - Primary key handling:
     *     - For `create` actions: validates non-auto-increment primary keys when required.
     *     - For `update` actions: skips primary key assignment.
     * - Skips backend-managed columns (timeCreate, timeEdit, adminCreate, adminEdit, ipCreate, ipEdit).
     * - For regular columns: generates Kotlin code to assign values only when the DTO field is not null.
     * - Automatically fills backend-handled fields depending on the action:
     *     - On create: assigns creation time, user, and IP if applicable.
     *     - On update: assigns edit time, user, and IP if applicable.
     *
     * @param string $tableName
     *        Name of the database table.
     *
     * @param array $tableInfo
     *        Table metadata, containing:
     *        [
     *            'primaryKey' => string,
     *            'columns' => [
     *                'column_name' => [
     *                    'name' => string,
     *                    'type' => string,
     *                    'length' => int|null,
     *                    'isAutoIncrement' => bool,
     *                    'primaryKeyValue' => string|null
     *                ],
     *                ...
     *            ]
     *        ]
     *
     * @param string $entityVar
     *        Variable name used for the Kotlin entity object inside generated code.
     *
     * @param string $dtoVar
     *        Variable name used for the DTO input object.
     *
     * @param string $action
     *        Either "create" or "update", affecting which mapping rules apply.
     *
     * @return string
     *         Kotlin source code representing the DTO-to-entity mapping.
     */
    private function generateDtoToEntityMappingKt($tableName, $tableInfo, $entityVar, $dtoVar, $action) {
        $mappingCode = "";

        $backendHandledColumnNames = $this->getBackendHandledColumnNames();

        if ($action == 'create') {
            $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
            if ($pkInfo && !$pkInfo['isAutoIncrement'] && $pkInfo['primaryKeyValue'] != 'autogenerated') {
                $pkCamelCase = $this->camelCase($pkInfo['name']);
                $mappingCode .= "        if (dtoInput.$pkCamelCase.isNullOrBlank()) {\n";
                $mappingCode .= "            throw RuntimeException(\"Invalid input: $pkCamelCase is required\")\n";
                $mappingCode .= "        }\n";
            }
        }
        $columnNames = [];
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $columnNames[] = $colName;
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated' || $action == 'update')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            
            $camelColName = $this->camelCase($colName);
            $mappingCode .= "        dtoInput.$camelColName?.let { $entityVar.$camelColName = it }\n";
        }

        $hasTimeEdit = false;
        $hasAdminEdit = false;
        $hasIpEdit = false;

        foreach($this->backendHandledColumns as $key => $col) {
            if ($action == 'create' && $key == 'timeCreate' && in_array($col['columnName'], $columnNames)) {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = java.time.LocalDateTime.now()\n";
            }
            if ($action == 'create' && $key == 'adminCreate' && in_array($col['columnName'], $columnNames)) {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = AuditTrailUtil.getUserId()\n";
            }
            if ($action == 'create' && $key == 'ipCreate' && in_array($col['columnName'], $columnNames)) {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = AuditTrailUtil.getUserIp()\n";
            }
            if ($key == 'timeEdit' && in_array($col['columnName'], $columnNames)) {
                $hasTimeEdit = true;
            }
            if ($key == 'adminEdit' && in_array($col['columnName'], $columnNames)) {
                $hasAdminEdit = true;
            }
            if ($key == 'ipEdit' && in_array($col['columnName'], $columnNames)) {
                $hasIpEdit = true;
            }
        }

        if ($hasTimeEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['timeEdit']['columnName'])." = java.time.LocalDateTime.now()\n";
        if ($hasAdminEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['adminEdit']['columnName'])." = AuditTrailUtil.getUserId()\n";
        if ($hasIpEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['ipEdit']['columnName'])." = AuditTrailUtil.getUserIp()\n";

        return $mappingCode;
    }

    /**
     * Generates a Kotlin GraphQL mutation method used to toggle the "active" status
     * of an entity. This mutation handles updating the active field as well as
     * applying backend-managed fields such as timeEdit, adminEdit, and ipEdit when
     * those columns exist.
     *
     * The generated Kotlin code includes:
     * - @MutationMapping function for toggling the active state
     * - Parameter mapping for the primary key and active flag
     * - Automatic update of audit fields (edit time, admin, IP) if present
     * - Error handling when the entity is not found
     *
     * @param string $tableName
     *        The name of the database table.
     *
     * @param array $tableInfo
     *        Metadata describing the table, including:
     *        [
     *            'hasActiveColumn' => bool,
     *            'columns' => [
     *                'column_name' => [
     *                    'type' => string,
     *                    'length' => int|null,
     *                    'isForeignKey' => bool,
     *                    'references' => string|null
     *                ],
     *                ...
     *            ]
     *        ]
     *
     * @return string
     *         Kotlin source code defining the GraphQL mutation, or an empty
     *         string if the table does not contain an active column.
     */
    private function generateToggleActiveMutationKt($tableName, $tableInfo)
    {
        if (!$tableInfo['hasActiveColumn']) {
            return "";
        }
        
        $columnNames = [];

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $columnNames[] = $colName;
        }

        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $activeField = $this->activeField;
        $camelActiveField = $this->camelCase($activeField);
        $ucActiveField = $this->pascalCase($activeField);
        
        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        $pkKotlinType = $pkInfo ? $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']) : 'String';

        $mappingCode = "";
        if (isset($this->backendHandledColumns['timeEdit']) && in_array($this->backendHandledColumns['timeEdit']['columnName'], $columnNames)) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['timeEdit']['columnName'])." = java.time.LocalDateTime.now()\n";
        }
        if (isset($this->backendHandledColumns['adminEdit']) && in_array($this->backendHandledColumns['adminEdit']['columnName'], $columnNames)) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['adminEdit']['columnName'])." = AuditTrailUtil.getUserId()\n";
        }
        if (isset($this->backendHandledColumns['ipEdit']) && in_array($this->backendHandledColumns['ipEdit']['columnName'], $columnNames)) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['ipEdit']['columnName'])." = AuditTrailUtil.getUserIp()\n";
        }

        return <<<KOTLIN

    @MutationMapping
    @Transactional
    fun toggle{$ucCamelName}Active(
        @Argument id: $pkKotlinType,
        @Argument(name = "$activeField") $activeField: Boolean
    ): $ucCamelName {
        val lang = AuditTrailUtil.getLanguageId()
        val entity = {$camelName}Repository.findById(id)
                .orElseThrow { RuntimeException(i18n.t("no_item_found_with_id", lang, "$tableName", id)) }
        entity.$camelActiveField = $activeField
$mappingCode
        return {$camelName}Repository.save(entity)
    }
KOTLIN;
    }

    /**
     * Generates Kotlin GraphQL field resolvers for a specific database table.
     *
     * This function automatically builds Kotlin resolver methods based on the
     * table structure and column definitions. It handles:
     * - Field name differences between database (snake_case) and Kotlin (camelCase)
     * - Mapping database types to Kotlin types
     * - Converting LocalDate, LocalTime, and LocalDateTime values into String
     * - Generating resolvers for foreign key relationships
     *
     * @param string $tableName
     *        The name of the database table.
     *
     * @param array $tableInfo
     *        Detailed table metadata with the following structure:
     *        [
     *            'columns' => [
     *                'column_name' => [
     *                    'type' => string,         // Database column type
     *                    'length' => int|null,     // Column length if applicable
     *                    'isForeignKey' => bool,   // Whether this column is a foreign key
     *                    'references' => string|null // Referenced table name if FK
     *                ],
     *                ...
     *            ]
     *        ]
     *
     * @return string
     *         The generated Kotlin code containing GraphQL field resolvers.
     */
    private function generateFieldResolversKt($tableName, $tableInfo) {
        $resolvers = "";
        $ucCamelTableName = $this->pascalCase($tableName);
        $camelTableName = $this->camelCase($tableName);
    
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $camelColName = $this->camelCase($colName);
            $ucCamelColName = $this->pascalCase($colName);
    
            if ($colName !== $camelColName) {
                $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
                $baseKotlinType = basename(str_replace('\\', '/', $kotlinType));

                $returnValue = "$camelTableName.$camelColName";

                if(strpos($baseKotlinType, 'LocalDateTime') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localDateTimeToString($returnValue)";
                }
                else if(strpos($baseKotlinType, 'LocalDate') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localDateToString($returnValue)";
                }
                else if(strpos($baseKotlinType, 'LocalTime') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localTimeToString($returnValue)";
                }
                else {
                    $baseKotlinType = $baseKotlinType.'?';
                }

                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$colName\")\n";
                $resolvers .= "    fun get{$ucCamelColName}($camelTableName: $ucCamelTableName): $baseKotlinType {\n";
                $resolvers .= "        return $returnValue\n";
                $resolvers .= "    }\n";
            }
    
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refCamelName = $this->camelCase($refTableName);
                $refUcCamelName = $this->pascalCase($refTableName);

                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$refTableName\")\n";
                $resolvers .= "    fun get".ucfirst($refCamelName)."($camelTableName: $ucCamelTableName): $refUcCamelName? {\n";
                $resolvers .= "        return $camelTableName.$refCamelName\n";
                $resolvers .= "    }\n";
            }
        }
    
        return $resolvers;
    }
    
}