<?php

namespace AppBuilder;
use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorKotlin` class is a powerful tool designed to automatically generate a complete Spring Boot GraphQL API in Kotlin from a JSON file that defines database entities.
 * It inspects the schema to understand tables, columns, primary keys, and foreign key relationships.
 * Based on this analysis, it produces Kotlin code for entities, repositories, DTOs, and GraphQL controllers, along with GraphQL schema files, and a comprehensive API manual in Markdown format.
 * This class streamlines the process of scaffolding a GraphQL API, reducing manual effort and ensuring consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorKotlin extends GraphQLGeneratorBase
{
    
    /**
     * @var array<string, string> Project configuration for build.gradle.kts and package structure.
     */
    private $projectConfig = array();
    
    /**
     * @var bool Whether to enable verbose logging in the generated application.
     */
    private $verboseLogging = false;
    
    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use in-memory caching for queries.
     * @param array $projectConfig Project configuration details.
     * @param bool $verboseLogging Whether to enable verbose logging.
     * @param bool $requireLogin Whether the generated application should require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $verboseLogging = false, $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'groupId' => 'io.magicapp.generated',
            'artifactId' => 'graphql-app',
            'version' => '0.0.1-SNAPSHOT',
            'name' => 'GraphQL App',
            'description' => 'GraphQL API generated by MagicAppBuilder',
            'kotlinVersion' => '1.9.23', // Kotlin version
            'javaVersion' => '21',
            'packageName' => 'io.magicapp.generated.graphqlapp',
            'verboseLogging' => $verboseLogging,
            'requireLogin' => $requireLogin
        ), $projectConfig);
        
        $this->verboseLogging = $verboseLogging;
        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Kotlin type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Kotlin type string.
     */
    private function mapDbTypeToKotlinType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'String';
        }
        if (strpos($dbType, 'timestamp') !== false) {
            return 'java.time.LocalDateTime';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'java.time.LocalDate';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'Double';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'Boolean';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'Int'; // Use Kotlin's Int
        }
        return 'String'; // Default fallback
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations for your Spring Boot application.\r\n\r\n";
        
        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in the `build.gradle.kts` file. Gradle will handle downloading them automatically.\r\n\r\n";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must configure the `src/main/resources/application.properties` file. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```properties\r\n";
        $manualContent .= "spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name\r\n";
        $manualContent .= "spring.datasource.username=your_username\r_n";
        $manualContent .= "spring.datasource.password=your_password\r\n";
        $manualContent .= "```\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $ucCamelName = $this->pascalCase($tableName);

            $manualContent .= "## " . $ucCamelName . "\r\n\r\n";

            // --- Get Fields for examples ---
            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true); // No relations for mutation return

            // --- Query Examples ---
            $manualContent .= "### Queries\r\n\r\n";

            // Get Single Item
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $ucCamelName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-" . $camelName . "-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Get List
            $manualContent .= "#### Get a list of " . $pluralCamelName . " (with filter & sort)\r\n\r\n";
            $manualContent .= "Supports `limit`, `offset`, `orderBy`, and `filter`.\r\n\r\n";

            // Find a good column for the filter example
            $filterField = $tableInfo['primaryKey'];
            $filterValue = '"your-' . $camelName . '-id"';
            $filterOperator = 'EQUALS';

            foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
                if (($columnName === 'name' || $columnName === 'title') && !$columnInfo['isForeignKey']) {
                    $filterField = $columnName;
                    $filterValue = '"some-text"';
                    $filterOperator = 'CONTAINS';
                    break;
                }
            }

            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $this->pascalCase($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(\r\n    limit: 10, \r\n    offset: 0, \r\n    orderBy: [{field: \"" . $tableInfo['primaryKey'] . "\", direction: DESC}],\r\n    filter: [{field: \"" . $filterField . "\", value: " . $filterValue . ", operator: " . $filterOperator . "}]\r\n  ) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString); // Indent fields
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // --- Mutation Examples ---
            $manualContent .= "### Mutations\r\n\r\n";

            list($inputFieldsString, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            // Create
            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $ucCamelName . " {\r\n";
            $manualContent .= "  create" . $ucCamelName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Update
            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $ucCamelName . " {\r\n";
            $manualContent .= "  update" . $ucCamelName . "(id: \"your-" . $camelName . "-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Delete
            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "Returns `true` on success.\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $ucCamelName . " {\r\n";
            $manualContent .= "  delete" . $ucCamelName . "(id: \"your-" . $camelName . "-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        return $manualContent;
    }
    
    /**
     * Generates the content for the build.gradle.kts file.
     * This includes the necessary dependencies for running the Kotlin-based GraphQL API.
     *
     * @return string The Kotlin DSL formatted content for build.gradle.kts.
     */
    public function generateBuildGradleKts()
    {
        $config = $this->projectConfig;
        return <<<KTS
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
    id("org.springframework.boot") version "3.2.5"
    id("io.spring.dependency-management") version "1.1.4"
    kotlin("jvm") version "{$config['kotlinVersion']}"
    kotlin("plugin.spring") version "{$config['kotlinVersion']}"
    kotlin("plugin.jpa") version "{$config['kotlinVersion']}"
}

group = "{$config['groupId']}"
version = "{$config['version']}"

java {
    sourceCompatibility = JavaVersion.VERSION_{$config['javaVersion']}
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-data-jpa")
    implementation("org.springframework.boot:spring-boot-starter-graphql")
    implementation("org.springframework.boot:spring-boot-starter-security")
    implementation("org.springframework.boot:spring-boot-starter-web")
    implementation("org.springframework.boot:spring-boot-starter-data-redis")
    implementation("org.springframework.session:spring-session-data-redis")
    implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
    implementation("org.jetbrains.kotlin:kotlin-reflect")

    // Database Drivers
    runtimeOnly("com.mysql:mysql-connector-j")
    runtimeOnly("org.mariadb.jdbc:mariadb-java-client")
    runtimeOnly("org.postgresql:postgresql")
    runtimeOnly("com.microsoft.sqlserver:mssql-jdbc")
    runtimeOnly("org.xerial:sqlite-jdbc")

    testImplementation("org.springframework.boot:spring-boot-starter-test")
    testImplementation("org.springframework:spring-webflux")
    testImplementation("org.springframework.graphql:spring-graphql-test")
    testImplementation("org.springframework.security:spring-security-test")
}

tasks.withType<KotlinCompile> {
    kotlinOptions {
        freeCompilerArgs += "-Xjsr305=strict"
        jvmTarget = "{$config['javaVersion']}"
    }
}

tasks.withType<Test> {
    useJUnitPlatform()
}

// All-open plugin for JPA
allOpen {
    annotation("jakarta.persistence.Entity")
    annotation("jakarta.persistence.Embeddable")
    annotation("jakarta.persistence.MappedSuperclass")
}

// No-arg plugin for JPA
noArg {
    annotation("jakarta.persistence.Entity")
}
KTS;
    }

    /**
     * Main function to generate all files for the Spring Boot project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();
        $packagePath = 'src/main/kotlin/' . str_replace('.', '/', $this->projectConfig['packageName']);

        // 1. Gradle build files
        $files[] = ['name' => 'build.gradle.kts', 'content' => $this->generateBuildGradleKts()];
        $files[] = ['name' => 'settings.gradle.kts', 'content' => 'rootProject.name = "' . $this->projectConfig['artifactId'] . '"'];
        //$files[] = ['name' => 'mvnw.cmd', 'content' => $this->generateMvnwCmd()];

        // 2. Main Application Class
        $files[] = ['name' => $packagePath . '/' . $this->pascalCase($this->projectConfig['artifactId']) . 'Application.kt', 'content' => $this->generateMainAppClass()];

        // 3. GraphQL Schema, Entities, Repositories, DTOs, Controllers
        $allSchemaParts = array();
        $allQueryFields = array();
        $allMutationFields = array();

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $files[] = ['name' => $packagePath . '/model/entity/' . $pascalName . '.kt', 'content' => $this->generateEntityClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/repository/' . $pascalName . 'Repository.kt', 'content' => $this->generateRepositoryInterface($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/dto/' . $pascalName . 'Input.kt', 'content' => $this->generateDtoClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/controller/' . $pascalName . 'Controller.kt', 'content' => $this->generateControllerClass($tableName, $tableInfo)];

            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];
        }
        
        // 4. Utility and DTO classes (converted to Kotlin)
        // Note: The original Java generator has many utility classes. Each needs a Kotlin equivalent.
        // For brevity, I'm showing the conversion pattern with a few key files.
        $files[] = ['name' => $packagePath . '/model/dto/FilterInput.kt', 'content' => $this->generateFilterInputDtoKt()];
        $files[] = ['name' => $packagePath . '/model/dto/SortInput.kt', 'content' => $this->generateSortInputDtoKt()];
        $files[] = ['name' => $packagePath . '/util/SpecificationBuilder.kt', 'content' => $this->generateSpecificationBuilderKt()];
        $files[] = ['name' => $packagePath . '/util/FilterCriteria.kt', 'content' => $this->generateFilterCriteriaKt()];
        $files[] = ['name' => $packagePath . '/util/SearchOperation.kt', 'content' => $this->generateSearchOperationKt()];
        $files[] = ['name' => $packagePath . '/util/GenericSpecification.kt', 'content' => $this->generateGenericSpecificationKt()];
        $files[] = ['name' => $packagePath . '/util/QueryUtil.kt', 'content' => $this->generateQueryUtilKt()];
        $files[] = ['name' => $packagePath . '/util/AuditTrailUtil.kt', 'content' => $this->generateAuditTrailUtilKt()];
        $files[] = ['name' => $packagePath . '/util/ValueUtil.kt', 'content' => $this->generateValueUtilKt()];
        $files[] = ['name' => $packagePath . '/util/ScalarValueUtil.kt', 'content' => $this->generateScalarValueUtilKt()];

        // 5. Combined GraphQL Schema
        $files[] = ['name' => 'src/main/resources/graphql/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        // 6. Security and Auth files (converted to Kotlin)
        $files[] = ['name' => $packagePath . '/config/SecurityConfig.kt', 'content' => $this->generateSecurityConfigKt()];
        $files[] = ['name' => $packagePath . '/config/CorsConfig.kt', 'content' => $this->generateCorsConfigKt()];
        $files[] = ['name' => $packagePath . '/config/Sha1PasswordEncoder.kt', 'content' => $this->generateSha1PasswordEncoderKt()];
        $files[] = ['name' => $packagePath . '/config/ObjectScalar.kt', 'content' => $this->generateObjectScalarKt()];
        $files[] = ['name' => $packagePath . '/config/GraphQlConfig.kt', 'content' => $this->generateGraphQlConfigKt()];
        $files[] = ['name' => $packagePath . '/model/entity/core/Admin.kt', 'content' => $this->generateAdminEntityKt()];
        $files[] = ['name' => $packagePath . '/model/repository/core/AdminRepository.kt', 'content' => $this->generateAdminRepositoryKt()];
        $files[] = ['name' => $packagePath . '/service/JpaUserDetailsService.kt', 'content' => $this->generateUserDetailsServiceKt()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginRequest.kt', 'content' => $this->generateLoginRequestDtoKt()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginResponse.kt', 'content' => $this->generateLoginResponseDtoKt()];
        $files[] = ['name' => $packagePath . '/controller/core/AuthController.kt', 'content' => $this->generateAuthControllerKt()];
        $files[] = ['name' => $packagePath . '/controller/core/UserProfileController.kt', 'content' => $this->generateUserProfileController()];
        

        return $files;
    }

    private function generateMvnwCmd()
    {
        return <<<CMD
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {\$scriptDir='%~dp0'; \$script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

\$ErrorActionPreference = "Stop"
if (\$env:MVNW_VERBOSE -eq "true") {
  \$VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
\$distributionUrl = (Get-Content -Raw "\$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!\$distributionUrl) {
  Write-Error "cannot read distributionUrl property in \$scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( \$(\$distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    \$USE_MVND = \$true
    \$distributionUrl = \$distributionUrl -replace '-bin\.[^.]*\$',"-windows-amd64.zip"
    \$MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    \$USE_MVND = \$false
    \$MVN_CMD = \$script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if (\$env:MVNW_REPOURL) {
  \$MVNW_REPO_PATTERN = if (\$USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  \$distributionUrl = "\$env:MVNW_REPOURL\$MVNW_REPO_PATTERN\$(\$distributionUrl -replace '^.*'+\$MVNW_REPO_PATTERN,'')"
}
\$distributionUrlName = \$distributionUrl -replace '^.*/',''
\$distributionUrlNameMain = \$distributionUrlName -replace '\.[^.]*\$','' -replace '-bin\$',''
\$MAVEN_HOME_PARENT = "\$HOME/.m2/wrapper/dists/\$distributionUrlNameMain"
if (\$env:MAVEN_USER_HOME) {
  \$MAVEN_HOME_PARENT = "\$env:MAVEN_USER_HOME/wrapper/dists/\$distributionUrlNameMain"
}
\$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]\$distributionUrl) | ForEach-Object {\$_.ToString("x2")}) -join ''
\$MAVEN_HOME = "\$MAVEN_HOME_PARENT/\$MAVEN_HOME_NAME"

if (Test-Path -Path "\$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at \$MAVEN_HOME"
  Write-Output "MVN_CMD=\$MAVEN_HOME/bin/\$MVN_CMD"
  exit \$?
}

if (! \$distributionUrlNameMain -or (\$distributionUrlName -eq \$distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found \$distributionUrl"
}

# prepare tmp dir
\$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
\$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "\$TMP_DOWNLOAD_DIR_HOLDER.dir"
\$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if (\$TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item \$TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove \$TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "\$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: \$distributionUrl"
Write-Verbose "Downloading to: \$TMP_DOWNLOAD_DIR/\$distributionUrlName"

\$webclient = New-Object System.Net.WebClient
if (\$env:MVNW_USERNAME -and \$env:MVNW_PASSWORD) {
  \$webclient.Credentials = New-Object System.Net.NetworkCredential(\$env:MVNW_USERNAME, \$env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
\$webclient.DownloadFile(\$distributionUrl, "\$TMP_DOWNLOAD_DIR/\$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
\$distributionSha256Sum = (Get-Content -Raw "\$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if (\$distributionSha256Sum) {
  if (\$USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module \$PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne \$distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -DestinationPath "\$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "\$TMP_DOWNLOAD_DIR/\$distributionUrlNameMain" -NewName \$MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "\$TMP_DOWNLOAD_DIR/\$MAVEN_HOME_NAME" -Destination \$MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "\$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item \$TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove \$TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=\$MAVEN_HOME/bin/\$MVN_CMD"
CMD;
    }

    /**
     * Generates the application.properties file.
     * @return string The content of application.properties.
     */
    public function generateApplicationProperties() {
        $requireLoginValue = $this->requireLogin ? 'true' : 'false';
        return <<<PROPERTIES
spring.application.name={$this->projectConfig['name']}

# Database Configuration (Please update with your details)
app.security.require-login=$requireLoginValue

# Default language for i18n
app.i18n.default-language=en

# Session Management
spring.session.store-type=none # Default to none, uncomment below to use Redis
# spring.session.store-type=redis
# spring.data.redis.host=localhost
# spring.data.redis.port=6379
# spring.session.timeout=30m

# Session and Cookie Lifetime
# Set session timeout. e.g., 30m for 30 minutes, 1h for 1 hour.
server.servlet.session.timeout=30m
server.servlet.session.cookie.max-age=30m

# CORS Configuration (Cross-Origin Resource Sharing)
app.security.cors.enabled=true
app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

spring.datasource.url={DB_URL}
spring.datasource.username={DB_USER}
spring.datasource.password={DB_PASS}
spring.datasource.driver-class-name={DB_DRIVER_CLASS}

# JPA/Hibernate Configuration
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect={DB_DIALECT}

# Use database column names directly without converting to camelCase
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# GraphQL Configuration
spring.graphql.graphiql.enabled=true
spring.graphql.schema.locations=classpath:graphql/
spring.graphql.schema.file-extensions=.graphqls

# Caching (optional)
# spring.cache.type=caffeine
PROPERTIES;
    }

    /**
     * Generates the main Spring Boot application class in Kotlin.
     *
     * @return string The content of the main application class.
     */
    private function generateMainAppClass() {
        $className = $this->pascalCase($this->projectConfig['artifactId']) . 'Application';
        $packageName = $this->projectConfig['packageName'];
        $cacheImport = $this->useCache ? "import org.springframework.cache.annotation.EnableCaching\n" : "";
        $cacheAnnotation = $this->useCache ? "@EnableCaching\n" : "";

        return <<<KOTLIN
package $packageName

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
$cacheImport
$cacheAnnotation
@SpringBootApplication
class $className

fun main(args: Array<String>) {
    runApplication<$className>(*args)
}
KOTLIN;
    }

    /**
     * Generates the Kotlin entity data class for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the entity class.
     */
    private function generateEntityClass($tableName, $tableInfo) {
        $className = $this->pascalCase($tableName);
        $packageName = $this->projectConfig['packageName'];
        
        $imports = "import jakarta.persistence.*\nimport java.io.Serializable\n";
        $fields = "";
        $importSet = array();

        $nCols = count($tableInfo['columns']);
        $i = 1;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);
            
            if (strpos($kotlinType, 'LocalDateTime') !== false) {
                $importSet['java.time.LocalDateTime'] = "import java.time.LocalDateTime";
                $importSet['JsonFormat'] = "import com.fasterxml.jackson.annotation.JsonFormat";
                $fields .= "    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd HH:mm:ss\")\n";
            } else if (strpos($kotlinType, 'LocalDate') !== false) {
                $importSet['java.time.LocalDate'] = "import java.time.LocalDate";
                $importSet['JsonFormat'] = "import com.fasterxml.jackson.annotation.JsonFormat";
                $fields .= "    @JsonFormat(shape = JsonFormat.Shape.STRING, pattern = \"yyyy-MM-dd\")\n";
            }
            
            if ($colInfo['isPrimaryKey']) {
                $fields .= "    @Id\n";
                if ($colInfo['isAutoIncrement']) {
                    if($colInfo['primaryKeyValue'] == 'autogenerated') {
                        $fields .= "    @GeneratedValue(strategy = GenerationType.IDENTITY)\n";
                    }
                }
            }
            
            if ($colInfo['isForeignKey']) {
                $importSet['JsonIgnore'] = "import com.fasterxml.jackson.annotation.JsonIgnore";
                $importSet['NotFound'] = "import org.hibernate.annotations.NotFound";
                $importSet['NotFoundAction'] = "import org.hibernate.annotations.NotFoundAction";
                
                $refTableName = $colInfo['references'];
                $refClassName = $this->pascalCase($refTableName);
                $refFieldName = $this->camelCase($refTableName);

                // Foreign key column
                $fields .= "    @Column(name = \"$colName\")\n";
                $fields .= "    var $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n\n";
                
                // Relationship
                $fields .= "    @JsonIgnore\n";
                $fields .= "    @ManyToOne(fetch = FetchType.LAZY)\n";
                $fields .= "    @NotFound(action = NotFoundAction.IGNORE)\n";
                $fields .= "    @JoinColumn(name = \"$colName\", insertable = false, updatable = false)\n";
                $fields .= "    var $refFieldName: $refClassName? = null,\n\n";
                continue;
            } else if ($fieldName !== $colName) {
                $fields .= "    @Column(name = \"$colName\")\n";
            }
            
            $fields .= "    var $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n\n";
            
        }
        
        $imports .= implode("\n", $importSet);

        // Use 'class' instead of 'data class' if there are no fields to avoid compilation errors.
        $classType = !empty(trim($fields)) ? 'data class' : 'class';
        $fields = rtrim($fields);
        $fields = rtrim($fields, ", ");

        return <<<KOTLIN
package $packageName.model.entity;

$imports

@Entity
@Table(name = "$tableName")
$classType $className(
$fields
) : Serializable
KOTLIN;
    }

    /**
     * Generates the Kotlin repository interface for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the repository interface.
     */
    private function generateRepositoryInterface($tableName, $tableInfo) {
        $className = $this->pascalCase($tableName);
        $packageName = $this->projectConfig['packageName'];
        $pkKotlinType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkKotlinType = $this->mapDbTypeToKotlinType($col['type'], $col['length']);
                break;
            }
        }

        $imports = "import org.springframework.data.jpa.repository.JpaRepository\n";
        $imports .= "import org.springframework.data.jpa.repository.JpaSpecificationExecutor\n";
        $imports .= "import org.springframework.stereotype.Repository\n";
        $imports .= "import $packageName.model.entity.$className\n";

        $modifying = "";
        $findByIdMethod = "";

        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        if ($pkInfo) {
            $pkCamelCase = $this->camelCase($pkInfo['name']);
            $pkUpperCamelCase = $this->pascalCase($pkInfo['name']);
            $pkKotlinType = $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']);

            if (!$pkInfo['isAutoIncrement'] && $pkInfo['primaryKeyValue'] != 'autogenerated') {
                $imports .= "import org.springframework.data.jpa.repository.Modifying\n";
                $imports .= "import org.springframework.data.jpa.repository.Query\n";
                $imports .= "import org.springframework.data.repository.query.Param\n";
                $imports .= "import org.springframework.transaction.annotation.Transactional\n";
                $modifying = "\n    @Modifying\n";
                $modifying .= "    @Transactional\n";
                $modifying .= "    @Query(\"UPDATE $className a SET a.$pkCamelCase = :newId WHERE a.$pkCamelCase = :oldId\")\n";
                $modifying .= "    fun update{$pkUpperCamelCase}(@Param(\"oldId\") oldId: $pkKotlinType, @Param(\"newId\") newId: $pkKotlinType): Int\n";
            }
        }

        return <<<KOTLIN
package $packageName.model.repository

{$imports}

@Repository
interface {$className}Repository : JpaRepository<$className, $pkKotlinType>, JpaSpecificationExecutor<$className> {
    {$modifying}
}
KOTLIN;
    }

    /**
     * Generates the DTO data class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the DTO class.
     */
    private function generateDtoClass($tableName, $tableInfo) {
        $className = $this->pascalCase($tableName) . "Input";
        $packageName = $this->projectConfig['packageName'];

        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        $fields = "";
        $importSet = array();

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if(in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);

            if (strpos($kotlinType, 'LocalDateTime') !== false) {
                $importSet['java.time.LocalDateTime'] = "import java.time.LocalDateTime";
            } else if (strpos($kotlinType, 'LocalDate') !== false) {
                $importSet['java.time.LocalDate'] = "import java.time.LocalDate";
            }

            $fields .= "    val $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n";
        }
        
        $imports = implode("\n", $importSet);
        $trimmedFields = rtrim(trim($fields), ',');

        return <<<KOTLIN
package $packageName.model.dto

$imports

data class $className(
$trimmedFields
)
KOTLIN;
    }

    /**
     * Generates the Controller class for a given table in Kotlin.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the Controller class.
     */
    private function generateControllerClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);
        $package = $this->projectConfig['packageName'];
        
        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        $pkKotlinType = 'String';
        $pkAutogenerated = false;
        if ($pkInfo) {
            $pkKotlinType = $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']);
            $pkAutogenerated = $pkInfo['isAutoIncrement'] || $pkInfo['primaryKeyValue'] == 'autogenerated';
        }
        $pkKotlinType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkKotlinType = $this->mapDbTypeToKotlinType($col['type'], $col['length']);
                break;
            }
        }

        $fieldResolvers = $this->generateFieldResolversKt($tableName, $tableInfo);
        $importScalarValueUtil = strpos($fieldResolvers, 'ScalarValueUtil') !== false ? "\nimport $package.util.ScalarValueUtil" : "";

        $returnUpdate = "        return {$camelName}Repository.save(entity)\n";
        if (!$pkAutogenerated && $pkInfo) {
            $pkCamelCase = $this->camelCase($pkInfo['name']);
            $pkUpperCamelCase = $this->pascalCase($pkInfo['name']);
            $returnUpdate = "        {$camelName}Repository.save(entity)\n";
            $returnUpdate .= "        // Update $pkCamelCase\n";
            $returnUpdate .= "        input.$pkCamelCase?.let {\n";
            $returnUpdate .= "            val rowsAffected = {$camelName}Repository.update${pkUpperCamelCase}(entity.$pkCamelCase!!, it)\n";
            $returnUpdate .= "            if (rowsAffected > 0) {\n";
            $returnUpdate .= "                entity.$pkCamelCase = it\n";
            $returnUpdate .= "            }\n";
            $returnUpdate .= "        }\n";
            $returnUpdate .= "        return entity\n";
        }

        $relatedEntityImports = "";
        foreach ($tableInfo['columns'] as $colInfo) {
            if ($colInfo['isForeignKey']) {
                $refClassName = $this->pascalCase($colInfo['references']);
                $relatedEntityImports .= "\nimport $package.model.entity.$refClassName";
            }
        }

        return <<<KOTLIN
package $package.controller

import $package.model.dto.FilterInput
import $package.model.dto.SortInput
import $package.model.dto.{$ucCamelName}Input
import $package.model.entity.$ucCamelName
import $package.model.repository.{$ucCamelName}Repository
import $package.util.QueryUtil
import $package.util.ValueUtil
import $package.util.AuditTrailUtil$importScalarValueUtil$relatedEntityImports
import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.graphql.data.method.annotation.SchemaMapping
import org.springframework.stereotype.Controller
import org.springframework.transaction.annotation.Transactional
import java.util.Optional

@Controller
class {$ucCamelName}Controller(private val {$camelName}Repository: {$ucCamelName}Repository) {

    @QueryMapping
    fun {$camelName}(@Argument id: $pkKotlinType): $ucCamelName? {
        return {$camelName}Repository.findById(id).orElse(null)
    }

    @QueryMapping
    fun {$pluralCamelName}(
        @Argument limit: Int?,
        @Argument offset: Int?,
        @Argument page: Int?,
        @Argument size: Int?,
        @Argument orderBy: List<SortInput>?,
        @Argument filter: List<FilterInput>?
    ): Map<String, Any> {
        val pageable = QueryUtil.createPageable(limit, offset, page, size, orderBy)
        val specification = QueryUtil.createSpecification<$ucCamelName>(filter)
        val resultPage = {$camelName}Repository.findAll(specification, pageable)
        return QueryUtil.createPageResultMap(resultPage)
    }

    @MutationMapping
    @Transactional
    fun create{$ucCamelName}(@Argument input: Map<String, Any>): $ucCamelName {
        val dtoInput = ValueUtil.convertSnakeCaseToDto(input, {$ucCamelName}Input::class.java)
        val entity = {$ucCamelName}()
{$this->generateDtoToEntityMappingKt($tableName, $tableInfo, 'entity', 'dtoInput', 'create')}
        return {$camelName}Repository.save(entity)
    }

    @MutationMapping
    @Transactional
    fun update{$ucCamelName}(@Argument id: $pkKotlinType, @Argument input: Map<String, Any>): $ucCamelName {
        val dtoInput = ValueUtil.convertSnakeCaseToDto(input, {$ucCamelName}Input::class.java)
        val entity = {$camelName}Repository.findById(id)
            .orElseThrow { RuntimeException("{$ucCamelName} not found with id \$id") }
{$this->generateDtoToEntityMappingKt($tableName, $tableInfo, 'entity', 'dtoInput', 'update')}
$returnUpdate
    }

    @MutationMapping
    @Transactional
    fun delete{$ucCamelName}(@Argument id: $pkKotlinType): Boolean {
        {$camelName}Repository.deleteById(id)
        return true
    }
{$this->generateToggleActiveMutationKt($tableName, $tableInfo)}
$fieldResolvers
}
KOTLIN;
    }

    /**
     * Maps Kotlin types to GraphQL types.
     *
     * @param string $kotlinType The Kotlin type.
     * @return string The corresponding GraphQL type.
     */
    private function mapKotlinTypeToGqlType($kotlinType) {
        $baseType = basename(str_replace('\\', '/', $kotlinType));
        switch ($baseType) {
            case 'Int':
                return 'Int';
            case 'Double':
            case 'Float':
                return 'Float';
            case 'Boolean':
                return 'Boolean';
            case 'String':
            case 'LocalDate':
            case 'LocalDateTime':
                return 'String'; // Or custom scalars
            default:
                return 'String';
        }
    }
    
    /**
     * Get project configuration.
     */
    public function getProjectConfig()
    {
        return $this->projectConfig;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information including columns and primary key.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapKotlinTypeToGqlType($this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original snake_case name
            if ($colInfo['isForeignKey']) {
                $refUcCamelName = $this->pascalCase($colInfo['references']);
                $fields .= "    $fieldName: $gqlType\n"; // Keep the ID field
                $fields .= "    {$colInfo['references']}: $refUcCamelName\n"; // Use original table name for relation
            } else {
                $fields .= "    $fieldName: $gqlType\n";
            }
        }

        // Input fields
        $inputFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $gqlType = $this->mapKotlinTypeToGqlType($this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original snake_case name
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $types = <<<GQL
type $ucCamelName {
$fields}

input {$ucCamelName}Input {
$inputFields}

type {$ucCamelName}Page {
    items: [$ucCamelName],
    total: Int,
    limit: Int,
    page: Int,
    totalPages: Int,
    hasNext: Boolean,
    hasPrevious: Boolean
}
GQL;
        $pkType = $this->mapKotlinTypeToGqlType($this->mapDbTypeToKotlinType($tableInfo['columns'][$tableInfo['primaryKey']]['type'], $tableInfo['columns'][$tableInfo['primaryKey']]['length']));

        $queries = "    {$camelName}(id: {$pkType}!): $ucCamelName\n";
        $queries .= "    {$pluralCamelName}(limit: Int, offset: Int, page: Int, size: Int, orderBy: [SortInput], filter: [FilterInput]): {$ucCamelName}Page\n";

        $mutations = "    create{$ucCamelName}(input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    update{$ucCamelName}(id: {$pkType}!, input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    delete{$ucCamelName}(id: {$pkType}!): Boolean\n";
        
        if ($tableInfo['hasActiveColumn']) {
            $activeField = $this->camelCase($this->activeField);
            $mutations .= "    toggle{$ucCamelName}Active(id: {$pkType}!, $activeField: Boolean!): $ucCamelName\n";
        }

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Combines all schema parts into a single GraphQL schema string.
     *
     * @param array $allSchemaParts Array of type definitions.
     * @param array $allQueryFields Array of query definitions.
     * @param array $allMutationFields Array of mutation definitions.
     * @return string The complete GraphQL schema.
     */
    private function generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields) {
        $typesString = implode("\n", $allSchemaParts);
        $queriesString = implode("", $allQueryFields);
        $mutationsString = implode("", $allMutationFields);

        return <<<GQL
enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Object
    operator: FilterOperator
}

$typesString

type Query {
$queriesString}

scalar Object

type Mutation {
$mutationsString}
GQL;
    }

    /**
     * Generates the FilterInput DTO class in Kotlin.
     * @return string The Kotlin code for FilterInput.kt.
     */
    private function generateFilterInputDtoKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.dto

data class FilterInput(
    val field: String,
    val value: Any?,
    val operator: String?
)
KOTLIN;
    }

    /**
     * Generates the SortInput DTO class in Kotlin.
     * @return string The Kotlin code for SortInput.kt.
     */
    private function generateSortInputDtoKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.dto

data class SortInput(
    val field: String,
    val direction: String? = "ASC"
)
KOTLIN;
    }

    /**
     * Generates the QueryUtil object in Kotlin.
     *
     * @return string The Kotlin code for QueryUtil.kt.
     */
    private function generateQueryUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import $package.model.dto.SortInput
import org.springframework.data.domain.Page
import org.springframework.data.domain.PageRequest
import org.springframework.data.domain.Pageable
import org.springframework.data.domain.Sort

object QueryUtil {

    fun createPageable(limit: Int?, offset: Int?, page: Int?, size: Int?, orderBy: List<SortInput>?): Pageable {
        val pageSize = limit ?: size ?: 20
        val pageNum = when {
            offset != null && pageSize > 0 -> offset / pageSize
            page != null -> if (page > 0) page - 1 else 0
            else -> 0
        }

        val sort = orderBy?.map {
            Sort.Order(Sort.Direction.fromString(it.direction ?: "ASC"), it.field)
        }?.let { Sort.by(it) } ?: Sort.unsorted()

        return PageRequest.of(pageNum, pageSize, sort)
    }

    fun <T> createPageResultMap(resultPage: Page<T>): Map<String, Any> {
        return mapOf(
            "items" to resultPage.content,
            "total" to resultPage.totalElements,
            "limit" to resultPage.size,
            "page" to resultPage.number + 1,
            "totalPages" to resultPage.totalPages,
            "hasNext" to resultPage.hasNext(),
            "hasPrevious" to resultPage.hasPrevious()
        )
    }

    fun <T> createSpecification(filter: List<FilterInput>?): Specification<T>? {
        if (filter.isNullOrEmpty()) {
            return null
        }
        val builder = SpecificationBuilder<T>()
        filter.forEach { f -> builder.with(f.field, SearchOperation.valueOf(f.operator.uppercase()), f.value) }
        return builder.build()
    }
}
KOTLIN;
    }

    /**
     * Generates the SecurityConfig class for application security in Kotlin.
     *
     * @return string The Kotlin code for SecurityConfig.kt.
     */
    private function generateSecurityConfigKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.annotation.web.invoke
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.web.SecurityFilterChain

@Configuration
@EnableWebSecurity
@EnableMethodSecurity(prePostEnabled = true)
class SecurityConfig(
    private val jpaUserDetailsService: JpaUserDetailsService,
    private val passwordEncoder: Sha1PasswordEncoder
) {

    @Value("\${app.security.require-login:true}")
    private val requireLogin: Boolean = true

    @Bean
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            csrf { disable() }
            authorizeRequests {
                authorize("/login", permitAll)
                authorize("/logout", permitAll)
                authorize("/update-password", permitAll)
                authorize("/graphiql", permitAll)
                authorize("/vendor/**", permitAll)
                authorize("/index.html", permitAll)
                authorize("/", permitAll)
                if (requireLogin) {
                    authorize(anyRequest, authenticated)
                } else {
                    authorize(anyRequest, permitAll)
                }
            }
            userDetailsService = jpaUserDetailsService
        }
        return http.build()
    }

    @Configuration
    @ConditionalOnProperty(value = ["spring.session.store-type"], havingValue = "redis")
    @EnableRedisHttpSession
    class RedisSessionConfig
}
KOTLIN;
    }

    /**
     * Generates the CorsConfig class for CORS configuration in Kotlin.
     * @return string The Kotlin code for CorsConfig.kt.
     */
    private function generateCorsConfigKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration
@Configuration
class CorsConfig {

    @Value("$"."{app.cors.origins:*}")
    private lateinit var origins: String

    @Bean
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/**").allowedOrigins(*origins.split(",").toTypedArray())
            }
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the Sha1PasswordEncoder class in Kotlin.
     * @return string The Kotlin code for Sha1PasswordEncoder.kt.
     */
    private function generateSha1PasswordEncoderKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import org.springframework.security.crypto.password.PasswordEncoder
import java.math.BigInteger
import java.security.MessageDigest

class Sha1PasswordEncoder : PasswordEncoder {

    override fun encode(rawPassword: CharSequence): String {
        return sha1(sha1(rawPassword.toString()))
    }

    override fun matches(rawPassword: CharSequence, encodedPassword: String): Boolean {
        return encodedPassword == encode(rawPassword)
    }

    fun sha1(input: String): String {
        val md = MessageDigest.getInstance("SHA-1")
        val messageDigest = md.digest(input.toByteArray())
        val no = BigInteger(1, messageDigest)
        var hashtext = no.toString(16)
        while (hashtext.length < 40) {
            hashtext = "0\$hashtext"
        }
        return hashtext
    }
}
KOTLIN;
    }

    /**
     * Generates the JpaUserDetailsService class in Kotlin.
     * @return string The Kotlin code for JpaUserDetailsService.kt.
     */
    private function generateUserDetailsServiceKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.service

import $package.model.repository.core.AdminRepository
import org.springframework.security.core.userdetails.User
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import org.springframework.stereotype.Service

@Service
class JpaUserDetailsService(private val adminRepository: AdminRepository) : UserDetailsService {

    override fun loadUserByUsername(username: String): UserDetails {
        val admin = adminRepository.findByUsername(username)
            .orElseThrow { UsernameNotFoundException("Username not found: $username") }

        return User.withUsername(admin.username!!)
            .password(admin.password!!)
            .authorities("USER").build()
    }
}
KOTLIN;
    }

    /**
     * Generates the Admin entity class in Kotlin.
     * @return string The Kotlin code for Admin.kt.
     */
    private function generateAdminEntityKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.entity.core

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "admin")
data class Admin(
    @Id
    @Column(name = "admin_id")
    var adminId: String? = null,
    var username: String? = null,
    var password: String? = null,
    var name: String? = null,
    var email: String? = null,
    var phone: String? = null,
    @Column(name = "admin_level_id")
    var adminLevelId: String? = null
)
KOTLIN;
    }

    /**
     * Generates the AdminRepository interface in Kotlin.
     * @return string The Kotlin code for AdminRepository.kt.
     */
    private function generateAdminRepositoryKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.repository.core

import $package.model.entity.core.Admin
import org.springframework.data.jpa.repository.JpaRepository
import java.util.Optional

interface AdminRepository : JpaRepository<Admin, String> {
    fun findByUsername(username: String): Optional<Admin>
}
KOTLIN;
    }

    /**
     * Generates the LoginRequest DTO in Kotlin.
     * @return string The Kotlin code for LoginRequest.kt.
     */
    private function generateLoginRequestDtoKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.dto

data class LoginRequest(
    val username: String,
    val password: String
)
KOTLIN;
    }

    /**
     * Generates the LoginResponse DTO in Kotlin.
     * @return string The Kotlin code for LoginResponse.kt.
     */
    private function generateLoginResponseDtoKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.dto

data class LoginResponse(
    val success: Boolean,
    val message: String
)
KOTLIN;
    }

    private function generateUserProfileController()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.core

import $package.model.repository.AdminRepository
import jakarta.servlet.http.HttpSession
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.stereotype.Controller

data class UserProfile(val username: String)

@Controller
class UserProfileController(private val adminRepository: AdminRepository) {

    @QueryMapping
    @PreAuthorize("isAuthenticated()")
    fun userProfile(session: HttpSession): UserProfile? {
        val username = session.getAttribute("username") as? String
        if (username != null) {
            val adminOptional = adminRepository.findByUsername(username)
            if (adminOptional.isPresent) {
                val admin = adminOptional.get()
                return UserProfile(username = admin.username!!)
            }
        }
        return null
    }

    @QueryMapping
    fun me(session: HttpSession): Map<String, Any?> {
        return mapOf("username" to session.getAttribute("username"))
    }
}
KOTLIN;

    }

    /**
     * Generates the AuthController class in Kotlin.
     * @return string The Kotlin code for AuthController.kt.
     */
    private function generateAuthControllerKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.core

import $package.config.Sha1PasswordEncoder
import $package.controller.dto.LoginResponse
import $package.model.repository.core.AdminRepository
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpSession
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
class AuthController(
    private val adminRepository: AdminRepository,
    private val passwordEncoder: Sha1PasswordEncoder
) {

    @Value("$"."{app.security.require-login:true}")
    private val requireLogin: Boolean = true

    @PostMapping("/login")
    fun login(@RequestParam username: String, @RequestParam password: String, session: HttpSession): ResponseEntity<LoginResponse> {
        if (!requireLogin) {
            return ResponseEntity.ok(LoginResponse(true, "Success"))
        }

        val singleHashedPassword = passwordEncoder.sha1(password)
        val adminOptional = adminRepository.findByUsername(username)

        if (adminOptional.isPresent) {
            val admin = adminOptional.get()
            if (admin.password == passwordEncoder.encode(password)) {
                session.setAttribute("username", admin.username!!)
                session.setAttribute("password", singleHashedPassword) // Store single hash
                return ResponseEntity.ok(LoginResponse(true, "Login successful"))
            }
        }

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(LoginResponse(false, "Invalid credentials"))
    }

    @RequestMapping(value = ["/logout"], method = [RequestMethod.GET, RequestMethod.POST])
    fun logout(request: HttpServletRequest): ResponseEntity<LoginResponse> {
        if (!requireLogin) {
            return ResponseEntity.ok(LoginResponse(true, "Success"))
        }
        request.session.invalidate()
        return ResponseEntity.ok(LoginResponse(true, "Logout successful"))
    }
}
KOTLIN;
    }

    // The following methods are placeholders for the full conversion.
    // The original Java generator has many more files it creates (Admin entities, Auth controllers, etc.).
    // Each would need a corresponding `generate...Kt()` method here.

    /**
     * Get whether to enable verbose logging in the generated application.
     *
     * @return bool True if verbose logging is enabled, false otherwise.
     */ 
    public function getVerboseLogging()
    {
        return $this->verboseLogging;
    }

    private function findPrimaryKeyInfo($tableInfo)
    {
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey']) {
                return array_merge($colInfo, ['name' => $colName]);
            }
        }
        return null;
    }

    private function generateDtoToEntityMappingKt($tableName, $tableInfo, $entityVar, $dtoVar, $action) {
        $mappingCode = "";

        $backendHandledColumnNames = $this->getBackendHandledColumnNames();

        if ($action == 'create') {
            $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
            if ($pkInfo && !$pkInfo['isAutoIncrement'] && $pkInfo['primaryKeyValue'] != 'autogenerated') {
                $pkCamelCase = $this->camelCase($pkInfo['name']);
                $mappingCode .= "        if (dtoInput.$pkCamelCase.isNullOrBlank()) {\n";
                $mappingCode .= "            throw RuntimeException(\"Invalid input: $pkCamelCase is required\")\n";
                $mappingCode .= "        }\n";
            }
        }

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated' || $action == 'update')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            
            $camelColName = $this->camelCase($colName);
            $mappingCode .= "        dtoInput.$camelColName?.let { $entityVar.$camelColName = it }\n";
        }

        $hasTimeEdit = false;
        $hasAdminEdit = false;
        $hasIpEdit = false;

        foreach($this->backendHandledColumns as $key => $col) {
            if ($action == 'create' && $key == 'timeCreate') {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = java.time.LocalDateTime.now()\n";
            }
            if ($action == 'create' && $key == 'adminCreate') {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = AuditTrailUtil.getUserId()\n";
            }
            if ($action == 'create' && $key == 'ipCreate') {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = AuditTrailUtil.getUserIp()\n";
            }
            if ($key == 'timeEdit') {
                $hasTimeEdit = true;
            }
            if ($key == 'adminEdit') {
                $hasAdminEdit = true;
            }
            if ($key == 'ipEdit') {
                $hasIpEdit = true;
            }
        }

        if ($hasTimeEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['timeEdit']['columnName'])." = java.time.LocalDateTime.now()\n";
        if ($hasAdminEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['adminEdit']['columnName'])." = AuditTrailUtil.getUserId()\n";
        if ($hasIpEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['ipEdit']['columnName'])." = AuditTrailUtil.getUserIp()\n";

        return $mappingCode;
    }

    private function generateToggleActiveMutationKt($tableName, $tableInfo)
    {
        if (!$tableInfo['hasActiveColumn']) {
            return "";
        }

        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $activeField = $this->activeField;
        $ucActiveField = $this->pascalCase($activeField);
        
        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        $pkKotlinType = $pkInfo ? $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']) : 'String';

        $mappingCode = "";
        if (isset($this->backendHandledColumns['timeEdit'])) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['timeEdit']['columnName'])." = java.time.LocalDateTime.now()\n";
        }
        if (isset($this->backendHandledColumns['adminEdit'])) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['adminEdit']['columnName'])." = AuditTrailUtil.getUserId()\n";
        }
        if (isset($this->backendHandledColumns['ipEdit'])) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['ipEdit']['columnName'])." = AuditTrailUtil.getUserIp()\n";
        }

        return <<<KOTLIN

    @MutationMapping
    @Transactional
    fun toggle{$ucCamelName}Active(@Argument id: $pkKotlinType, @Argument(name = "$activeField") $activeField: Boolean): $ucCamelName {
        val entity = {$camelName}Repository.findById(id)
                .orElseThrow { RuntimeException("{$ucCamelName} not found with id \$id") }
        entity.$ucActiveField = $activeField
$mappingCode
        return {$camelName}Repository.save(entity)
    }
KOTLIN;
    }

    private function generateFieldResolversKt($tableName, $tableInfo) {
        $resolvers = "";
        $ucCamelTableName = $this->pascalCase($tableName);
        $camelTableName = $this->camelCase($tableName);
    
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $camelColName = $this->camelCase($colName);
            $ucCamelColName = $this->pascalCase($colName);
    
            if ($colName !== $camelColName) {
                $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
                $baseKotlinType = basename(str_replace('\\', '/', $kotlinType));

                $returnValue = "$camelTableName.$camelColName";

                if(strpos($baseKotlinType, 'LocalDateTime') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localDateTimeToString($returnValue)";
                }
                else if(strpos($baseKotlinType, 'LocalDate') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localDateToString($returnValue)";
                }
                else if(strpos($baseKotlinType, 'LocalTime') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localTimeToString($returnValue)";
                }
                else {
                    $baseKotlinType = $baseKotlinType.'?';
                }

                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$colName\")\n";
                $resolvers .= "    fun get{$ucCamelColName}($camelTableName: $ucCamelTableName): $baseKotlinType {\n";
                $resolvers .= "        return $returnValue\n";
                $resolvers .= "    }\n";
            }
    
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refCamelName = $this->camelCase($refTableName);
                $refUcCamelName = $this->pascalCase($refTableName);

                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$refTableName\")\n";
                $resolvers .= "    fun get".ucfirst($refCamelName)."($camelTableName: $ucCamelTableName): $refUcCamelName? {\n";
                $resolvers .= "        return $camelTableName.$refCamelName\n";
                $resolvers .= "    }\n";
            }
        }
    
        return $resolvers;
    }

    private function generateSpecificationBuilderKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import org.springframework.data.jpa.domain.Specification

class SpecificationBuilder<T> {
    private val params: MutableList<FilterCriteria> = mutableListOf()

    fun with(key: String, operation: SearchOperation, value: Any?): SpecificationBuilder<T> {
        params.add(FilterCriteria(key, operation, value))
        return this
    }

    fun build(): Specification<T>? {
        if (params.isEmpty()) {
            return null
        }
        val specs = params.map { GenericSpecification<T>(it) }

        return specs.reduceOrNull { acc: Specification<T>, spec ->
            acc.and(spec)
        }
    }
}
KOTLIN;
    }

    private function generateFilterCriteriaKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

data class FilterCriteria(
    val key: String,
    val operation: SearchOperation,
    val value: Any?
)
KOTLIN;
    }

    private function generateSearchOperationKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

enum class SearchOperation {
    EQUALS,
    NOT_EQUALS,
    CONTAINS,
    GREATER_THAN,
    GREATER_THAN_OR_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUALS,
    IN,
    NOT_IN
}
KOTLIN;
    }

    private function generateGenericSpecificationKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.CriteriaQuery
import jakarta.persistence.criteria.Predicate
import jakarta.persistence.criteria.Root
import org.springframework.data.jpa.domain.Specification

lass GenericSpecification<T>(private val criteria: FilterCriteria) : Specification<T> {

    override fun toPredicate(root: Root<T>, query: CriteriaQuery<*>, builder: CriteriaBuilder): Predicate? {
        val key = criteria.key
        val value = criteria.value
        val fieldType = root.get<Any>(key).javaType

        val typedValue = value?.let {
            val stringValue = it.toString()
            when (fieldType) {
                Integer::class.java, Int::class.java -> stringValue.toIntOrNull()
                Long::class.java, Long::class.java -> stringValue.toLongOrNull()
                Double::class.java, Double::class.java -> stringValue.toDoubleOrNull()
                Float::class.java, Float::class.java -> stringValue.toFloatOrNull()
                Boolean::class.java, Boolean::class.java -> stringValue.toBoolean()
                else -> stringValue
            }
        }

        @Suppress("UNCHECKED_CAST")
        return when (criteria.operation) {
            SearchOperation.EQUALS -> builder.equal(root.get<Any>(key), typedValue)
            SearchOperation.NOT_EQUALS -> builder.notEqual(root.get<Any>(key), typedValue)
            SearchOperation.GREATER_THAN -> {
                val comparableValue = typedValue as? Comparable<Any>
                comparableValue?.let { builder.greaterThan(root.get(key), it) }
            }
            SearchOperation.GREATER_THAN_OR_EQUALS -> {
                val comparableValue = typedValue as? Comparable<Any>
                comparableValue?.let { builder.greaterThanOrEqualTo(root.get(key), it) }
            }
            SearchOperation.LESS_THAN -> {
                val comparableValue = typedValue as? Comparable<Any>
                comparableValue?.let { builder.lessThan(root.get(key), it) }
            }
            SearchOperation.LESS_THAN_OR_EQUALS -> {
                val comparableValue = typedValue as? Comparable<Any>
                comparableValue?.let { builder.lessThanOrEqualTo(root.get(key), it) }
            }
            SearchOperation.CONTAINS -> if (fieldType == String::class.java) builder.like(root.get(key), "%$typedValue%") else builder.equal(root.get<Any>(key), typedValue)
            SearchOperation.IN -> root.get<Any>(key).`in`(typedValue as? Collection<*>)
            SearchOperation.NOT_IN -> builder.not(root.get<Any>(key).`in`(typedValue as? Collection<*>))
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the AuditTrailUtil object in Kotlin.
     * @return string The Kotlin code for AuditTrailUtil.kt.
     */
    private function generateAuditTrailUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import jakarta.servlet.http.HttpServletRequest
import org.springframework.web.context.request.RequestContextHolder
import org.springframework.web.context.request.ServletRequestAttributes

object AuditTrailUtil {

    /**
     * Retrieves the client's IP address from the current request.
     * It checks for the 'X-FORWARDED-FOR' header first.
     */
    fun getUserIp(): String? {
        val request = (RequestContextHolder.getRequestAttributes() as? ServletRequestAttributes)?.request ?: return null
        var remoteAddr = request.getHeader("X-FORWARDED-FOR")
        if (remoteAddr.isNullOrEmpty()) {
            remoteAddr = request.remoteAddr
        } else {
            remoteAddr = remoteAddr.split(",")[0].trim()
        }
        return remoteAddr
    }

    /**
     * Retrieves the ID of the currently authenticated admin user from the session.
     */
    fun getUserId(): String? {
        val request = (RequestContextHolder.getRequestAttributes() as? ServletRequestAttributes)?.request ?: return null
        val session = request.getSession(false)
        return session?.getAttribute("adminId") as? String
    }
}
KOTLIN;
    }

    /**
     * Generates the ValueUtil object in Kotlin for handling naming conversions and map-to-DTO conversions.
     * @return string The content of the ValueUtil class.
     */
    private function generateValueUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.registerKotlinModule

object ValueUtil {

    private val MAPPER: ObjectMapper = ObjectMapper().apply {
        registerKotlinModule()
        registerModule(JavaTimeModule())
        configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        configure(DeserializationFeature.ACCEPT_FLOAT_AS_INT, true)
    }

    /**
     * Converts a Map with snake_case keys directly to a target DTO.
     */
    fun <T> convertSnakeCaseToDto(snakeCaseMap: Map<String, Any>?, targetClass: Class<T>): T {
        val camelCaseMap = convertSnakeToCamelCase(snakeCaseMap)
        return MAPPER.convertValue(camelCaseMap, targetClass)
    }

    /**
     * Converts the keys of a Map from snake_case to camelCase.
     */
    private fun convertSnakeToCamelCase(snakeCaseMap: Map<String, Any>?): Map<String, Any> {
        if (snakeCaseMap == null) {
            return emptyMap()
        }
        return snakeCaseMap.mapKeys { toCamelCase(it.key) }
    }

    /**
     * Converts a single snake_case string to camelCase.
     */
    fun toCamelCase(snakeCase: String): String {
        return snakeCase.split('_').reduceIndexed { index, acc, part ->
            if (index == 0) part else acc + part.replaceFirstChar { it.uppercase() }
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the `ScalarValueUtil` object in Kotlin.
     * @return string The content of the `ScalarValueUtil` class.
     */
    private function generateScalarValueUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

object ScalarValueUtil {

    private const val DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss"
    private const val DATE_FORMAT = "yyyy-MM-dd"

    private val dateTimeFormatter = DateTimeFormatter.ofPattern(DATE_TIME_FORMAT)
    private val dateFormatter = DateTimeFormatter.ofPattern(DATE_FORMAT)

    fun localDateTimeToString(datetime: LocalDateTime?): String? {
        return datetime?.format(dateTimeFormatter)
    }

    fun localDateToString(date: LocalDate?): String? {
        return date?.format(dateFormatter)
    }

    fun stringToLocalDateTime(datetime: String?): LocalDateTime? {
        return if (datetime.isNullOrEmpty()) null else LocalDateTime.parse(datetime, dateTimeFormatter)
    }

    fun stringToLocalDate(date: String?): LocalDate? {
        return if (date.isNullOrEmpty()) null else LocalDate.parse(date, dateFormatter)
    }
}
KOTLIN;
    }

    /**
     * Generates the ObjectScalar class for GraphQL custom scalar type in Kotlin.
     * @return string The Java code for ObjectScalar.java.
     */
    private function generateObjectScalarKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import graphql.language.*
import graphql.schema.Coercing
import graphql.schema.CoercingParseLiteralException
import graphql.schema.CoercingParseValueException
import graphql.schema.CoercingSerializeException

@Configuration
class ObjectScalar {

    @Bean
    fun runtimeWiringConfigurer(): RuntimeWiringConfigurer {
        val objectScalar = GraphQLScalarType.newScalar()
            .name("Object")
            .description("A custom scalar that handles Object values")
            .coercing(object : Coercing<Any?, Any?> {
                override fun serialize(dataFetcherResult: Any): Any? = dataFetcherResult
                override fun parseValue(input: Any): Any? = input
                override fun parseLiteral(input: Value<*>, variables: CoercingParseLiteralVariables): Any? = (input as? graphql.language.ObjectValue)?.objectFields
            })
            .build()

        return RuntimeWiringConfigurer { wiringBuilder: RuntimeWiring.Builder ->
            wiringBuilder.scalar(objectScalar)
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the GraphQlConfig class for GraphQL configuration in Kotlin.
     * @return string The Java code for GraphQlConfig.java.
     */
    private function generateGraphQlConfigKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import graphql.schema.GraphQLScalarType
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.execution.RuntimeWiringConfigurer

@Configuration
class GraphQlConfig {

    @Bean
    fun runtimeWiringConfigurer(): RuntimeWiringConfigurer {
        val objectScalar = GraphQLScalarType.newScalar()
            .name("Object")
            .description("A custom scalar that can represent any JSON-like object.")
            .coercing(ObjectScalar())
            .build()

        return RuntimeWiringConfigurer { builder ->
            builder.scalar(objectScalar)
        }
    }
}
KOTLIN;
    }

    
}