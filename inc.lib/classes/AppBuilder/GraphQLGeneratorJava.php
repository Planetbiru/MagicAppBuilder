<?php

namespace AppBuilder;
use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorJava` class is a powerful tool designed to automatically generate a complete Spring Boot GraphQL API from a JSON file that defines database entities.
 * It inspects the schema to understand tables, columns, primary keys, and foreign key relationships.
 * Based on this analysis, it produces Java code for entities, repositories, DTOs, and GraphQL controllers, along with GraphQL schema files, and a comprehensive API manual in Markdown format.
 * This class streamlines the process of scaffolding a GraphQL API, reducing manual effort and ensuring consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorJava extends GraphQLGeneratorBase
{
    
    /**
     * @var array<string, string> Project configuration for pom.xml and package structure.
     */
    private $projectConfig = array();
    
    /**
     * @var bool Whether to enable verbose logging in the generated application.
     */
    private $verboseLogging = false;
    
    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use in-memory caching for queries.
     * @param array $projectConfig Project configuration details.
     * @param bool $verboseLogging Whether to enable verbose logging.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $verboseLogging = false, $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'groupId' => 'io.magicapp.generated',
            'artifactId' => 'graphql-app',
            'version' => '0.0.1-SNAPSHOT',
            'name' => 'GraphQL App',
            'description' => 'GraphQL API generated by MagicAppBuilder',
            'javaVersion' => '21',
            'packageName' => 'io.magicapp.generated.graphqlapp',
            'verboseLogging' => $verboseLogging,
            'requireLogin' => $requireLogin
        ), $projectConfig);
        
        $this->verboseLogging = $verboseLogging;
        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Java type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Java type string.
     */
    private function mapDbTypeToJavaType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'String';
        }
        if (strpos($dbType, 'timestamp') !== false) {
            return 'java.time.LocalDateTime';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'java.time.LocalDate';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'Double';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'Boolean';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'Integer';
        }
        return 'String'; // Default fallback
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations for your Spring Boot application.\r\n\r\n";
        
        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in the `pom.xml` file. Maven will handle downloading them automatically.\r\n\r\n";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must configure the `src/main/resources/application.properties` file. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```properties\r\n";
        $manualContent .= "spring.application.name=YourAppName\r\n\r\n";
        $manualContent .= "# Database Configuration (Please update with your details)\r\n";
        $manualContent .= "app.security.require-login=true\r\n\r\n";
        $manualContent .= "# Session Management (optional, uncomment to use Redis)\r\n";
        $manualContent .= "# spring.session.store-type=redis\r\n";
        $manualContent .= "# spring.data.redis.host=localhost\r\n";
        $manualContent .= "# spring.data.redis.port=6379\r\n";
        $manualContent .= "# spring.session.timeout=30m\r\n\r\n";
        $manualContent .= "# CORS Configuration (Cross-Origin Resource Sharing)\r\n";
        $manualContent .= "app.security.cors.enabled=true\r\n";
        $manualContent .= "app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:8080\r\n\r\n";
        $manualContent .= "spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name\r\n";
        $manualContent .= "spring.datasource.username=your_username\r\n";
        $manualContent .= "spring.datasource.password=your_password\r\n";
        $manualContent .= "spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n\r\n";
        $manualContent .= "# JPA/Hibernate Configuration\r\n";
        $manualContent .= "spring.jpa.hibernate.ddl-auto=update\r\n";
        $manualContent .= "spring.jpa.show-sql=true\r\n";
        $manualContent .= "spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\r\n";
        $manualContent .= "spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\r\n\r\n";
        $manualContent .= "# GraphQL Properties\r\n";
        $manualContent .= "spring.graphql.graphiql.enabled=true\r\n";
        $manualContent .= "spring.graphql.schema.locations=classpath:graphql/\r\n";
        $manualContent .= "spring.graphql.schema.file-extensions=.graphqls\r\n";
        $manualContent .= "```\r\n\r\n";
        $manualContent .= "Make sure to replace `your_database_name`, `your_username`, and `your_password` with your actual database credentials.\r\n\r\n";


        $manualContent .= "### Integration with MagicAppBuilder\r\n\r\n";
        $manualContent .= "If you are integrating with MagicAppBuilder, you can use the database connection from an existing connection:\r\n\r\n";
        $manualContent .= "The generator will automatically populate the `application.properties` file with the connection details from your MagicAppBuilder project.\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        $manualContent .= "## In-Memory Cache\r\n\r\n";
        $manualContent .= "The auto-generated API can be configured to use Spring's caching abstraction. To enable it, you would add `@EnableCaching` to your main application class and configure a cache manager (e.g., Caffeine, EhCache, Redis) in your `application.properties`.\r\n\r\n";
        $manualContent .= "### Benefits\r\n\r\n";
        $manualContent .= "- **Reduced Database Load**: Fewer queries are executed on the database.\r\n";
        $manualContent .= "- **Faster Response Times**: Retrieving data from memory is significantly faster than from the database.\r\n\r\n";
        $manualContent .= "### How to Use\r\n\r\n";
        $manualContent .= "You can enable or disable this cache in the generator settings. When enabled, `@Cacheable` annotations will be added to the appropriate repository methods.\r\n\r\n";
        
        // Use the first table name as an example, or a placeholder if no tables exist.
        $exampleTableName = !empty($this->analyzedSchema) ? array_key_first($this->analyzedSchema) : 'yourEntity';

        $manualContent .= "```java\r\n";
        $manualContent .= "@Cacheable(value = \"".$this->camelCase($exampleTableName)."\", key = \"#id\")\r\n";
        $manualContent .= "Optional<".ucfirst($this->camelCase($exampleTableName))."> findById(String id);\r\n";
        $manualContent .= "```\r\n\r\n";

        $manualContent .= "---\r\n\r\n";
        
        $manualContent .= "## Security Considerations\r\n\r\n";
        $manualContent .= "For production or any publicly exposed environments, it is strongly recommended to remove files that are not essential for the API's runtime operations. This helps to minimize the attack surface and prevent potential information disclosure.\r\n\r\n";
        $manualContent .= "Please consider deleting the following files from your production server:\r\n\r\n";
        $manualContent .= "- **`manual.md`**: This file contains API documentation and is not needed for runtime.\r\n";
        $manualContent .= "\r\n";
        $manualContent .= "---\r\n\r\n";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $ucCamelName = ucfirst($camelName);

            $manualContent .= "## " . $ucCamelName . "\r\n\r\n";

            // --- Get Fields for examples ---
            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true); // No relations for mutation return

            // --- Query Examples ---
            $manualContent .= "### Queries\r\n\r\n";

            // Get Single Item
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $ucCamelName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-" . $camelName . "-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Get List
            $manualContent .= "#### Get a list of " . $pluralCamelName . " (with filter & sort)\r\n\r\n";
            $manualContent .= "Supports `limit`, `offset`, `orderBy`, and `filter`.\r\n\r\n";

            // Find a good column for the filter example
            $filterField = $tableInfo['primaryKey'];
            $filterValue = '"your-' . $camelName . '-id"';
            $filterOperator = 'EQUALS';

            // Prefer 'name' or 'title' for a CONTAINS filter
            foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
                if (($columnName === 'name' || $columnName === 'title') && !$columnInfo['isForeignKey']) {
                    $filterField = $columnName;
                    $filterValue = '"some-text"';
                    $filterOperator = 'CONTAINS';
                    break;
                }
            }

            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . ucfirst($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(\r\n    limit: 10, \r\n    offset: 0, \r\n    orderBy: [{field: \"" . $tableInfo['primaryKey'] . "\", direction: DESC}],\r\n    filter: [{field: \"" . $filterField . "\", value: " . $filterValue . ", operator: " . $filterOperator . "}]\r\n  ) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString); // Indent fields
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "    limit\r\n";
            $manualContent .= "    page\r\n";
            $manualContent .= "    totalPages\r\n";
            $manualContent .= "    hasNext\r\n";
            $manualContent .= "    hasPrevious\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // --- Mutation Examples ---
            $manualContent .= "### Mutations\r\n\r\n";

            // Get Input Fields for mutations
            list($inputFieldsString, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            // Create
            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $ucCamelName . " {\r\n";
            $manualContent .= "  create" . $ucCamelName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Update
            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $ucCamelName . " {\r\n";
            $manualContent .= "  update" . $ucCamelName . "(id: \"your-" . $camelName . "-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Delete
            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "Returns `true` on success.\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $ucCamelName . " {\r\n";
            $manualContent .= "  delete" . $ucCamelName . "(id: \"your-" . $camelName . "-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        // --- API Reference Guide ---
        $manualContent .= "## API Reference Guide\r\n\r\n";
        $manualContent .= "This section provides a reference for common arguments used in list queries.\r\n\r\n";

        // Filtering
        $manualContent .= "### Filtering (`filter`)\r\n\r\n";
        $manualContent .= "The `filter` argument allows you to narrow down results based on field values. It accepts a list of filter objects, which are combined with `AND` logic.\r\n\r\n";
        $manualContent .= "| Operator       | Description                                      | Example                                                |\r\n";
        $manualContent .= "|----------------|--------------------------------------------------|--------------------------------------------------------|\r\n";
        $manualContent .= "| `EQUALS`       | Finds records where the field exactly matches the value. | `{field: \"status\", value: \"published\"}`                |\r\n";
        $manualContent .= "| `NOT_EQUALS`   | Finds records where the field does not match the value. | `{field: \"status\", value: \"archived\", operator: NOT_EQUALS}` |\r\n";
        $manualContent .= "| `CONTAINS`     | Finds records where the text field contains the value (`LIKE '%value%'`). | `{field: \"title\", value: \"love\", operator: CONTAINS}` |\r\n";
        $manualContent .= "| `GREATER_THAN_OR_EQUALS` | Finds records where the numeric/date field is greater than or equal to the value. | `{field: \"price\", value: \"99.99\", operator: GREATER_THAN_OR_EQUALS}` |\r\n";
        $manualContent .= "| `GREATER_THAN` | Finds records where the numeric/date field is greater than the value. | `{field: \"price\", value: \"100\", operator: GREATER_THAN}` |\r\n";
        $manualContent .= "| `LESS_THAN_OR_EQUALS`    | Finds records where the numeric/date field is less than or equal to the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN_OR_EQUALS}`   |\r\n";
        $manualContent .= "| `LESS_THAN`    | Finds records where the numeric/date field is less than the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN}`   |\r\n";
        $manualContent .= "| `IN` / `NOT_IN` | Finds records where the field value is in (or not in) a comma-separated list of values. | `{field: \"category_id\", value: \"1,2,3\", operator: IN}` |\r\n\r\n";

        // Sorting
        $manualContent .= "### Sorting (`orderBy`)\r\n\r\n";
        $manualContent .= "The `orderBy` argument sorts the results. It accepts a list of sort objects.\r\n\r\n";
        $manualContent .= "- `field`: The name of the field to sort by (e.g., `\"name\"`).\r\n";
        $manualContent .= "- `direction`: The sort direction. Can be `ASC` (ascending) or `DESC` (descending). Defaults to `ASC`.\r\n\r\n";
        $manualContent .= "**Example:** `orderBy: [{field: \"release_date\", direction: DESC}]`\r\n\r\n";

        // Pagination
        $manualContent .= "### Pagination (`limit` & `offset`)\r\n\r\n";
        $manualContent .= "- `limit`: Specifies the maximum number of records to return.\r\n";
        $manualContent .= "- `offset`: Specifies the number of records to skip from the beginning.\r\n\r\n";
        $manualContent .= "**Example:** To get the second page of 10 items: `limit: 10, offset: 10`\r\n\r\n";

        return $manualContent;
    }
    
    /**
     * Generates the content for the composer.json file.
     * This includes the necessary dependencies for running the GraphQL API.
     *
     * @return string The XML formatted content for pom.xml.
     */
    public function generatePomXml()
    {
        $config = $this->projectConfig;
        return <<<XML
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>{$config['groupId']}</groupId>
	<artifactId>{$config['artifactId']}</artifactId>
	<version>{$config['version']}</version>
	<name>{$config['name']}</name>
	<description>{$config['description']}</description>
	<properties>
		<java.version>{$config['javaVersion']}</java.version>
        <!-- Explicitly set the main class to avoid ambiguity -->
        <start-class>{$config['packageName']}.{$this->pascalCase($config['artifactId'])}Application</start-class>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-graphql</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webflux</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.graphql</groupId>
			<artifactId>spring-graphql-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
XML;
    }

    /**
     * Main function to generate all files for the Spring Boot project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = [];
        $this->projectConfig['basePackagePath'] = 'src/main/java/' . str_replace('.', '/', $this->projectConfig['packageName']);
        $packagePath = 'src/main/java/' . str_replace('.', '/', $this->projectConfig['packageName']);

        // 1. pom.xml
        $files[] = ['name' => 'pom.xml', 'content' => $this->generatePomXml()];

        // 3. Main Application Class
        $files[] = ['name' => $packagePath . '/' . $this->pascalCase($this->projectConfig['artifactId']) . 'Application.java', 'content' => $this->generateMainAppClass()];

        // 4. GraphQL Schema, Entities, Repositories, DTOs, Controllers
        $allSchemaParts = [];
        $allQueryFields = [];
        $allMutationFields = [];

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            // Generate individual Java files
            $files[] = ['name' => $packagePath . '/model/entity/' . ucfirst($this->camelCase($tableName)) . '.java', 'content' => $this->generateEntityClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/repository/' . ucfirst($this->camelCase($tableName)) . 'Repository.java', 'content' => $this->generateRepositoryInterface($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/dto/' . ucfirst($this->camelCase($tableName)) . 'Input.java', 'content' => $this->generateDtoClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/controller/' . ucfirst($this->camelCase($tableName)) . 'Controller.java', 'content' => $this->generateControllerClass($tableName, $tableInfo)];

            // Collect schema parts to be merged later
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];
        }
        
        // 5. Specification and Filter classes
        $files[] = ['name' => $packagePath . '/util/SpecificationBuilder.java', 'content' => $this->generateSpecificationBuilder()];
        $files[] = ['name' => $packagePath . '/util/FilterCriteria.java', 'content' => $this->generateFilterCriteria()];
        $files[] = ['name' => $packagePath . '/util/SearchOperation.java', 'content' => $this->generateSearchOperation()];
        $files[] = ['name' => $packagePath . '/util/GenericSpecification.java', 'content' => $this->generateGenericSpecification()];

        // 5.1. DTOs for GraphQL inputs
        $files[] = ['name' => $packagePath . '/model/dto/FilterInput.java', 'content' => $this->generateFilterInputDto()];
        $files[] = ['name' => $packagePath . '/model/dto/SortInput.java', 'content' => $this->generateSortInputDto()];
        
        $files[] = ['name' => 'src/main/resources/frontend-config.json', 'content' => $this->generateFrontendConfigJson()];

        // 5.1. Generate the single, combined GraphQL schema file
        $files[] = ['name' => 'src/main/resources/graphql/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        // 6. Security and Auth files
        $files[] = ['name' => $packagePath . '/config/SecurityConfig.java', 'content' => $this->generateSecurityConfig()];
        $files[] = ['name' => $packagePath . '/config/CorsConfig.java', 'content' => $this->generateCorsConfig()];
        $files[] = ['name' => $packagePath . '/config/SessionAuthFilter.java', 'content' => $this->generateSessionAuthFilter()];
        $files[] = ['name' => $packagePath . '/config/Sha1PasswordEncoder.java', 'content' => $this->generateSha1PasswordEncoder()];
        $files[] = ['name' => $packagePath . '/service/JpaUserDetailsService.java', 'content' => $this->generateUserDetailsService()];
        $files[] = ['name' => $packagePath . '/model/entity/Admin.java', 'content' => $this->generateAdminEntity()];
        $files[] = ['name' => $packagePath . '/model/repository/AdminRepository.java', 'content' => $this->generateAdminRepository()];

        // 7. Auth and App Controllers
        $files[] = ['name' => $packagePath . '/controller/dto/LoginRequest.java', 'content' => $this->generateLoginRequestDto()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginResponse.java', 'content' => $this->generateLoginResponseDto()];
        $files[] = ['name' => $packagePath . '/controller/AuthController.java', 'content' => $this->generateAuthController()];
        $files[] = ['name' => $packagePath . '/controller/AppController.java', 'content' => $this->generateAppController()];
        $files[] = ['name' => $packagePath . '/config/ObjectScalar.java', 'content' => $this->generateObjectScalar()];
        $files[] = ['name' => $packagePath . '/config/GraphQlConfig.java', 'content' => $this->generateGraphQlConfig()];
        $files[] = ['name' => $packagePath . '/controller/dto/ProfileUpdateRequest.java', 'content' => $this->generateProfileUpdateRequestDto()];

        return $files;
    }

    /**
     * Generates the application.properties file.
     * @return string The content of application.properties.
     */
    public function generateApplicationProperties() {
        $requireLoginValue = $this->requireLogin ? 'true' : 'false';
        return <<<PROPERTIES
spring.application.name={$this->projectConfig['name']}

# Database Configuration (Please update with your details)
app.security.require-login=$requireLoginValue

# Session Management
spring.session.store-type=none # Default to none, uncomment below to use Redis
# spring.session.store-type=redis
# spring.data.redis.host=localhost
# spring.data.redis.port=6379
# spring.session.timeout=30m

# CORS Configuration (Cross-Origin Resource Sharing)
app.security.cors.enabled=true
app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

spring.datasource.url={DB_URL}
spring.datasource.username={DB_USER}
spring.datasource.password={DB_PASS}
spring.datasource.driver-class-name={DB_DRIVER_CLASS}

# JPA/Hibernate Configuration
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect={DB_DIALECT}

# Use database column names directly without converting to camelCase
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# GraphQL Configuration
spring.graphql.graphiql.enabled=true
spring.graphql.schema.locations=classpath:graphql/
spring.graphql.schema.file-extensions=.graphqls

# Caching (optional)
# spring.cache.type=caffeine
PROPERTIES;
    }

    /**
     * Generates the main Spring Boot application class.
     *
     * @return string The content of the main application class.
     */
    private function generateMainAppClass() {
        $className = $this->pascalCase($this->projectConfig['artifactId']) . 'Application';
        $content = "package {$this->projectConfig['packageName']};\n\n";
        $content .= "import org.springframework.boot.autoconfigure.EnableAutoConfiguration;\n";
        $content .= "import org.springframework.boot.SpringApplication;\n";
        $content .= "import org.springframework.boot.autoconfigure.SpringBootApplication;\n";
        $content .= "import org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration;\n";
        $content .= "import org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration;\n";
        if ($this->useCache) {
            $content .= "import org.springframework.cache.annotation.EnableCaching;\n";
        }
        $content .= "\n";
        if ($this->useCache) {
            $content .= "@EnableCaching\n";
        }
        $content .= "@SpringBootApplication\n";
        $content .= "@EnableAutoConfiguration(exclude = {RedisAutoConfiguration.class, RedisRepositoriesAutoConfiguration.class})\n";
        $content .= "public class $className {\n\n";
        $content .= "    public static void main(String[] args) {\n";
        $content .= "        SpringApplication.run($className.class, args);\n";
        $content .= "    }\n\n";
        $content .= "}\n";
        return $content;
    }

    /**
     * Generates the Java entity class for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the entity class.
     */
    private function generateEntityClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $className = ucfirst($camelName);
        $package = $this->projectConfig['packageName'];
        
        $imports = "import jakarta.persistence.*;\nimport lombok.Data;\nimport java.io.Serializable;\n";
        $fields = "";
        $hasLdt = false;
        $hasLd = false;
        $hasManyToOne = false;
        
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $javaType = $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);
            
            if (strpos($javaType, 'LocalDateTime') !== false) $hasLdt = true;
            if (strpos($javaType, 'LocalDate') !== false) $hasLd = true;
            
            if ($colInfo['isPrimaryKey']) {
                $fields .= "    @Id\n";
                if ($colInfo['isAutoIncrement']) {
                    $fields .= "    @GeneratedValue(strategy = GenerationType.IDENTITY)\n";
                }
                if ($fieldName !== $colName) {
                    $fields .= "    @Column(name = \"$colName\")\n";
                }
            } else if ($colInfo['isForeignKey']) {
                $hasManyToOne = true;
                $refTableName = $colInfo['references'];
                $refClassName = ucfirst($this->camelCase($refTableName));
                $refFieldName = $this->camelCase($refTableName);

                // Add the foreign key column field
                $fields .= "    @Column(name = \"$colName\")\n";
                $fields .= "    private " . basename(str_replace('\\', '/', $javaType)) . " $fieldName;\n\n";
                
                // Add the object relationship
                $fields .= "    @ManyToOne(fetch = FetchType.LAZY)\n";
                $fields .= "    @JoinColumn(name = \"$colName\", insertable = false, updatable = false)\n";
                $fields .= "    private $refClassName $refFieldName;\n\n";
                continue; // Skip the separate ID field generation for foreign keys
            } else if ($fieldName !== $colName) {
                $fields .= "    @Column(name = \"$colName\")\n";
            }
            // No need for @Column(name=...) if physical strategy is used and field name matches
            $fields .= "    private " . basename(str_replace('\\', '/', $javaType)) . " $fieldName;\n\n";
        }

        if ($hasLdt) $imports .= "import java.time.LocalDateTime;\n";
        if ($hasLd) $imports .= "import java.time.LocalDate;\n";
        if ($hasManyToOne) $imports .= "import com.fasterxml.jackson.annotation.JsonIgnore;\n";

        return <<<JAVA
package $package.model.entity;

$imports
@Data
@Entity
@Table(name = "$tableName")
public class $className implements Serializable {

$fields}
JAVA;
    }

    /**
     * Generates the Java interface for a given table's repository.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the repository interface.
     */
    private function generateRepositoryInterface($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $className = ucfirst($camelName);
        $package = $this->projectConfig['packageName'];
        $pkJavaType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkJavaType = $this->mapDbTypeToJavaType($col['type'], $col['length']);
                break;
            }
        }

        $imports = "import org.springframework.data.jpa.repository.JpaRepository;\n";
        $imports .= "import org.springframework.data.jpa.repository.JpaSpecificationExecutor;\n";
        $imports .= "import $package.model.entity.$className;\n";
        $imports .= "import org.springframework.data.jpa.repository.EntityGraph;\n";
        if ($this->useCache) {
            $imports .= "import org.springframework.cache.annotation.Cacheable;\n";
        }
        $imports .= "import java.util.Optional;\n";
        $entityGraphAnnotation = $this->buildEntityGraphAnnotation($tableName);
        $findByIdMethod = "Optional<$className> findById($pkJavaType id);";
        if ($this->useCache) {
            $findByIdMethod = "@Cacheable(value = \"$camelName\", key = \"#id\")\n    " . $findByIdMethod;
        }
        if(!empty($entityGraphAnnotation)) {
            $findByIdMethod = $entityGraphAnnotation . "    " . $findByIdMethod;
        }


        return <<<JAVA
package $package.model.repository;

$imports
import org.springframework.stereotype.Repository;

@Repository
public interface {$className}Repository extends JpaRepository<$className, $pkJavaType>, JpaSpecificationExecutor<$className> {
$findByIdMethod
}
JAVA;
    }

    /**
     * Builds the @EntityGraph annotation string by recursively finding all nested relationships.
     *
     * @param string $tableName The starting table name.
     * @return string The generated @EntityGraph annotation string.
     */
    private function buildEntityGraphAnnotation($tableName)
    {
        $allPaths = $this->getNestedAttributePaths($tableName);
        if (empty($allPaths)) {
            return "";
        }

        $quotedPaths = array_map(function($path) {
            return '"' . $path . '"';
        }, $allPaths);

        return "    @EntityGraph(attributePaths = {" . implode(', ', $quotedPaths) . "})\n";
    }

    /**
     * Recursively traverses entity relationships to build a list of nested attribute paths for @EntityGraph.
     *
     * @param string $tableName The current table to analyze.
     * @param string $currentPath The path prefix built so far (e.g., "subKlasifikasi.").
     * @param array $visited An array to prevent infinite loops in circular dependencies.
     * @return array A flat list of all nested attribute paths.
     */
    private function getNestedAttributePaths($tableName, $currentPath = '', &$visited = [])
    {
        if (isset($visited[$tableName])) {
            return []; // Avoid infinite recursion on circular dependencies
        }
        $visited[$tableName] = true;

        $paths = [];
        $tableInfo = $this->analyzedSchema[$tableName];

        foreach ($tableInfo['columns'] as $colInfo) {
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $attributeName = $this->camelCase($refTableName);
                $fullPath = $currentPath . $attributeName;
                $paths[] = $fullPath;

                // Recursively find paths from the referenced table
                $nestedPaths = $this->getNestedAttributePaths($refTableName, $fullPath . '.', $visited);
                $paths = array_merge($paths, $nestedPaths);
            }
        }

        // Backtrack for the current path
        unset($visited[$tableName]);

        return $paths;
    }

    /**
     * Generates the DTO class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the DTO class.
     */
    private function generateDtoClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $className = ucfirst($camelName) . "Input";
        $package = $this->projectConfig['packageName'];

        $imports = "import com.fasterxml.jackson.annotation.JsonProperty;\nimport lombok.Data;\n";
        $fields = "";
        $hasLdt = false;
        $hasLd = false;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            
            if ($colInfo['isForeignKey']) {
                $javaType = $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']);
            }
            else {
                $javaType = $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']);
            }
            $fieldName = $this->camelCase($colName);

            if (strpos($javaType, 'LocalDateTime') !== false) $hasLdt = true;
            if (strpos($javaType, 'LocalDate') !== false) $hasLd = true;

            if ($fieldName !== $colName) {
                $fields .= "    @JsonProperty(\"$colName\")\n";
            }
            $fields .= "    private " . basename(str_replace('\\', '/', $javaType)) . " $fieldName;\n\n";
        }

        if ($hasLdt) $imports .= "import java.time.LocalDateTime;\n";
        if ($hasLd) $imports .= "import java.time.LocalDate;\n";

        return <<<JAVA
package $package.model.dto;

$imports
@Data
public class $className {
$fields}
JAVA;
    }

    /**
     * Generates the Controller class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the Controller class.
     */
    private function generateControllerClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);
        $package = $this->projectConfig['packageName'];
        $schemaMappings = "";
        $pkJavaType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkJavaType = $this->mapDbTypeToJavaType($col['type'], $col['length']);
                break;
            }
        }

        $relatedEntityImports = "";
        foreach ($tableInfo['columns'] as $colInfo) {
            if ($colInfo['isForeignKey']) {
                $refClassName = ucfirst($this->camelCase($colInfo['references']));
                $relatedEntityImports .= "import $package.model.entity.$refClassName;\n";
            }
        }

        $code = <<<JAVA
package $package.controller;

import $package.model.dto.FilterInput;
import $package.model.dto.SortInput;
import $package.model.dto.{$ucCamelName}Input;{$relatedEntityImports}
import $package.model.entity.$ucCamelName;
import $package.model.repository.{$ucCamelName}Repository;
import $package.util.SearchOperation;
import $package.util.SpecificationBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.SchemaMapping;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.List;
import java.util.Map;
import java.util.UUID;

@Controller
public class {$ucCamelName}Controller {

    @Autowired
    private {$ucCamelName}Repository {$camelName}Repository;

    @QueryMapping
    public $ucCamelName {$camelName}(@Argument $pkJavaType id) {
        return {$camelName}Repository.findById(id).orElse(null);
    }

    @QueryMapping
    public Map<String, Object> {$pluralCamelName}(
            @Argument Integer limit,
            @Argument Integer offset,
            @Argument Integer page,
            @Argument Integer size,
            @Argument List<SortInput> orderBy,
            @Argument List<FilterInput> filter) {

        int pageSize = (limit != null) ? limit : (size != null ? size : 20);
        int pageNum = 0;
        if (offset != null && pageSize > 0) {
            pageNum = offset / pageSize;
        } else if (page != null) {
            pageNum = page > 0 ? page - 1 : 0; // Convert 1-based page to 0-based
        }

        Sort sort = Sort.unsorted();
        if (orderBy != null && !orderBy.isEmpty()) {
            List<Sort.Order> orders = orderBy.stream()
                    .map(order -> new Sort.Order(Sort.Direction.fromString(order.getDirection()), order.getField()))
                    .toList();
            sort = Sort.by(orders);
        }

        Pageable pageable = PageRequest.of(pageNum, pageSize, sort);

        SpecificationBuilder<$ucCamelName> builder = new SpecificationBuilder<>();
        if (filter != null) {
            for (FilterInput f : filter) {
                String operator = (f.getOperator() == null || f.getOperator().isEmpty()) 
                                  ? "EQUALS" 
                                  : f.getOperator().toUpperCase();
                builder.with(f.getField(), SearchOperation.valueOf(operator), f.getValue());
            }
        }

        Page<$ucCamelName> resultPage = {$camelName}Repository.findAll(builder.build(), pageable);

        return Map.of(
            "items", resultPage.getContent(),
            "total", resultPage.getTotalElements(),
            "limit", resultPage.getSize(),
            "page", resultPage.getNumber() + 1, // Frontend pages are usually 1-based
            "totalPages", resultPage.getTotalPages(),
            "hasNext", resultPage.hasNext(),
            "hasPrevious", resultPage.hasPrevious()
        );
    }

    @MutationMapping
    public $ucCamelName create{$ucCamelName}(@Argument {$ucCamelName}Input input) {
        $ucCamelName {$camelName} = new $ucCamelName();
        // Manual mapping from DTO to Entity. Consider using a library like MapStruct.
{$this->generateDtoToEntityMapping($tableName, $tableInfo, $camelName, 'input')}
        return {$camelName}Repository.save({$camelName});
    }

    @MutationMapping
    public $ucCamelName update{$ucCamelName}(@Argument $pkJavaType id, @Argument {$ucCamelName}Input input) {
        $ucCamelName {$camelName} = {$camelName}Repository.findById(id)
            .orElseThrow(() -> new RuntimeException("{$ucCamelName} not found with id " + id));
        // Manual mapping from DTO to Entity. Consider using a library like MapStruct.
{$this->generateDtoToEntityMapping($tableName, $tableInfo, $camelName, 'input')}
        return {$camelName}Repository.save({$camelName});
    }

    // Field resolvers for relationships and snake_case to camelCase mapping
{$this->generateFieldResolvers($tableName, $tableInfo)}

    @MutationMapping
    public boolean delete{$ucCamelName}(@Argument $pkJavaType id) {
        {$camelName}Repository.deleteById(id);
        return true;
    }
}
JAVA;
        
        $code = str_replace("}\n}", "}", $code);
        
        // Inject field resolvers before the final closing brace
        $fieldResolvers = $this->generateFieldResolvers($tableName, $tableInfo);
        $lastBracePos = strrpos($code, '}');
        if ($lastBracePos !== false) {
            $code = substr_replace($code, $fieldResolvers . "\n}", $lastBracePos, 1);
        }

        $code .= <<<JAVA
}
JAVA;
        return $code;
    }

    /**
     * Generates field resolvers for foreign key relationships and camelCase to snake_case mapping.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return string The generated field resolver methods.
     */
    private function generateFieldResolvers($tableName, $tableInfo) {
        $resolvers = "";
        $ucCamelTableName = ucfirst($this->camelCase($tableName));
        $camelTableName = $this->camelCase($tableName);
    
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $camelColName = $this->camelCase($colName);
            $ucCamelColName = ucfirst($camelColName);
    
            // Resolver for snake_case field to camelCase getter
            if ($colName !== $camelColName) {
                $javaType = $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']);
                $baseJavaType = basename(str_replace('\\', '/', $javaType));
                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$colName\")\n";
                $resolvers .= "    public $baseJavaType get".PicoStringUtil::upperCamelize($colName)."($ucCamelTableName $camelTableName) {\n";
                $resolvers .= "        return {$camelTableName}.get{$ucCamelColName}();\n";
                $resolvers .= "    }\n";
            }
    
            // Resolver for relationship objects
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refCamelName = $this->camelCase($refTableName);
                $refUcCamelName = ucfirst($refCamelName);

                // Resolver for the related object itself
                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$refTableName\")\n";
                $resolvers .= "    public $refUcCamelName get".ucfirst($refCamelName)."($ucCamelTableName $camelTableName) {\n";
                $resolvers .= "        return {$camelTableName}.get".ucfirst($refCamelName)."();\n";
                $resolvers .= "    }\n";
            }
        }
    
        return $resolvers;
    }

    /**
     * Maps Java types to GraphQL types.
     *
     * @param string $javaType The Java type.
     * @return string The corresponding GraphQL type.
     */
    private function mapJavaTypeToGqlType($javaType) {
        $baseType = basename(str_replace('\\', '/', $javaType));
        switch ($baseType) {
            case 'Integer':
                return 'Int';
            case 'Double':
            case 'Float':
                return 'Float';
            case 'Boolean':
                return 'Boolean';
            case 'String':
            case 'LocalDate':
            case 'LocalDateTime':
                return 'String'; // Or custom scalars
            default:
                return 'String';
        }
    }
    
    /**
     * Get project configuration.
     */
    public function getProjectConfig()
    {
        return $this->projectConfig;
    }

    /**
     * Generates the SpecificationBuilder class for dynamic filtering.
     *
     * @return string The Java code for SpecificationBuilder.java.
     */
    private function generateSpecificationBuilder() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

import org.springframework.data.jpa.domain.Specification;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class SpecificationBuilder<T> {

    private final List<FilterCriteria> params;

    public SpecificationBuilder() {
        params = new ArrayList<>();
    }

    public SpecificationBuilder<T> with(String key, SearchOperation operation, Object value) {
        params.add(new FilterCriteria(key, operation, value));
        return this;
    }

    public Specification<T> build() {
        if (params.isEmpty()) {
            return null;
        }

        List<Specification<T>> specs = params.stream()
                .map(GenericSpecification<T>::new)
                .collect(Collectors.toList());

        Specification<T> result = specs.get(0);

        for (int i = 1; i < params.size(); i++) {
            result = Specification.where(result).and(specs.get(i));
        }
        return result;
    }
}
JAVA;
    }

    /**
     * Generates the FilterCriteria class for filtering specifications.
     *
     * @return string The Java code for FilterCriteria.java.
     */
    private function generateFilterCriteria() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class FilterCriteria {
    private String key;
    private SearchOperation operation;
    private Object value;
}
JAVA;
    }

    /**
     * Generates the SearchOperation enum for filtering specifications.
     *
     * @return string The Java code for SearchOperation.java.
     */
    private function generateSearchOperation() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

public enum SearchOperation {
    EQUALS,
    NOT_EQUALS,
    CONTAINS,
    GREATER_THAN,
    GREATER_THAN_OR_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUALS,
    IN,
    NOT_IN;
}
JAVA;
    }

    /**
     * Generates the GenericSpecification class for dynamic filtering.
     *
     * @return string The Java code for GenericSpecification.java.
     */
    private function generateGenericSpecification() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import org.springframework.data.jpa.domain.Specification;

@SuppressWarnings("serial")
public class GenericSpecification<T> implements Specification<T> {

    private final FilterCriteria criteria;

    public GenericSpecification(FilterCriteria criteria) {
        this.criteria = criteria;
    }

    @Override
    public Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        String key = criteria.getKey();
        Object value = criteria.getValue();

        // Get the expected Java type for the field from the JPA entity metadata
        Class<?> fieldType = root.get(key).getJavaType();
        Object typedValue = value;

        // Convert the incoming value (which can be String, BigDecimal, Boolean, etc.) to the correct type
        if (value != null) {
            String stringValue = value.toString();
            if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
                typedValue = Integer.parseInt(stringValue);
            } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
                typedValue = Long.parseLong(stringValue);
            } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
                typedValue = Double.parseDouble(stringValue);
            } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
                typedValue = Float.parseFloat(stringValue);
            } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
                typedValue = Boolean.parseBoolean(stringValue);
            } else if (fieldType.equals(String.class)) {
                typedValue = stringValue;
            } else if (fieldType.isEnum()) {
                typedValue = Enum.valueOf((Class<Enum>) fieldType, stringValue);
            }
            // Note: java.time types might need specific parsing if required
        }

        switch (criteria.getOperation()) {
            case EQUALS:
                return builder.equal(root.get(key), typedValue);
            case NOT_EQUALS:
                return builder.notEqual(root.get(key), typedValue);
            case GREATER_THAN:
                return builder.greaterThan(root.get(key), typedValue.toString());
            case GREATER_THAN_OR_EQUALS:
                return builder.greaterThanOrEqualTo(root.get(key), typedValue.toString());
            case LESS_THAN:
                return builder.lessThan(root.get(key), typedValue.toString());
            case LESS_THAN_OR_EQUALS:
                return builder.lessThanOrEqualTo(root.get(key), typedValue.toString());
            case CONTAINS:
                if (root.get(key).getJavaType() == String.class) {
                    return builder.like(root.get(key), "%" + typedValue + "%");
                } else {
                    return builder.equal(root.get(key), typedValue);
                }
            case IN:
                return root.get(key).in((Object[]) typedValue);
            case NOT_IN:
                return builder.not(root.get(key).in((Object[]) typedValue));
            default:
                return null;
        }
    }
}
JAVA;
    }

    /**
     * Generates the SecurityConfig class for application security.
     *
     * @return string The Java code for SecurityConfig.java.
     */
    private function generateSecurityConfig() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package {$package}.config;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.HttpStatusEntryPoint;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import {$package}.service.JpaUserDetailsService;
import org.springframework.security.config.http.SessionCreationPolicy;
import {$package}.model.repository.AdminRepository;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.context.annotation.Bean;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JpaUserDetailsService userDetailsService;
    private final AdminRepository adminRepository;

    @Value("\${app.security.require-login:true}")
    private boolean requireLogin;

    public SecurityConfig(JpaUserDetailsService userDetailsService, AdminRepository adminRepository) {
        this.userDetailsService = userDetailsService;
        this.adminRepository = adminRepository;
    }

    @Bean
    public Sha1PasswordEncoder passwordEncoder() 
    {
        return new Sha1PasswordEncoder();
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(AbstractHttpConfigurer::disable);
        
        // Disable default logout handling in all cases, as we will manage it in AuthController
        http.logout(logout -> logout.disable());

        if (!requireLogin) {
            // If login is not required, permit all requests.
            http
                .authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        } else {
            // If login is required, set up session-based security with our custom filter.
            SessionAuthFilter sessionAuthFilter = new SessionAuthFilter(adminRepository);
            http.addFilterBefore(sessionAuthFilter, UsernamePasswordAuthenticationFilter.class);

            AuthenticationEntryPoint apiEntryPoint = new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED);

            http            
                .authorizeHttpRequests(auth -> auth
                    .requestMatchers(
                        "/login", 
                        "/logout", 
                        "/",
                        "/index.html",
                        "/assets/**",
                        "/favicon.ico"
                    ).permitAll()
                    .requestMatchers(
                        "/graphiql/**", 
                        "/vendor/**"
                        ).permitAll() // Allow GraphiQL UI
                    .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService)
                .exceptionHandling(e -> e
                    // For API paths, return 401. For others, redirect to login.
                    .defaultAuthenticationEntryPointFor(
                        apiEntryPoint, new AntPathRequestMatcher("/graphql/**")
                    )
                );
        }

        return http.build();
    }
}

@Configuration
@ConditionalOnProperty(name = "spring.session.store-type", havingValue = "redis")
@EnableRedisHttpSession
class RedisSessionConfig {
    // This class is intentionally empty.
    // Its purpose is to conditionally enable Redis session management
    // based on the application properties.
}
JAVA;
    }

    /**
     * Generates the CorsConfig class for CORS configuration.
     *
     * @return string The Java code for CorsConfig.java.
     */
    private function generateCorsConfig() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package {$package}.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig {

    @Value("\${app.security.cors.allowed-origins:}")
    private String[] allowedOrigins;

    @Bean
    @ConditionalOnProperty(name = "app.security.cors.enabled", havingValue = "true")
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**") // Apply to all endpoints
                        .allowedOrigins(allowedOrigins)
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        };
    }
}
JAVA;
    }
    
    /**
     * Generates the SessionAuthFilter class for session-based authentication.
     *
     * @return string The Java code for SessionAuthFilter.java.
     */
    private function generateSessionAuthFilter() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package {$package}.config;

import {$package}.model.entity.Admin;
import org.springframework.beans.factory.annotation.Value;
import {$package}.model.repository.AdminRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import org.springframework.stereotype.Component;
import java.io.IOException;
import java.util.Collections;

public class SessionAuthFilter extends OncePerRequestFilter {

    private final AdminRepository adminRepository;

    public SessionAuthFilter(AdminRepository adminRepository) {
        this.adminRepository = adminRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        HttpSession session = request.getSession(false);

        if (session != null && session.getAttribute("username") != null && session.getAttribute("password") != null) {
            String username = (String) session.getAttribute("username");
            String sessionPasswordHash = (String) session.getAttribute("password"); // This is sha1(password)

            // Only proceed if there is no existing authentication
            if (SecurityContextHolder.getContext().getAuthentication() == null) {
                adminRepository.findByUsername(username).ifPresent(admin -> {
                    // Re-create the single hash of the password from the database's double hash
                    // This logic is complex. A simpler way is to just trust the session hash.
                    // For this implementation, we'll validate the session hash against the user from DB.
                    
                    Sha1PasswordEncoder encoder = new Sha1PasswordEncoder();
                    String expectedSingleHash = encoder.sha1(encoder.sha1(admin.getPassword())); // This is incorrect, let's simplify

                    // We need to re-validate the session password.
                    // The password in DB is sha1(sha1(plain_password))
                    // The password in Session is sha1(plain_password)
                    // So, we hash the session password again and compare with DB password.
                    if (encoder.sha1(sessionPasswordHash).equals(admin.getPassword())) {
                        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                                username, null, Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));
                        SecurityContextHolder.getContext().setAuthentication(authToken);
                    }
                });
            }
        }
        filterChain.doFilter(request, response);
    }
}
JAVA;
    }

    /**
     * Generates the Sha1PasswordEncoder class for password encoding.
     *
     * @return string The Java code for Sha1PasswordEncoder.java.
     */
    private function generateSha1PasswordEncoder() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.config;

import org.springframework.security.crypto.password.PasswordEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.math.BigInteger;

public class Sha1PasswordEncoder implements PasswordEncoder {

    @Override
    public String encode(CharSequence rawPassword) {
        // This replicates sha1(sha1(password))
        return sha1(sha1(rawPassword.toString()));
    }

    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        // The rawPassword is the plain text from the login form.
        // The encodedPassword is the double-hashed password from the database.
        // We must double-hash the raw password to match what's in the database.
        return encodedPassword.equals(encode(rawPassword));
    }

    public String sha1(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            byte[] messageDigest = md.digest(input.getBytes());
            BigInteger no = new BigInteger(1, messageDigest);
            String hashtext = no.toString(16);
            while (hashtext.length() < 40) { // SHA-1 is 40 chars long
                hashtext = "0" + hashtext;
            }
            return hashtext;
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
JAVA;
    }

    /**
     * Generates the JpaUserDetailsService class for loading user details.
     *
     * @return string The Java code for JpaUserDetailsService.java.
     */
    private function generateUserDetailsService() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.service;

import $package.model.repository.AdminRepository;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class JpaUserDetailsService implements UserDetailsService {

    private final AdminRepository adminRepository;

    public JpaUserDetailsService(AdminRepository adminRepository) {
        this.adminRepository = adminRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return adminRepository.findByUsername(username)
                .map(admin -> {
                    // The password stored in the database is sha1(sha1(password)).
                    // Spring Security's session authentication will compare against the session's password, which is sha1(password).
                    // Therefore, we must provide the double-hashed password here for the initial login check to succeed.
                    return User.withUsername(admin.getUsername()).password(admin.getPassword()).roles("USER").build();
                })
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
    }
}
JAVA;
    }

    /**
     * Generates the Admin entity class.
     *
     * @return string The Java code for Admin.java.
     */
    private function generateAdminEntity() {
        $package = $this->projectConfig['packageName'];
        // A simplified Admin entity based on auth.php and login.php logic
        return <<<JAVA
package $package.model.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Entity
@Table(name = "admin")
public class Admin {
    @Id
    @Column(name = "admin_id")
    private String adminId;
    private String username;
    private String password;
    private String name;
    private String email;
    private String phone;
    @Column(name = "admin_level_id")
    private String adminLevelId;
}
JAVA;
    }

    /**
     * Generates the AdminRepository interface.
     *
     * @return string The Java code for AdminRepository.java.
     */
    private function generateAdminRepository() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.model.repository;

import $package.model.entity.Admin;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface AdminRepository extends JpaRepository<Admin, String> {
    Optional<Admin> findByUsername(String username);
}
JAVA;
    }

    /**
     * Generates the LoginRequest class.
     *
     * @return string The Java code for LoginRequest.java.
     */
    private function generateLoginRequestDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller.dto;
import lombok.Data;
@Data
public class LoginRequest {
    private String username;
    private String password;
}
JAVA;
    }

    /**
     * Generates the LoginResponse class.
     *
     * @return string The Java code for LoginResponse.java.
     */
    private function generateLoginResponseDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller.dto;
import lombok.AllArgsConstructor;
import lombok.Data;
@Data
@AllArgsConstructor
public class LoginResponse {
    private boolean success;
    private String message;
}
JAVA;
    }

    /**
     * Generates the AuthController class for handling authentication.
     *
     * @return string The Java code for AuthController.java.
     */
    private function generateAuthController() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller;

import $package.config.Sha1PasswordEncoder;
import $package.controller.dto.LoginRequest;
import $package.controller.dto.LoginResponse;
import $package.model.repository.AdminRepository;
import jakarta.servlet.http.HttpSession;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AuthController {

    @Value("\${app.security.require-login:true}")
    private boolean requireLogin;

    private final AdminRepository adminRepository;
    private final Sha1PasswordEncoder passwordEncoder;

    public AuthController(AdminRepository adminRepository, Sha1PasswordEncoder passwordEncoder) {
        this.adminRepository = adminRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestParam String username, @RequestParam String password, HttpSession session) {
        if (!requireLogin) {
            return ResponseEntity.ok(new LoginResponse(true, "Success"));
        }
        String singleHashedPassword = passwordEncoder.sha1(password);
        return adminRepository.findByUsername(username)
                .filter(admin -> admin.getPassword().equals(passwordEncoder.encode(password)))
                .map(admin -> {
                    session.setAttribute("username", admin.getUsername());
                    // Store the single-hashed password in the session for subsequent requests.
                    session.setAttribute("password", singleHashedPassword);
                    return ResponseEntity.ok(new LoginResponse(true, "Login successful"));
                })
                .orElse(ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body(new LoginResponse(false, "Invalid credentials")));
    }

    @RequestMapping(value = "/logout", method = {RequestMethod.GET, RequestMethod.POST})
    public ResponseEntity<LoginResponse> logout(HttpServletRequest request) {
        if (!requireLogin) {
            return ResponseEntity.ok(new LoginResponse(true, "Success"));
        }
        HttpSession session = request.getSession(false); // Get session only if it exists, don't create a new one
        if (session != null) {
            session.invalidate();
        }
        return ResponseEntity.ok(new LoginResponse(true, "Logout successful"));
    }
}
JAVA;
    }

    /**
     * Generates the AppController class for various utility endpoints.
     *
     * @return string The Java code for AppController.java.
     */
    private function generateAppController() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Map;

@RestController
public class AppController {

    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;

    public AppController(ResourceLoader resourceLoader, ObjectMapper objectMapper) {
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
    }


    // Replicates available-language.php
    @GetMapping("/available-language")
    public Map<String, Object> getAvailableLanguages() {
        // This should ideally read from a file, but hardcoding for simplicity
        return Map.of(
            "default", "en",
            "supported", Map.of("en", "English", "id", "Indonesia")
        );
    }

    // Replicates available-theme.php
    @GetMapping("/available-theme")
    public Object[] getAvailableThemes() {
        // This should scan a directory, but hardcoding for simplicity
        return new Object[]{
            Map.of("name", "dark-blue", "title", "Dark Blue"),
            Map.of("name", "light-green", "title", "Light Green")
        };
    }

    // Replicates frontend-config.php
    @GetMapping(value = "/frontend-config", produces = "application/json")
    public Object getFrontendConfig() throws IOException {
        Resource resource = resourceLoader.getResource("classpath:frontend-config.json");
        String jsonContent = new String(Files.readAllBytes(Paths.get(resource.getURI())));
        return objectMapper.readValue(jsonContent, Object.class);
    }
    
    // Other endpoints like /user-profile, /settings etc. would go here
}
JAVA;
    }

    /**
     * Generates the ProfileUpdateRequest DTO class.
     *
     * @return string The Java code for ProfileUpdateRequest.java.
     */
    private function generateProfileUpdateRequestDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller.dto;

import lombok.Data;

@Data
public class ProfileUpdateRequest {
    private String name;
    private String email;
    private String gender;
    private String birthDay;
    private String phone;
}
JAVA;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information including columns and primary key.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original snake_case name
            if ($colInfo['isForeignKey']) {
                $refUcCamelName = ucfirst($this->camelCase($colInfo['references']));
                $fields .= "    $fieldName: $gqlType\n"; // Keep the ID field
                $fields .= "    {$colInfo['references']}: $refUcCamelName\n"; // Use original table name for relation
            } else {
                $fields .= "    $fieldName: $gqlType\n";
            }
        }

        // Input fields
        $inputFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $gqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original snake_case name
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $types = <<<GQL
type $ucCamelName {
$fields}

input {$ucCamelName}Input {
$inputFields}

type {$ucCamelName}Page {
    items: [$ucCamelName],
    total: Int,
    limit: Int,
    page: Int,
    totalPages: Int,
    hasNext: Boolean,
    hasPrevious: Boolean
}
GQL;

        $queries = "    {$camelName}(id: ID!): $ucCamelName\n";
        $queries .= "    {$pluralCamelName}(limit: Int, offset: Int, page: Int, size: Int, orderBy: [SortInput], filter: [FilterInput]): {$ucCamelName}Page\n";

        $mutations = "    create{$ucCamelName}(input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    update{$ucCamelName}(id: ID!, input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    delete{$ucCamelName}(id: ID!): Boolean\n";

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Generates the mapping code from a DTO to an Entity.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @param string $entityVar The variable name of the entity.
     * @param string $dtoVar The variable name of the DTO.
     * @return string The generated mapping code.
     */
    private function generateDtoToEntityMapping($tableName, $tableInfo, $entityVar, $dtoVar) {
        $mappingCode = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refCamelName = $this->camelCase($refTableName);
                $ucRefCamelName = ucfirst($refCamelName);
                $camelColName = $this->camelCase($colName);
                $ucCamelColName = ucfirst($camelColName);
                $mappingCode .= "        if (input.get{$ucCamelColName}() != null) {\n";
                $mappingCode .= "            {$this->projectConfig['packageName']}.model.entity.$ucRefCamelName {$refCamelName} = new {$this->projectConfig['packageName']}.model.entity.$ucRefCamelName();\n";
                $refTableInfo = $this->analyzedSchema[$refTableName];
                $refTablePrimaryKey = $refTableInfo['primaryKey'];
                $mappingCode .= "            {$refCamelName}.set".ucfirst($this->camelCase($refTablePrimaryKey))."(input.get{$ucCamelColName}());\n";
                $mappingCode .= "            {$entityVar}.set".ucfirst($refCamelName)."({$refCamelName});\n";
                $mappingCode .= "        }\n";
            } else {
                $camelColName = $this->camelCase($colName);
                $ucCamelColName = ucfirst($camelColName);
                $mappingCode .= "        {$entityVar}.set{$ucCamelColName}({$dtoVar}.get{$ucCamelColName}());\n";
            }
        }
        return $mappingCode;
    }


    /**
     * Combines all schema parts into a single GraphQL schema string.
     *
     * @param array $allSchemaParts Array of type definitions.
     * @param array $allQueryFields Array of query definitions.
     * @param array $allMutationFields Array of mutation definitions.
     * @return string The complete GraphQL schema.
     */
    private function generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields) {
        $typesString = implode("\n", $allSchemaParts);
        $queriesString = implode("", $allQueryFields);
        $mutationsString = implode("", $allMutationFields);

        return <<<GQL
enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Object
    operator: FilterOperator
}

$typesString

type Query {
$queriesString}

scalar Object

type Mutation {
$mutationsString}
GQL;
    }

    /**
     * Generates the FilterInput DTO class.
     * @return string The Java code for FilterInput.java.
     */
    private function generateFilterInputDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.model.dto;

import lombok.Data;

@Data
public class FilterInput {
    private String field;
    private Object value;
    private String operator;
}
JAVA;
    }

    /**
     * Generates the SortInput DTO class.
     * @return string The Java code for SortInput.java.
     */
    private function generateSortInputDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.model.dto;

import lombok.Data;

@Data
public class SortInput {
    private String field;
private String direction;

    public String getDirection() {
        return (direction == null || direction.isEmpty()) ? "ASC" : direction;
    }
}
JAVA;
    }

    /**
     * Generates the ObjectScalar class for GraphQL custom scalar type.
     *
     * @return string The Java code for ObjectScalar.java.
     */
    private function generateObjectScalar() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.config;

import graphql.language.ArrayValue;
import graphql.language.BooleanValue;
import graphql.language.FloatValue;
import graphql.language.IntValue;
import graphql.language.ObjectField;
import graphql.language.ObjectValue;
import graphql.language.StringValue;
import graphql.language.Value;
import graphql.schema.Coercing;
import graphql.schema.CoercingParseLiteralException;
import graphql.schema.CoercingParseValueException;
import graphql.schema.CoercingSerializeException;
import graphql.schema.GraphQLScalarType;
import java.util.stream.Collectors;

public class ObjectScalar implements Coercing<Object, Object> {

    public static final GraphQLScalarType INSTANCE = GraphQLScalarType.newScalar()
            .name("Object")
            .description("A custom scalar that can represent any JSON-like object.")
            .coercing(new ObjectScalar())
            .build();

    @Override
    public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {
        return dataFetcherResult;
    }

    @Override
    public Object parseValue(Object input) throws CoercingParseValueException {
        return input;
    }

    @Override
    public Object parseLiteral(Object input) throws CoercingParseLiteralException {
        if (input instanceof StringValue) {
            return ((StringValue) input).getValue();
        } else if (input instanceof IntValue) {
            return ((IntValue) input).getValue();
        } else if (input instanceof FloatValue) {
            return ((FloatValue) input).getValue();
        } else if (input instanceof BooleanValue) {
            return ((BooleanValue) input).isValue();
        } else if (input instanceof ArrayValue) {
            return ((ArrayValue) input).getValues().stream().map(this::parseLiteral).collect(Collectors.toList());
        } else if (input instanceof ObjectValue) {
            return ((ObjectValue) input).getObjectFields().stream()
                    .collect(Collectors.toMap(ObjectField::getName, field -> parseLiteral(field.getValue())));
        }
        return null;
    }
}
JAVA;
    }

    /**
     * Generates the GraphQlConfig class for GraphQL configuration.
     *
     * @return string The Java code for GraphQlConfig.java.
     */
    private function generateGraphQlConfig() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.execution.RuntimeWiringConfigurer;

@Configuration
public class GraphQlConfig {

    @Bean
    public RuntimeWiringConfigurer runtimeWiringConfigurer() {
        return wiringBuilder -> wiringBuilder.scalar(ObjectScalar.INSTANCE);
    }
}
JAVA;
    }

    /**
     * Get whether to enable verbose logging in the generated application.
     *
     * @return bool True if verbose logging is enabled, false otherwise.
     */ 
    public function getVerboseLogging()
    {
        return $this->verboseLogging;
    }
}
