<?php

namespace AppBuilder;
use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorJava` class is a powerful tool designed to automatically generate a complete Spring Boot GraphQL API from a JSON file that defines database entities.
 * It inspects the schema to understand tables, columns, primary keys, and foreign key relationships.
 * Based on this analysis, it produces Java code for entities, repositories, DTOs, and GraphQL controllers, along with GraphQL schema files, and a comprehensive API manual in Markdown format.
 * This class streamlines the process of scaffolding a GraphQL API, reducing manual effort and ensuring consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorJava extends GraphQLGeneratorBase
{
    /**
     * @var array<string, array> List of reserved column definitions.
     */
    private $reservedColumns = []; 

    /**
     * @var string Name of the 'active' field, e.g., 'aktif'.
     */
    private $activeField = 'active';

    /**
     * @var array<string, array> List of backend-handled columns.
     */
    private $backendHandledColumns = [];

    /**
     * @var string Name of the 'display' field, e.g., 'nama'.
     */
    private $displayField = 'name';

    /**
     * @var array The entire schema definition from the input JSON.
     */
    private $schema;

    /**
     * @var array<string, array> Analyzed schema with PK, FK, and column info.
     */
    private $analyzedSchema = array();
    
    /**
     * @var bool Whether to enable caching features in the generated code.
     */
    private $useCache = false;
    
    /**
     * @var array<string, string> Project configuration for pom.xml and package structure.
     */
    private $projectConfig = array();
    
    /**
     * @var bool Whether to enable verbose logging in the generated application.
     */
    private $verboseLogging = false;
    
    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use in-memory caching for queries.
     * @param array $projectConfig Project configuration details.
     * @param bool $verboseLogging Whether to enable verbose logging.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $verboseLogging = false, $requireLogin = true)
    {
        $this->schema = $schema;
        $this->backendHandledColumns = $backendHandledColumns;
        $this->useCache = $useCache;
        $this->projectConfig = array_merge(array(
            'groupId' => 'io.magicapp.generated',
            'artifactId' => 'graphql-app',
            'version' => '0.0.1-SNAPSHOT',
            'name' => 'GraphQL App',
            'description' => 'GraphQL API generated by MagicAppBuilder',
            'javaVersion' => '21',
            'packageName' => 'io.magicapp.generated.graphqlapp',
            'verboseLogging' => $verboseLogging,
            'requireLogin' => $requireLogin
        ), $projectConfig);

        if(isset($reservedColumns) && isset($reservedColumns['columns']))
        {
          $arr = array();
          foreach($reservedColumns['columns'] as $value)
          {
            $arr[$value['key']] = $value;
            if($value['key'] == 'active')
            {
              $this->activeField = $value['name'];
            }
            if($value['key'] == 'name')
            {
              $this->displayField = $value['name'];
            }
          }
          $this->reservedColumns = $arr;
        }
        else
        {
          $this->reservedColumns = array();
          
        }

        $this->analyzeSchema();
        
        $this->verboseLogging = $verboseLogging;
        $this->requireLogin = $requireLogin;
    }

    /**
     * Analyzes the raw JSON schema to identify tables, primary keys, and foreign keys.
     */
    private function analyzeSchema()
    {
        $tableNames = array();
        foreach ($this->schema['entities'] as $entity) {
            $tableNames[] = $entity['name'];
        }

        foreach ($this->schema['entities'] as $entity) {
            $tableName = $entity['name'];
            $primaryKey = $tableName . '_id';
            
            $this->analyzedSchema[$tableName] = array(
                'name' => $tableName,
                'primaryKey' => $primaryKey,
                'columns' => array(),
                'hasActiveColumn' => false,
                'filters' => isset($entity['filters']) ? $entity['filters'] : array(),
                'textareaColumns' => isset($entity['textareaColumns']) ? $entity['textareaColumns'] : array(),
                'description' => isset($entity['description']) ? $entity['description'] : null,
                
            );

            foreach ($entity['columns'] as $column) {
                $columnName = $column['name'];
                if ($column['primaryKey']) {
                    // Set the actual primary key name found in the column definition
                    $this->analyzedSchema[$tableName]['primaryKey'] = $columnName;
                    $primaryKey = $columnName;
                }
                $this->analyzedSchema[$tableName]['columns'][$columnName] = array(
                    'type' => $column['type'],
                    'length' => $column['length'],
                    'isPrimaryKey' => $column['primaryKey'],
                    'isAutoIncrement' => $column['autoIncrement'],
                    'isForeignKey' => false,
                    'references' => null,
                    'primaryKeyValue' => isset($column['primaryKeyValue']) ? $column['primaryKeyValue'] : null
                );
                if ($columnName === $this->activeField) {
                    $this->analyzedSchema[$tableName]['hasActiveColumn'] = true;
                }

                // Foreign Key Detection Logic
                if ($columnName !== $primaryKey && substr($columnName, -3) === '_id') {
                    $refTableName = substr($columnName, 0, -3);
                    if (in_array($refTableName, $tableNames)) {
                        // Check if the referenced table has a PK with the same name
                        $refTablePK = $refTableName . '_id';
                        $isRealFk = false;
                        foreach($this->schema['entities'] as $refEntity) {
                            if($refEntity['name'] === $refTableName) {
                                foreach($refEntity['columns'] as $refColumn) {
                                    if($refColumn['name'] === $refTablePK && $refColumn['primaryKey']) {
                                        $isRealFk = true;
                                        break 2;
                                    }
                                }
                            }
                        }

                        if ($isRealFk) {
                            $this->analyzedSchema[$tableName]['columns'][$columnName]['isForeignKey'] = true;
                            $this->analyzedSchema[$tableName]['columns'][$columnName]['references'] = $refTableName;
                        }
                    }
                }
            }
        }
    }

    /**
     * Maps a database type to a Java type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Java type string.
     */
    private function mapDbTypeToJavaType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'String';
        }
        if (strpos($dbType, 'timestamp') !== false) {
            return 'java.time.LocalDateTime';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'java.time.LocalDate';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'Double';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'Boolean';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'Integer';
        }
        return 'String'; // Default fallback
    }

    /**
     * Normalize a database-specific column type into a generic type.
     *
     * Supported DBMS: MySQL, MariaDB, PostgreSQL, SQLite, SQL Server
     *
     * Possible return values:
     * - string
     * - integer
     * - float
     * - boolean
     * - date
     * - time
     * - datetime
     * - binary
     * - json
     * - uuid
     * - enum
     * - geometry
     * - unknown
     *
     * @param string $dbType The raw column type from the database (e.g., VARCHAR(255), INT, NUMERIC(10,2), TEXT, etc.)
     * @return string One of the normalized type names listed above.
     */
    function normalizeDbType($dbType, $length = null)
    {
        $type = strtolower(trim($dbType));

        if($type == 'tinyint' && isset($length) && $length == '1'){
            return 'boolean';
        }

        // Remove size and precision (e.g. varchar(255) → varchar)
        $type = preg_replace('/\(.+\)/', '', $type);

        // Common integer types
        $integerTypes = [
            'int', 'integer', 'smallint', 'mediumint', 'bigint', 'serial', 'bigserial', 'tinyint'
        ];

        // Common float/decimal types
        $floatTypes = [
            'float', 'double', 'decimal', 'numeric', 'real', 'money', 'smallmoney'
        ];

        // Common string/text types
        $stringTypes = [
            'char', 'varchar', 'text', 'tinytext', 'mediumtext', 'longtext', 'nchar', 'nvarchar', 'citext', 'uuid'
        ];

        // Common date/time types
        $dateTypes = [
            'date', 'datetime', 'timestamp', 'time', 'year'
        ];

        // Boolean types
        $booleanTypes = [
            'boolean', 'bool', 'bit'
        ];

        // Binary types
        $binaryTypes = [
            'blob', 'binary', 'varbinary', 'image', 'bytea'
        ];

        // JSON types
        $jsonTypes = [
            'json', 'jsonb'
        ];

        // Normalize by matching
        if (in_array($type, $integerTypes, true)) {
            // Detect MySQL TINYINT(1) as boolean
            if (strpos($dbType, 'tinyint(1)') !== false) {
                return 'boolean';
            }
            return 'integer';
        }

        if (in_array($type, $floatTypes, true)) {
            return 'float';
        }

        if (in_array($type, $booleanTypes, true)) {
            return 'boolean';
        }

        if (in_array($type, $stringTypes, true)) {
            // UUID is string-like but semantically different
            return $type === 'uuid' ? 'uuid' : 'string';
        }

        if (in_array($type, $jsonTypes, true)) {
            return 'json';
        }

        if (in_array($type, $binaryTypes, true)) {
            return 'binary';
        }

        if (in_array($type, $dateTypes, true)) {
            if ($type === 'time') return 'time';
            if ($type === 'date') return 'date';
            return 'datetime'; // timestamp, datetime, etc.
        }

        // Default fallback
        return 'string';
    }

    /**
     * Gets a list of column names from table information.
     *
     * @param array $tableInfo Table information which must contain a 'columns' key.
     * @return string[] An array containing column names.
     */
    private function getColumnNames($tableInfo)
    {
        $columnNames = [];
        foreach ($tableInfo['columns'] as $columnName => $col) { //NOSONAR
            $columnNames[] = $columnName;
        }
        return $columnNames;
    }

    /**
     * Retrieves a simple array containing the names of columns handled by the backend.
     *
     * @return string[] An array containing column names.
     */
    private function backendHandledColumns()
    {
        $backendHandledColumns = [];
        foreach ($this->backendHandledColumns as $col) { //NOSONAR
            $backendHandledColumns[] = $col['columnName'];
        }
        return $backendHandledColumns;
    }

    /**
     * Checks if a table has columns that are handled by the backend.
     *
     * @param array $tableInfo Table information to be checked.
     * @return bool Returns `true` if there is a matching column, otherwise `false`.
     */
    private function hasBackendHandledColumns($tableInfo)
    {
        $columnNames = $this->getColumnNames($tableInfo);
        $backendHandledColumns = $this->backendHandledColumns();
        foreach ($backendHandledColumns as $columnName) {
            if (in_array($columnName, $columnNames)) {
                return true;
            }
        }
        return false;
        
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations for your Spring Boot application.\r\n\r\n";
        
        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in the `pom.xml` file. Maven will handle downloading them automatically.\r\n\r\n";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must configure the `src/main/resources/application.properties` file. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```properties\r\n";
        $manualContent .= "spring.application.name=YourAppName\r\n\r\n";
        $manualContent .= "# Database Configuration (Please update with your details)\r\n";
        $manualContent .= "app.security.require-login=true\r\n\r\n";
        $manualContent .= "# Session Management (optional, uncomment to use Redis)\r\n";
        $manualContent .= "# spring.session.store-type=redis\r\n";
        $manualContent .= "# spring.data.redis.host=localhost\r\n";
        $manualContent .= "# spring.data.redis.port=6379\r\n";
        $manualContent .= "# spring.session.timeout=30m\r\n\r\n";
        $manualContent .= "# CORS Configuration (Cross-Origin Resource Sharing)\r\n";
        $manualContent .= "app.security.cors.enabled=true\r\n";
        $manualContent .= "app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:8080\r\n\r\n";
        $manualContent .= "spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name\r\n";
        $manualContent .= "spring.datasource.username=your_username\r\n";
        $manualContent .= "spring.datasource.password=your_password\r\n";
        $manualContent .= "spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n\r\n";
        $manualContent .= "# JPA/Hibernate Configuration\r\n";
        $manualContent .= "spring.jpa.hibernate.ddl-auto=update\r\n";
        $manualContent .= "spring.jpa.show-sql=true\r\n";
        $manualContent .= "spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\r\n";
        $manualContent .= "spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\r\n\r\n";
        $manualContent .= "# GraphQL Properties\r\n";
        $manualContent .= "spring.graphql.graphiql.enabled=true\r\n";
        $manualContent .= "spring.graphql.schema.locations=classpath:graphql/\r\n";
        $manualContent .= "spring.graphql.schema.file-extensions=.graphqls\r\n";
        $manualContent .= "```\r\n\r\n";
        $manualContent .= "Make sure to replace `your_database_name`, `your_username`, and `your_password` with your actual database credentials.\r\n\r\n";


        $manualContent .= "### Integration with MagicAppBuilder\r\n\r\n";
        $manualContent .= "If you are integrating with MagicAppBuilder, you can use the database connection from an existing connection:\r\n\r\n";
        $manualContent .= "The generator will automatically populate the `application.properties` file with the connection details from your MagicAppBuilder project.\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        $manualContent .= "## In-Memory Cache\r\n\r\n";
        $manualContent .= "The auto-generated API can be configured to use Spring's caching abstraction. To enable it, you would add `@EnableCaching` to your main application class and configure a cache manager (e.g., Caffeine, EhCache, Redis) in your `application.properties`.\r\n\r\n";
        $manualContent .= "### Benefits\r\n\r\n";
        $manualContent .= "- **Reduced Database Load**: Fewer queries are executed on the database.\r\n";
        $manualContent .= "- **Faster Response Times**: Retrieving data from memory is significantly faster than from the database.\r\n\r\n";
        $manualContent .= "### How to Use\r\n\r\n";
        $manualContent .= "You can enable or disable this cache in the generator settings. When enabled, `@Cacheable` annotations will be added to the appropriate repository methods.\r\n\r\n";
        
        // Use the first table name as an example, or a placeholder if no tables exist.
        $exampleTableName = !empty($this->analyzedSchema) ? array_key_first($this->analyzedSchema) : 'yourEntity';

        $manualContent .= "```java\r\n";
        $manualContent .= "@Cacheable(value = \"".$this->camelCase($exampleTableName)."\", key = \"#id\")\r\n";
        $manualContent .= "Optional<".ucfirst($this->camelCase($exampleTableName))."> findById(String id);\r\n";
        $manualContent .= "```\r\n\r\n";

        $manualContent .= "---\r\n\r\n";
        
        $manualContent .= "## Security Considerations\r\n\r\n";
        $manualContent .= "For production or any publicly exposed environments, it is strongly recommended to remove files that are not essential for the API's runtime operations. This helps to minimize the attack surface and prevent potential information disclosure.\r\n\r\n";
        $manualContent .= "Please consider deleting the following files from your production server:\r\n\r\n";
        $manualContent .= "- **`manual.md`**: This file contains API documentation and is not needed for runtime.\r\n";
        $manualContent .= "\r\n";
        $manualContent .= "---\r\n\r\n";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $ucCamelName = ucfirst($camelName);

            $manualContent .= "## " . $ucCamelName . "\r\n\r\n";

            // --- Get Fields for examples ---
            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true); // No relations for mutation return

            // --- Query Examples ---
            $manualContent .= "### Queries\r\n\r\n";

            // Get Single Item
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $ucCamelName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-" . $camelName . "-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Get List
            $manualContent .= "#### Get a list of " . $pluralCamelName . " (with filter & sort)\r\n\r\n";
            $manualContent .= "Supports `limit`, `offset`, `orderBy`, and `filter`.\r\n\r\n";

            // Find a good column for the filter example
            $filterField = $tableInfo['primaryKey'];
            $filterValue = '"your-' . $camelName . '-id"';
            $filterOperator = 'EQUALS';

            // Prefer 'name' or 'title' for a CONTAINS filter
            foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
                if (($columnName === 'name' || $columnName === 'title') && !$columnInfo['isForeignKey']) {
                    $filterField = $columnName;
                    $filterValue = '"some-text"';
                    $filterOperator = 'CONTAINS';
                    break;
                }
            }

            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . ucfirst($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(\r\n    limit: 10, \r\n    offset: 0, \r\n    orderBy: [{field: \"" . $tableInfo['primaryKey'] . "\", direction: DESC}],\r\n    filter: [{field: \"" . $filterField . "\", value: " . $filterValue . ", operator: " . $filterOperator . "}]\r\n  ) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString); // Indent fields
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "    limit\r\n";
            $manualContent .= "    page\r\n";
            $manualContent .= "    totalPages\r\n";
            $manualContent .= "    hasNext\r\n";
            $manualContent .= "    hasPrevious\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // --- Mutation Examples ---
            $manualContent .= "### Mutations\r\n\r\n";

            // Get Input Fields for mutations
            list($inputFieldsString, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            // Create
            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $ucCamelName . " {\r\n";
            $manualContent .= "  create" . $ucCamelName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Update
            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $ucCamelName . " {\r\n";
            $manualContent .= "  update" . $ucCamelName . "(id: \"your-" . $camelName . "-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Delete
            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "Returns `true` on success.\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $ucCamelName . " {\r\n";
            $manualContent .= "  delete" . $ucCamelName . "(id: \"your-" . $camelName . "-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        // --- API Reference Guide ---
        $manualContent .= "## API Reference Guide\r\n\r\n";
        $manualContent .= "This section provides a reference for common arguments used in list queries.\r\n\r\n";

        // Filtering
        $manualContent .= "### Filtering (`filter`)\r\n\r\n";
        $manualContent .= "The `filter` argument allows you to narrow down results based on field values. It accepts a list of filter objects, which are combined with `AND` logic.\r\n\r\n";
        $manualContent .= "| Operator       | Description                                      | Example                                                |\r\n";
        $manualContent .= "|----------------|--------------------------------------------------|--------------------------------------------------------|\r\n";
        $manualContent .= "| `EQUALS`       | Finds records where the field exactly matches the value. | `{field: \"status\", value: \"published\"}`                |\r\n";
        $manualContent .= "| `NOT_EQUALS`   | Finds records where the field does not match the value. | `{field: \"status\", value: \"archived\", operator: NOT_EQUALS}` |\r\n";
        $manualContent .= "| `CONTAINS`     | Finds records where the text field contains the value (`LIKE '%value%'`). | `{field: \"title\", value: \"love\", operator: CONTAINS}` |\r\n";
        $manualContent .= "| `GREATER_THAN_OR_EQUALS` | Finds records where the numeric/date field is greater than or equal to the value. | `{field: \"price\", value: \"99.99\", operator: GREATER_THAN_OR_EQUALS}` |\r\n";
        $manualContent .= "| `GREATER_THAN` | Finds records where the numeric/date field is greater than the value. | `{field: \"price\", value: \"100\", operator: GREATER_THAN}` |\r\n";
        $manualContent .= "| `LESS_THAN_OR_EQUALS`    | Finds records where the numeric/date field is less than or equal to the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN_OR_EQUALS}`   |\r\n";
        $manualContent .= "| `LESS_THAN`    | Finds records where the numeric/date field is less than the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN}`   |\r\n";
        $manualContent .= "| `IN` / `NOT_IN` | Finds records where the field value is in (or not in) a comma-separated list of values. | `{field: \"category_id\", value: \"1,2,3\", operator: IN}` |\r\n\r\n";

        // Sorting
        $manualContent .= "### Sorting (`orderBy`)\r\n\r\n";
        $manualContent .= "The `orderBy` argument sorts the results. It accepts a list of sort objects.\r\n\r\n";
        $manualContent .= "- `field`: The name of the field to sort by (e.g., `\"name\"`).\r\n";
        $manualContent .= "- `direction`: The sort direction. Can be `ASC` (ascending) or `DESC` (descending). Defaults to `ASC`.\r\n\r\n";
        $manualContent .= "**Example:** `orderBy: [{field: \"release_date\", direction: DESC}]`\r\n\r\n";

        // Pagination
        $manualContent .= "### Pagination (`limit` & `offset`)\r\n\r\n";
        $manualContent .= "- `limit`: Specifies the maximum number of records to return.\r\n";
        $manualContent .= "- `offset`: Specifies the number of records to skip from the beginning.\r\n\r\n";
        $manualContent .= "**Example:** To get the second page of 10 items: `limit: 10, offset: 10`\r\n\r\n";

        return $manualContent;
    }

    /**
     * Helper to get a formatted string of fields for the manual.
     * If $noRelations is true, foreign key relations are not expanded.
     * 
     * @param array $tableInfo The table information.
     * @param bool $noRelations Whether to exclude foreign key relations.
     * @return string The formatted fields string.
     */
    private function getFieldsForManual($tableInfo, $noRelations = false)
    { //NOSONAR
        $fieldsString = ""; //NOSONAR
        if(isset($tableInfo) && isset($tableInfo['columns']))
        {
            foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
                if (!$columnInfo['isForeignKey']) {
                    $fieldsString .= "    " . $columnName . "\r\n";
                } else if (!$noRelations) {
                    $refTableName = $columnInfo['references'];
                    $fieldsString .= "    " . $refTableName . " {\r\n";
                    $fieldsString .= "      " . $this->analyzedSchema[$refTableName]['primaryKey'] . "\r\n";
                    // Add one more field for context
                    foreach ($this->analyzedSchema[$refTableName]['columns'] as $refColName => $refColInfo) {
                        if (!$refColInfo['isForeignKey'] && $refColName !== $this->analyzedSchema[$refTableName]['primaryKey']) {
                            $fieldsString .= "      " . $refColName . "\r\n";
                            break;
                        }
                    }
                    $fieldsString .= "    }\r\n";
                }
            }
        }
        return $fieldsString;
    }

    /**
     * Helper to get formatted input fields for the manual.
     * @param array $tableInfo The table information.
     * @return array An array with two strings: input fields and example values.
     */
    private function getInputFieldsForManual($tableInfo)
    {
        $inputExampleString = ""; //NOSONAR
        foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
            if ($columnName === $tableInfo['primaryKey'] && ($columnInfo['isAutoIncrement'] || $columnInfo['primaryKeyValue'] == 'autogenerated')) continue;
            $javaType = $this->mapDbTypeToJavaType($columnInfo['type'], $columnInfo['length']);
            $exampleValue = '"string"';
            if ($javaType === 'Integer') $exampleValue = '123';
            if ($javaType === 'Double') $exampleValue = '123.45';
            if ($javaType === 'Boolean') $exampleValue = 'true';
            $inputExampleString .= "    " . $columnName . ": " . $exampleValue . "\r\n";
        }
        return array($inputExampleString, $inputExampleString);
    }

    /**
     * Generates the content for the composer.json file.
     * This includes the necessary dependencies for running the GraphQL API.
     *
     * @return string The XML formatted content for pom.xml.
     */
    public function generatePomXml()
    {
        $config = $this->projectConfig;
        return <<<XML
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
	<modelVersion>4.0.0</modelVersion>
	<parent>
		<groupId>org.springframework.boot</groupId>
		<artifactId>spring-boot-starter-parent</artifactId>
		<version>3.2.5</version>
		<relativePath/> <!-- lookup parent from repository -->
	</parent>
	<groupId>{$config['groupId']}</groupId>
	<artifactId>{$config['artifactId']}</artifactId>
	<version>{$config['version']}</version>
	<name>{$config['name']}</name>
	<description>{$config['description']}</description>
	<properties>
		<java.version>{$config['javaVersion']}</java.version>
        <!-- Explicitly set the main class to avoid ambiguity -->
        <start-class>{$config['packageName']}.{$this->pascalCase($config['artifactId'])}Application</start-class>
	</properties>
	<dependencies>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-graphql</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-redis</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.session</groupId>
            <artifactId>spring-session-data-redis</artifactId>
        </dependency>
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>
		<dependency>
			<groupId>org.projectlombok</groupId>
			<artifactId>lombok</artifactId>
			<optional>true</optional>
		</dependency>
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework</groupId>
			<artifactId>spring-webflux</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.graphql</groupId>
			<artifactId>spring-graphql-test</artifactId>
			<scope>test</scope>
		</dependency>
		<dependency>
			<groupId>org.springframework.security</groupId>
			<artifactId>spring-security-test</artifactId>
			<scope>test</scope>
		</dependency>
	</dependencies>

	<build>
		<plugins>
			<plugin>
				<groupId>org.springframework.boot</groupId>
				<artifactId>spring-boot-maven-plugin</artifactId>
				<configuration>
					<excludes>
						<exclude>
							<groupId>org.projectlombok</groupId>
							<artifactId>lombok</artifactId>
						</exclude>
					</excludes>
				</configuration>
			</plugin>
		</plugins>
	</build>

</project>
XML;
    }

    /**
     * Converts a camelCase string to snake_case.
     *
     * @param string $str The camelCase string.
     * @return string The converted snake_case string.
     */
    public function camelCaseToSnakeCase($str) {
        return strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $str));
    }

    /**
     * Converts a snake_case string to camelCase.
     *
     * @param string $str The snake_case string.
     * @return string The converted camelCase string.
     */
    public function snakeCaseToCamelCase($str) {
        $words = explode('_', strtolower($str));
        $camel = array_shift($words);
        foreach ($words as $word) {
            $camel .= ucfirst($word);
        }
        return $camel;
    }

    /**
     * Converts a snake_case string to Title Case.
     *
     * @param string $str The snake_case string.
     * @return string The converted Title Case string.
     */
    public function snakeCaseToTitleCase($str) {
        $str = str_replace('_', ' ', strtolower($str));
        return $this->titleCase($str);
    }

    /**
     * Converts a camelCase string to Title Case.
     *
     * @param string $str The camelCase string.
     * @return string The converted Title Case string.
     */
    public function camelCaseToTitleCase($str) {
        return $this->snakeCaseToTitleCase(strtolower(preg_replace('/([a-z])([A-Z])/', '$1_$2', $str)));
    }

    /**
     * Converts a string to Title Case.
     *
     * @param string $str The input string.
     * @return string The converted Title Case string.
     */
    public function titleCase($str) {
        $words = explode(' ', strtolower(trim($str)));
        foreach ($words as &$word) {
            $word = ucfirst($word);
        }
        return implode(' ', $words);
    }

    /**
     * Converts any case style (snake_case, kebab-case, camelCase, etc.) to PascalCase.
     *
     * @param string $str The input string in any case.
     * @return string The converted PascalCase string.
     */
    public function pascalCase($str) {
        // Normalize: replace common separators with space
        $normalized = preg_replace('/[_\-]/', ' ', $str);

        // Insert space before capital letters (for camelCase or PascalCase)
        $normalized = preg_replace('/(?<!^)([A-Z])/', ' $1', $normalized);

        // Lowercase everything first
        $normalized = strtolower($normalized);

        // Capitalize each word and remove spaces
        $pascal = str_replace(' ', '', ucwords($normalized));

        return $pascal;
    }

    /**
     * Generates the PHP code for a helper function that retrieves the last inserted ID
     * in a cross-database compatible way.
     *
     * @return string The PHP code for the `getLastInsertId` function.
     */
    private function generateLastInsertIdFunction()
    {
        return "
/**
 * Retrieves the last inserted ID in a way that is compatible with MySQL, PostgreSQL, and SQL Server.
 *
 * @param PDO \$db The PDO database connection object.
 * @param string \$tableName The name of the table.
 * @param string \$primaryKeyName The name of the primary key column.
 * @return mixed The last inserted ID.
 */
function getLastInsertId(\$db, \$tableName, \$primaryKeyName)
{
    \$driver = \$db->getAttribute(PDO::ATTR_DRIVER_NAME);
    switch (\$driver) {
        case 'pgsql':
            // For PostgreSQL, lastInsertId() requires the sequence name.
            \$sequenceName = \$tableName . '_' . \$primaryKeyName . '_seq';
            return \$db->lastInsertId(\$sequenceName);
        case 'sqlsrv':
            // For SQL Server, SCOPE_IDENTITY() is the most reliable way.
            return \$db->query('SELECT SCOPE_IDENTITY()')->fetchColumn();
        case 'mysql':
        case 'sqlite':
        default:
            // For MySQL, MariaDB, and SQLite, lastInsertId() works without arguments.
            return \$db->lastInsertId();
    }
}";
    }

    /**
     * Generates the PHP code for a helper function that generates a unique 20-byte ID.
     *
     * @return string The PHP code for the `generateNewId` function.
     */
    private function generateNewIdFunction()
    {
        return "
/**
 * Generate a unique 20-byte ID.
 *
 * This method generates a unique ID by concatenating a 13-character string
 * from `uniqid()` with a 6-character random hexadecimal string, ensuring
 * the resulting string is 20 characters in length.
 *
 * @return string A unique 20-byte identifier.
 */
function generateNewId()
{
    \$uuid = uniqid();
    if ((strlen(\$uuid) % 2) == 1) {
        \$uuid = '0' . \$uuid;
    }
    \$random = sprintf('%06x', mt_rand(0, 16777215));
    return sprintf('%s%s', \$uuid, \$random);
}
";
    }

    /**
     * Generates the PHP code for a helper function that normalizes boolean inputs
     * for specific database drivers.
     *
     * @return string The PHP code for the `normalizeBooleanInputs` function.
     */
    private function generateNormalizeBooleanInputsFunction()
    {
        return "/**
 * Normalizes boolean values in input arguments for specific database drivers.
 *
 * This function converts boolean values (true/false) inside `\$args['input']`
 * into integer values (1/0) when using databases that do not natively support
 * boolean types — specifically SQLite and SQL Server.
 *
 * For other drivers (e.g., MySQL, PostgreSQL), the input arguments are returned
 * unchanged.
 *
 * @param array \$args Input arguments, typically containing a key `input` with associative data.
 * @param PDO \$db A valid PDO instance representing the current database connection.
 *
 * @return array The modified (or original) input arguments with normalized boolean values.
 */
function normalizeBooleanInputs(\$args, \$db)
{
    \$driver = strtolower(\$db->getAttribute(PDO::ATTR_DRIVER_NAME));
    if (\$driver !== 'sqlite' && \$driver !== 'sqlsrv') {
        return \$args;
    }
    if(isset(\$args['input']) && is_array(\$args['input']))
    {
        foreach (\$args['input'] as \$key => \$value) {
            if (is_bool(\$value)) {
                \$args['input'][\$key] = \$value ? 1 : 0;
            }
        }
    }
    return \$args;
}";
    }

    /**
     * Generates the PHP code for a helper function that normalizes a single boolean value
     * for specific database drivers.
     *
     * @return string The PHP code for the `normalizeBoolean` function.
     */
    private function generateNormalizeBooleanFunction()
    {
        return "/**
 * Normalizes boolean value argument for specific database drivers.
 *
 * This function converts boolean value (true/false) into integer values (1/0) 
 * when using databases that do not natively support
 * boolean types — specifically SQLite and SQL Server.
 *
 * For other drivers (e.g., MySQL, PostgreSQL), the input arguments are returned
 * unchanged.
 *
 * @param boolean \$value Input value, typically containing a key `input` with associative data.
 * @param PDO \$db A valid PDO instance representing the current database connection.
 *
 * @return boolean The modified (or original) input argument with normalized boolean value.
 */
function normalizeBoolean(\$value, \$db)
{
    \$driver = strtolower(\$db->getAttribute(PDO::ATTR_DRIVER_NAME));
    if (\$driver === 'sqlite' || \$driver === 'sqlsrv') {
        return \$value ? 1 : 0;
    }
    return (bool) \$value;
}";
    }

    /**
     * Main function to generate all files for the Spring Boot project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = [];
        $this->projectConfig['basePackagePath'] = 'src/main/java/' . str_replace('.', '/', $this->projectConfig['packageName']);
        $packagePath = 'src/main/java/' . str_replace('.', '/', $this->projectConfig['packageName']);

        // 1. pom.xml
        $files[] = ['name' => 'pom.xml', 'content' => $this->generatePomXml()];

        // 3. Main Application Class
        $files[] = ['name' => $packagePath . '/' . $this->pascalCase($this->projectConfig['artifactId']) . 'Application.java', 'content' => $this->generateMainAppClass()];

        // 4. GraphQL Schema, Entities, Repositories, DTOs, Controllers
        $allSchemaParts = [];
        $allQueryFields = [];
        $allMutationFields = [];

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            // Generate individual Java files
            $files[] = ['name' => $packagePath . '/model/entity/' . ucfirst($this->camelCase($tableName)) . '.java', 'content' => $this->generateEntityClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/repository/' . ucfirst($this->camelCase($tableName)) . 'Repository.java', 'content' => $this->generateRepositoryInterface($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/dto/' . ucfirst($this->camelCase($tableName)) . 'Input.java', 'content' => $this->generateDtoClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/controller/' . ucfirst($this->camelCase($tableName)) . 'Controller.java', 'content' => $this->generateControllerClass($tableName, $tableInfo)];

            // Collect schema parts to be merged later
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];
        }
        
        // 5. Specification and Filter classes
        $files[] = ['name' => $packagePath . '/util/SpecificationBuilder.java', 'content' => $this->generateSpecificationBuilder()];
        $files[] = ['name' => $packagePath . '/util/FilterCriteria.java', 'content' => $this->generateFilterCriteria()];
        $files[] = ['name' => $packagePath . '/util/SearchOperation.java', 'content' => $this->generateSearchOperation()];
        $files[] = ['name' => $packagePath . '/util/GenericSpecification.java', 'content' => $this->generateGenericSpecification()];

        // 5.1. DTOs for GraphQL inputs
        $files[] = ['name' => $packagePath . '/model/dto/FilterInput.java', 'content' => $this->generateFilterInputDto()];
        $files[] = ['name' => $packagePath . '/model/dto/SortInput.java', 'content' => $this->generateSortInputDto()];
        
        $files[] = ['name' => 'src/main/resources/frontend-config.json', 'content' => $this->generateFrontendConfigJson()];

        // 5.1. Generate the single, combined GraphQL schema file
        $files[] = ['name' => 'src/main/resources/graphql/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        // 6. Security and Auth files
        $files[] = ['name' => $packagePath . '/config/SecurityConfig.java', 'content' => $this->generateSecurityConfig()];
        $files[] = ['name' => $packagePath . '/config/CorsConfig.java', 'content' => $this->generateCorsConfig()];
        $files[] = ['name' => $packagePath . '/config/SessionAuthFilter.java', 'content' => $this->generateSessionAuthFilter()];
        $files[] = ['name' => $packagePath . '/config/Sha1PasswordEncoder.java', 'content' => $this->generateSha1PasswordEncoder()];
        $files[] = ['name' => $packagePath . '/service/JpaUserDetailsService.java', 'content' => $this->generateUserDetailsService()];
        $files[] = ['name' => $packagePath . '/model/entity/Admin.java', 'content' => $this->generateAdminEntity()];
        $files[] = ['name' => $packagePath . '/model/repository/AdminRepository.java', 'content' => $this->generateAdminRepository()];

        // 7. Auth and App Controllers
        $files[] = ['name' => $packagePath . '/controller/dto/LoginRequest.java', 'content' => $this->generateLoginRequestDto()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginResponse.java', 'content' => $this->generateLoginResponseDto()];
        $files[] = ['name' => $packagePath . '/controller/AuthController.java', 'content' => $this->generateAuthController()];
        $files[] = ['name' => $packagePath . '/controller/AppController.java', 'content' => $this->generateAppController()];
        $files[] = ['name' => $packagePath . '/config/ObjectScalar.java', 'content' => $this->generateObjectScalar()];
        $files[] = ['name' => $packagePath . '/config/GraphQlConfig.java', 'content' => $this->generateGraphQlConfig()];
        $files[] = ['name' => $packagePath . '/controller/dto/ProfileUpdateRequest.java', 'content' => $this->generateProfileUpdateRequestDto()];

        return $files;
    }

    public function generateApplicationProperties() {
        $requireLoginValue = $this->requireLogin ? 'true' : 'false';
        return <<<PROPERTIES
spring.application.name={$this->projectConfig['name']}

# Database Configuration (Please update with your details)
app.security.require-login=$requireLoginValue

# Session Management (optional, uncomment to use Redis)
# spring.session.store-type=redis
# spring.data.redis.host=localhost
# spring.data.redis.port=6379
# spring.session.timeout=30m

# CORS Configuration (Cross-Origin Resource Sharing)
app.security.cors.enabled=true
app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

spring.datasource.url={DB_URL}
spring.datasource.username={DB_USER}
spring.datasource.password={DB_PASS}
spring.datasource.driver-class-name={DB_DRIVER_CLASS}

# JPA/Hibernate Configuration
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect={DB_DIALECT}

# Use database column names directly without converting to camelCase
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# GraphQL Configuration
spring.graphql.graphiql.enabled=true
spring.graphql.schema.locations=classpath:graphql/
spring.graphql.schema.file-extensions=.graphqls

# Caching (optional)
# spring.cache.type=caffeine
PROPERTIES;
    }

    private function generateMainAppClass() {
        $className = $this->pascalCase($this->projectConfig['artifactId']) . 'Application';
        $content = "package {$this->projectConfig['packageName']};\n\n";
        $content .= "import org.springframework.boot.SpringApplication;\n";
        $content .= "import org.springframework.boot.autoconfigure.SpringBootApplication;\n";
        if ($this->useCache) {
            $content .= "import org.springframework.cache.annotation.EnableCaching;\n";
        }
        $content .= "\n";
        if ($this->useCache) {
            $content .= "@EnableCaching\n";
        }
        $content .= "@SpringBootApplication\n";
        $content .= "public class $className {\n\n";
        $content .= "    public static void main(String[] args) {\n";
        $content .= "        SpringApplication.run($className.class, args);\n";
        $content .= "    }\n\n";
        $content .= "}\n";
        return $content;
    }

    private function generateEntityClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $className = ucfirst($camelName);
        $package = $this->projectConfig['packageName'];

        $imports = "import jakarta.persistence.*;\nimport lombok.Data;\nimport java.io.Serializable;\n";
        $fields = "";
        $hasLdt = false;
        $hasLd = false;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $javaType = $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']);
            $fieldName = $colName; // Use original column name

            if (strpos($javaType, 'LocalDateTime') !== false) $hasLdt = true;
            if (strpos($javaType, 'LocalDate') !== false) $hasLd = true;

            if ($colInfo['isPrimaryKey']) {
                $fields .= "    @Id\n";
                if ($colInfo['isAutoIncrement']) {
                    $fields .= "    @GeneratedValue(strategy = GenerationType.IDENTITY)\n";
                }
            }
            // No need for @Column(name=...) if physical strategy is used and field name matches
            $fields .= "    private " . basename(str_replace('\\', '/', $javaType)) . " $fieldName;\n\n";
        }

        if ($hasLdt) $imports .= "import java.time.LocalDateTime;\n";
        if ($hasLd) $imports .= "import java.time.LocalDate;\n";

        return <<<JAVA
package $package.model.entity;

$imports
@Data
@Entity
@Table(name = "$tableName")
public class $className implements Serializable {

$fields}
JAVA;
    }

    private function generateRepositoryInterface($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $className = ucfirst($camelName);
        $package = $this->projectConfig['packageName'];
        $pkJavaType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkJavaType = $this->mapDbTypeToJavaType($col['type'], $col['length']);
                break;
            }
        }

        $imports = "import org.springframework.data.jpa.repository.JpaRepository;\n";
        $imports .= "import org.springframework.data.jpa.repository.JpaSpecificationExecutor;\n";
        $imports .= "import $package.model.entity.$className;\n";
        if ($this->useCache) {
            $imports .= "import org.springframework.cache.annotation.Cacheable;\n";
        }
        $imports .= "import java.util.Optional;\n";

        $findByIdMethod = "Optional<$className> findById($pkJavaType id);";
        if ($this->useCache) {
            $findByIdMethod = "@Cacheable(value = \"$camelName\", key = \"#id\")\n    " . $findByIdMethod;
        }

        return <<<JAVA
package $package.model.repository;

$imports
import org.springframework.stereotype.Repository;

@Repository
public interface {$className}Repository extends JpaRepository<$className, $pkJavaType>, JpaSpecificationExecutor<$className> {
    $findByIdMethod
}
JAVA;
    }

    private function generateDtoClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $className = ucfirst($camelName) . "Input";
        $package = $this->projectConfig['packageName'];

        $imports = "import lombok.Data;\n";
        $fields = "";
        $hasLdt = false;
        $hasLd = false;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $javaType = $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']);
            $fieldName = $colName; // Use original column name
            if (strpos($javaType, 'LocalDateTime') !== false) $hasLdt = true;
            if (strpos($javaType, 'LocalDate') !== false) $hasLd = true;
            $fields .= "    private " . basename(str_replace('\\', '/', $javaType)) . " $fieldName;\n\n";
        }

        if ($hasLdt) $imports .= "import java.time.LocalDateTime;\n";
        if ($hasLd) $imports .= "import java.time.LocalDate;\n";

        return <<<JAVA
package $package.model.dto;

$imports
@Data
public class $className {
$fields}
JAVA;
    }

    private function generateControllerClass($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);
        $package = $this->projectConfig['packageName'];
        $pkJavaType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkJavaType = $this->mapDbTypeToJavaType($col['type'], $col['length']);
                break;
            }
        }

        return <<<JAVA
package $package.controller;

import $package.model.dto.FilterInput;
import $package.model.dto.SortInput;
import $package.model.dto.{$ucCamelName}Input;
import $package.model.entity.$ucCamelName;
import $package.model.repository.{$ucCamelName}Repository;
import $package.util.SearchOperation;
import $package.util.SpecificationBuilder;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.graphql.data.method.annotation.Argument;
import org.springframework.graphql.data.method.annotation.MutationMapping;
import org.springframework.graphql.data.method.annotation.QueryMapping;
import org.springframework.stereotype.Controller;

import java.util.List;
import java.util.Map;
import java.util.UUID;

@Controller
public class {$ucCamelName}Controller {

    @Autowired
    private {$ucCamelName}Repository {$camelName}Repository;

    @QueryMapping
    public $ucCamelName {$camelName}(@Argument $pkJavaType id) {
        return {$camelName}Repository.findById(id).orElse(null);
    }

    @QueryMapping
    public Map<String, Object> {$pluralCamelName}(
            @Argument Integer limit,
            @Argument Integer offset,
            @Argument Integer page,
            @Argument Integer size,
            @Argument List<SortInput> orderBy,
            @Argument List<FilterInput> filter) {

        int pageSize = (limit != null) ? limit : (size != null ? size : 20);
        int pageNum = 0;
        if (offset != null && pageSize > 0) {
            pageNum = offset / pageSize;
        } else if (page != null) {
            pageNum = page > 0 ? page - 1 : 0; // Convert 1-based page to 0-based
        }

        Sort sort = Sort.unsorted();
        if (orderBy != null && !orderBy.isEmpty()) {
            List<Sort.Order> orders = orderBy.stream()
                    .map(order -> new Sort.Order(Sort.Direction.fromString(order.getDirection()), order.getField()))
                    .toList();
            sort = Sort.by(orders);
        }

        Pageable pageable = PageRequest.of(pageNum, pageSize, sort);

        SpecificationBuilder<$ucCamelName> builder = new SpecificationBuilder<>();
        if (filter != null) {
            for (FilterInput f : filter) {
                String operator = (f.getOperator() == null || f.getOperator().isEmpty()) 
                                  ? "EQUALS" 
                                  : f.getOperator().toUpperCase();
                builder.with(f.getField(), SearchOperation.valueOf(operator), f.getValue());
            }
        }

        Page<$ucCamelName> resultPage = {$camelName}Repository.findAll(builder.build(), pageable);

        return Map.of(
            "items", resultPage.getContent(),
            "total", resultPage.getTotalElements(),
            "limit", resultPage.getSize(),
            "page", resultPage.getNumber() + 1, // Frontend pages are usually 1-based
            "totalPages", resultPage.getTotalPages(),
            "hasNext", resultPage.hasNext(),
            "hasPrevious", resultPage.hasPrevious()
        );
    }

    @MutationMapping
    public $ucCamelName create{$ucCamelName}(@Argument {$ucCamelName}Input input) {
        $ucCamelName {$camelName} = new $ucCamelName();
        // Manual mapping from DTO to Entity
        // You can use a library like MapStruct for this
        return {$camelName}Repository.save({$camelName});
    }

    @MutationMapping
    public $ucCamelName update{$ucCamelName}(@Argument $pkJavaType id, @Argument {$ucCamelName}Input input) {
        $ucCamelName {$camelName} = {$camelName}Repository.findById(id)
            .orElseThrow(() -> new RuntimeException("$ucCamelName not found with id " + id));
        // Manual mapping from DTO to Entity
        return {$camelName}Repository.save({$camelName});
    }

    @MutationMapping
    public boolean delete{$ucCamelName}(@Argument $pkJavaType id) {
        {$camelName}Repository.deleteById(id);
        return true;
    }
}
JAVA;
    }

    private function mapJavaTypeToGqlType($javaType) {
        $baseType = basename(str_replace('\\', '/', $javaType));
        switch ($baseType) {
            case 'Integer':
                return 'Int';
            case 'Double':
            case 'Float':
                return 'Float';
            case 'Boolean':
                return 'Boolean';
            case 'String':
            case 'LocalDate':
            case 'LocalDateTime':
                return 'String'; // Or custom scalars
            default:
                return 'String';
        }
    }

    /**
     * Converts snake_case to camelCase.
     *
     * @param string $string The input string.
     * @return string The camelCased string.
     */
    private function camelCase($string) //NOSONAR
    {
        return lcfirst(str_replace(' ', '', ucwords(str_replace('_', ' ', $string))));
    }

    /**
     * A simple pluralizer.
     *
     * @param string $string The singular string.
     * @return string The pluralized string.
     */
    private function pluralize($string) //NOSONAR
    {
        if (substr($string, -1) === 'y') {
            return substr($string, 0, -1) . 'ies';
        }
        if (substr($string, -1) === 's') {
            return $string . 'es';
        }
        return $string . 's';
    }

    /**
     * Get list of reserved column definitions.
     */
    public function getReservedColumns()
    {
        return $this->reservedColumns;
    }
    
    /**
     * Get project configuration.
     */
    public function getProjectConfig()
    {
        return $this->projectConfig;
    }

    private function generateSpecificationBuilder() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

import org.springframework.data.jpa.domain.Specification;
import java.util.ArrayList;
import java.util.List;
import java.util.stream.Collectors;

public class SpecificationBuilder<T> {

    private final List<FilterCriteria> params;

    public SpecificationBuilder() {
        params = new ArrayList<>();
    }

    public SpecificationBuilder<T> with(String key, SearchOperation operation, Object value) {
        params.add(new FilterCriteria(key, operation, value));
        return this;
    }

    public Specification<T> build() {
        if (params.isEmpty()) {
            return null;
        }

        List<Specification<T>> specs = params.stream()
                .map(GenericSpecification<T>::new)
                .collect(Collectors.toList());

        Specification<T> result = specs.get(0);

        for (int i = 1; i < params.size(); i++) {
            result = Specification.where(result).and(specs.get(i));
        }
        return result;
    }
}
JAVA;
    }

    private function generateFilterCriteria() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;

@Data
@AllArgsConstructor
@NoArgsConstructor
public class FilterCriteria {
    private String key;
    private SearchOperation operation;
    private Object value;
}
JAVA;
    }

    private function generateSearchOperation() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

public enum SearchOperation {
    EQUALS,
    NOT_EQUALS,
    CONTAINS,
    GREATER_THAN,
    GREATER_THAN_OR_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUALS,
    IN,
    NOT_IN;
}
JAVA;
    }

    private function generateGenericSpecification() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.util;

import jakarta.persistence.criteria.CriteriaBuilder;
import jakarta.persistence.criteria.CriteriaQuery;
import jakarta.persistence.criteria.Predicate;
import jakarta.persistence.criteria.Root;
import org.springframework.data.jpa.domain.Specification;

@SuppressWarnings("serial")
public class GenericSpecification<T> implements Specification<T> {

    private final FilterCriteria criteria;

    public GenericSpecification(FilterCriteria criteria) {
        this.criteria = criteria;
    }

    @Override
    public Predicate toPredicate(Root<T> root, CriteriaQuery<?> query, CriteriaBuilder builder) {
        String key = criteria.getKey();
        Object value = criteria.getValue();

        // Get the expected Java type for the field from the JPA entity metadata
        Class<?> fieldType = root.get(key).getJavaType();
        Object typedValue = value;

        // Convert the incoming value (which can be String, BigDecimal, Boolean, etc.) to the correct type
        if (value != null) {
            String stringValue = value.toString();
            if (fieldType.equals(Integer.class) || fieldType.equals(int.class)) {
                typedValue = Integer.parseInt(stringValue);
            } else if (fieldType.equals(Long.class) || fieldType.equals(long.class)) {
                typedValue = Long.parseLong(stringValue);
            } else if (fieldType.equals(Double.class) || fieldType.equals(double.class)) {
                typedValue = Double.parseDouble(stringValue);
            } else if (fieldType.equals(Float.class) || fieldType.equals(float.class)) {
                typedValue = Float.parseFloat(stringValue);
            } else if (fieldType.equals(Boolean.class) || fieldType.equals(boolean.class)) {
                typedValue = Boolean.parseBoolean(stringValue);
            } else if (fieldType.equals(String.class)) {
                typedValue = stringValue;
            } else if (fieldType.isEnum()) {
                typedValue = Enum.valueOf((Class<Enum>) fieldType, stringValue);
            }
            // Note: java.time types might need specific parsing if required
        }

        switch (criteria.getOperation()) {
            case EQUALS:
                return builder.equal(root.get(key), typedValue);
            case NOT_EQUALS:
                return builder.notEqual(root.get(key), typedValue);
            case GREATER_THAN:
                return builder.greaterThan(root.get(key), typedValue.toString());
            case GREATER_THAN_OR_EQUALS:
                return builder.greaterThanOrEqualTo(root.get(key), typedValue.toString());
            case LESS_THAN:
                return builder.lessThan(root.get(key), typedValue.toString());
            case LESS_THAN_OR_EQUALS:
                return builder.lessThanOrEqualTo(root.get(key), typedValue.toString());
            case CONTAINS:
                if (root.get(key).getJavaType() == String.class) {
                    return builder.like(root.get(key), "%" + typedValue + "%");
                } else {
                    return builder.equal(root.get(key), typedValue);
                }
            case IN:
                return root.get(key).in((Object[]) typedValue);
            case NOT_IN:
                return builder.not(root.get(key).in((Object[]) typedValue));
            default:
                return null;
        }
    }
}
JAVA;
    }
    
    /**
     * Generates a JSON config file for the frontend.
     * This file contains metadata about entities, fields, and relationships.
     *
     * @return string The JSON formatted content for frontend-config.json.
     */
    public function generateFrontendConfigJson()
    {
        $sortOrder = 1;
        $frontendConfig = array();
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            
            $textareaColumns = array();
            if(isset($tableInfo['textareaColumns']) && is_array($tableInfo['textareaColumns']))
            {
                $textareaColumns = $tableInfo['textareaColumns'];
            }
            $columns = array();
            foreach($tableInfo['columns'] as $colName => $colInfo) {
                $columns[$colName] = array(
                    'type' => $this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']),
                    'dataType' => $this->normalizeDbType($colInfo['type'], $colInfo['length']),
                    'isPrimaryKey' => $colInfo['isPrimaryKey'],
                    'isForeignKey' => $colInfo['isForeignKey'],
                    'references' => $colInfo['references'] ? $colInfo['references'] : null,
                    'element' => in_array($colName, $textareaColumns) ? 'textarea' : 'input',
                );
                if($colInfo['isPrimaryKey'])
                {
                    $columns[$colName]['primaryKeyValue'] = $colInfo['primaryKeyValue'] ? $colInfo['primaryKeyValue'] : 'autogenerated';
                }
            }

            $frontendConfig[$camelName] = array(
                'name' => $camelName,
                'pluralName' => $pluralCamelName,
                'displayName' => $this->camelCaseToTitleCase($camelName),
                'originalName' => $tableName,
                'displayField' => $this->displayField,
                'activeField' => $this->activeField,
                'primaryKey' => $tableInfo['primaryKey'],
                'hasActiveColumn' => $tableInfo['hasActiveColumn'],
                'sortOrder' => $sortOrder++,
                'menu' => true,
                'columns' => $columns,
                'filters' => isset($tableInfo['filters']) ? $tableInfo['filters'] : [],
                'backendHandledColumns' => array_column($this->backendHandledColumns, 'columnName'),
                
            );
        }
        
        return json_encode([
            'booleanDisplay' => array(
                'trueLabelKey' => 'yes',
                'falseLabelKey' => 'no'
            ),
            'pagination' => array (
                'pageSize' => 20,
                'maxPageSize' => 100,
                'minPageSize' => 1
            ),
            'entities' => $frontendConfig
        ], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    }

    /**
     * Generates a JSON file for frontend language translations.
     * This file contains human-readable names for entities and their fields.
     *
     * @return string The JSON formatted content for frontend-language.json.
     */
    public function generateFrontendLanguageJson()
    {
        $frontendConfig = array();
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $columns = array();
            foreach($tableInfo['columns'] as $colName => $colInfo) {
                if($colInfo['isForeignKey'] && PicoStringUtil::endsWith($colName, '_id'))
                {
                    $columns[$colName] = $this->snakeCaseToTitleCase(substr($colName, 0, strlen($colName) - 3)); 
                }
                else
                {
                    $columns[$colName] = $this->snakeCaseToTitleCase($colName); 
                }
            }
            $frontendConfig[$tableName]['name'] = trim($tableName);
            $frontendConfig[$tableName]['displayName'] = $this->snakeCaseToTitleCase($tableName);
            $frontendConfig[$tableName]['columns'] = $columns;
        }
        return json_encode(['entities' => $frontendConfig], JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES);
    }


    private function generateSecurityConfig() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package {$package}.config;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Configuration;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.http.HttpStatus;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.HttpStatusEntryPoint;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import {$package}.service.JpaUserDetailsService;
import org.springframework.security.config.http.SessionCreationPolicy;
import {$package}.model.repository.AdminRepository;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.context.annotation.Bean;

@Configuration
@EnableWebSecurity
public class SecurityConfig {

    private final JpaUserDetailsService userDetailsService;
    private final AdminRepository adminRepository;

    @Value("\${app.security.require-login:true}")
    private boolean requireLogin;

    public SecurityConfig(JpaUserDetailsService userDetailsService, AdminRepository adminRepository) {
        this.userDetailsService = userDetailsService;
        this.adminRepository = adminRepository;
    }

    @Bean
    public Sha1PasswordEncoder passwordEncoder() 
    {
        return new Sha1PasswordEncoder();
    }
    
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(AbstractHttpConfigurer::disable);
        
        // Disable default logout handling in all cases, as we will manage it in AuthController
        http.logout(logout -> logout.disable());

        if (!requireLogin) {
            // If login is not required, permit all requests.
            http
                .authorizeHttpRequests(auth -> auth.anyRequest().permitAll())
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        } else {
            // If login is required, set up session-based security with our custom filter.
            SessionAuthFilter sessionAuthFilter = new SessionAuthFilter(adminRepository);
            http.addFilterBefore(sessionAuthFilter, UsernamePasswordAuthenticationFilter.class);

            AuthenticationEntryPoint apiEntryPoint = new HttpStatusEntryPoint(HttpStatus.UNAUTHORIZED);

            http            
                .authorizeHttpRequests(auth -> auth
                    .requestMatchers(
                        "/login", 
                        "/logout", 
                        "/",
                        "/index.html",
                        "/assets/**",
                        "/favicon.ico"
                    ).permitAll()
                    .requestMatchers(
                        "/graphiql/**", 
                        "/vendor/**"
                        ).permitAll() // Allow GraphiQL UI
                    .anyRequest().authenticated()
                )
                .userDetailsService(userDetailsService)
                .exceptionHandling(e -> e
                    // For API paths, return 401. For others, redirect to login.
                    .defaultAuthenticationEntryPointFor(
                        apiEntryPoint, new AntPathRequestMatcher("/graphql/**")
                    )
                );
        }

        return http.build();
    }
}

@Configuration
@ConditionalOnProperty(name = "spring.session.store-type", havingValue = "redis")
@EnableRedisHttpSession
class RedisSessionConfig {
    // This class is intentionally empty.
    // Its purpose is to conditionally enable Redis session management
    // based on the application properties.
}
JAVA;
    }

    private function generateCorsConfig() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package {$package}.config;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class CorsConfig {

    @Value("\${app.security.cors.allowed-origins:}")
    private String[] allowedOrigins;

    @Bean
    @ConditionalOnProperty(name = "app.security.cors.enabled", havingValue = "true")
    public WebMvcConfigurer corsConfigurer() {
        return new WebMvcConfigurer() {
            @Override
            public void addCorsMappings(CorsRegistry registry) {
                registry.addMapping("/**") // Apply to all endpoints
                        .allowedOrigins(allowedOrigins)
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true);
            }
        };
    }
}
JAVA;
    }
    
    private function generateSessionAuthFilter() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package {$package}.config;

import {$package}.model.entity.Admin;
import {$package}.model.repository.AdminRepository;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import jakarta.servlet.http.HttpSession;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.Collections;

public class SessionAuthFilter extends OncePerRequestFilter {

    private final AdminRepository adminRepository;

    public SessionAuthFilter(AdminRepository adminRepository) {
        this.adminRepository = adminRepository;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain)
            throws ServletException, IOException {

        HttpSession session = request.getSession(false);

        if (session != null && session.getAttribute("username") != null && session.getAttribute("password") != null) {
            String username = (String) session.getAttribute("username");
            String sessionPasswordHash = (String) session.getAttribute("password"); // This is sha1(password)

            // Only proceed if there is no existing authentication
            if (SecurityContextHolder.getContext().getAuthentication() == null) {
                adminRepository.findByUsername(username).ifPresent(admin -> {
                    // Re-create the single hash of the password from the database's double hash
                    // This logic is complex. A simpler way is to just trust the session hash.
                    // For this implementation, we'll validate the session hash against the user from DB.
                    
                    Sha1PasswordEncoder encoder = new Sha1PasswordEncoder();
                    String expectedSingleHash = encoder.sha1(encoder.sha1(admin.getPassword())); // This is incorrect, let's simplify

                    // We need to re-validate the session password.
                    // The password in DB is sha1(sha1(plain_password))
                    // The password in Session is sha1(plain_password)
                    // So, we hash the session password again and compare with DB password.
                    if (encoder.sha1(sessionPasswordHash).equals(admin.getPassword())) {
                        UsernamePasswordAuthenticationToken authToken = new UsernamePasswordAuthenticationToken(
                                username, null, Collections.singletonList(new SimpleGrantedAuthority("ROLE_USER")));
                        SecurityContextHolder.getContext().setAuthentication(authToken);
                    }
                });
            }
        }
        filterChain.doFilter(request, response);
    }
}
JAVA;
    }

    private function generateSha1PasswordEncoder() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.config;

import org.springframework.security.crypto.password.PasswordEncoder;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.math.BigInteger;

public class Sha1PasswordEncoder implements PasswordEncoder {

    @Override
    public String encode(CharSequence rawPassword) {
        // This replicates sha1(sha1(password))
        return sha1(sha1(rawPassword.toString()));
    }

    @Override
    public boolean matches(CharSequence rawPassword, String encodedPassword) {
        // The rawPassword is the plain text from the login form.
        // The encodedPassword is the double-hashed password from the database.
        // We must double-hash the raw password to match what's in the database.
        return encodedPassword.equals(encode(rawPassword));
    }

    public String sha1(String input) {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            byte[] messageDigest = md.digest(input.getBytes());
            BigInteger no = new BigInteger(1, messageDigest);
            String hashtext = no.toString(16);
            while (hashtext.length() < 40) { // SHA-1 is 40 chars long
                hashtext = "0" + hashtext;
            }
            return hashtext;
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}
JAVA;
    }

    private function generateUserDetailsService() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.service;

import $package.model.repository.AdminRepository;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;

@Service
public class JpaUserDetailsService implements UserDetailsService {

    private final AdminRepository adminRepository;

    public JpaUserDetailsService(AdminRepository adminRepository) {
        this.adminRepository = adminRepository;
    }

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return adminRepository.findByUsername(username)
                .map(admin -> {
                    // The password stored in the database is sha1(sha1(password)).
                    // Spring Security's session authentication will compare against the session's password, which is sha1(password).
                    // Therefore, we must provide the double-hashed password here for the initial login check to succeed.
                    return User.withUsername(admin.getUsername()).password(admin.getPassword()).roles("USER").build();
                })
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username: " + username));
    }
}
JAVA;
    }

    private function generateAdminEntity() {
        $package = $this->projectConfig['packageName'];
        // A simplified Admin entity based on auth.php and login.php logic
        return <<<JAVA
package $package.model.entity;

import jakarta.persistence.Column;
import jakarta.persistence.Entity;
import jakarta.persistence.Id;
import jakarta.persistence.Table;
import lombok.Data;

@Data
@Entity
@Table(name = "admin")
public class Admin {
    @Id
    @Column(name = "admin_id")
    private String adminId;
    private String username;
    private String password;
    private String name;
    private String email;
    private String phone;
    @Column(name = "admin_level_id")
    private String adminLevelId;
}
JAVA;
    }

    private function generateAdminRepository() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.model.repository;

import $package.model.entity.Admin;
import org.springframework.data.jpa.repository.JpaRepository;
import java.util.Optional;

public interface AdminRepository extends JpaRepository<Admin, String> {
    Optional<Admin> findByUsername(String username);
}
JAVA;
    }

    private function generateLoginRequestDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller.dto;
import lombok.Data;
@Data
public class LoginRequest {
    private String username;
    private String password;
}
JAVA;
    }

    private function generateLoginResponseDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller.dto;
import lombok.AllArgsConstructor;
import lombok.Data;
@Data
@AllArgsConstructor
public class LoginResponse {
    private boolean success;
    private String message;
}
JAVA;
    }

    private function generateAuthController() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller;

import $package.config.Sha1PasswordEncoder;
import $package.controller.dto.LoginRequest;
import $package.controller.dto.LoginResponse;
import $package.model.repository.AdminRepository;
import jakarta.servlet.http.HttpSession;
import jakarta.servlet.http.HttpServletRequest;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

@RestController
public class AuthController {

    @Value("\${app.security.require-login:true}")
    private boolean requireLogin;

    private final AdminRepository adminRepository;
    private final Sha1PasswordEncoder passwordEncoder;

    public AuthController(AdminRepository adminRepository, Sha1PasswordEncoder passwordEncoder) {
        this.adminRepository = adminRepository;
        this.passwordEncoder = passwordEncoder;
    }

    @PostMapping("/login")
    public ResponseEntity<LoginResponse> login(@RequestParam String username, @RequestParam String password, HttpSession session) {
        if (!requireLogin) {
            return ResponseEntity.ok(new LoginResponse(true, "Success"));
        }
        String singleHashedPassword = passwordEncoder.sha1(password);
        return adminRepository.findByUsername(username)
                .filter(admin -> admin.getPassword().equals(passwordEncoder.encode(password)))
                .map(admin -> {
                    session.setAttribute("username", admin.getUsername());
                    // Store the single-hashed password in the session for subsequent requests.
                    session.setAttribute("password", singleHashedPassword);
                    return ResponseEntity.ok(new LoginResponse(true, "Login successful"));
                })
                .orElse(ResponseEntity.status(HttpStatus.UNAUTHORIZED)
                        .body(new LoginResponse(false, "Invalid credentials")));
    }

    @RequestMapping(value = "/logout", method = {RequestMethod.GET, RequestMethod.POST})
    public ResponseEntity<LoginResponse> logout(HttpServletRequest request) {
        if (!requireLogin) {
            return ResponseEntity.ok(new LoginResponse(true, "Success"));
        }
        HttpSession session = request.getSession(false); // Get session only if it exists, don't create a new one
        if (session != null) {
            session.invalidate();
        }
        return ResponseEntity.ok(new LoginResponse(true, "Logout successful"));
    }
}
JAVA;
    }

    private function generateAppController() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ResponseBody;
import org.springframework.web.bind.annotation.RestController;
import org.springframework.core.io.Resource;
import org.springframework.core.io.ResourceLoader;
import com.fasterxml.jackson.databind.ObjectMapper;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.Collections;
import java.util.Map;

@RestController
public class AppController {

    private final ResourceLoader resourceLoader;
    private final ObjectMapper objectMapper;

    public AppController(ResourceLoader resourceLoader, ObjectMapper objectMapper) {
        this.resourceLoader = resourceLoader;
        this.objectMapper = objectMapper;
    }


    // Replicates available-language.php
    @GetMapping("/available-language")
    public Map<String, Object> getAvailableLanguages() {
        // This should ideally read from a file, but hardcoding for simplicity
        return Map.of(
            "default", "en",
            "supported", Map.of("en", "English", "id", "Indonesia")
        );
    }

    // Replicates available-theme.php
    @GetMapping("/available-theme")
    public Object[] getAvailableThemes() {
        // This should scan a directory, but hardcoding for simplicity
        return new Object[]{
            Map.of("name", "dark-blue", "title", "Dark Blue"),
            Map.of("name", "light-green", "title", "Light Green")
        };
    }

    // Replicates frontend-config.php
    @GetMapping(value = "/frontend-config", produces = "application/json")
    public Object getFrontendConfig() throws IOException {
        Resource resource = resourceLoader.getResource("classpath:frontend-config.json");
        String jsonContent = new String(Files.readAllBytes(Paths.get(resource.getURI())));
        return objectMapper.readValue(jsonContent, Object.class);
    }
    
    // Other endpoints like /user-profile, /settings etc. would go here
}
JAVA;
    }

    private function generateProfileUpdateRequestDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.controller.dto;

import lombok.Data;

@Data
public class ProfileUpdateRequest {
    private String name;
    private String email;
    private String gender;
    private String birthDay;
    private String phone;
}
JAVA;
    }

    private function getSchemaPartsForTable($tableName, $tableInfo) {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original column name
            if ($colInfo['isForeignKey']) {
                $refUcCamelName = ucfirst($this->camelCase($colInfo['references']));
                $fields .= "    $fieldName: $gqlType\n"; // Keep the ID field
                $fields .= "    {$colInfo['references']}: $refUcCamelName\n";
            } else {
                $fields .= "    $fieldName: $gqlType\n";
            }
        }

        // Input fields
        $inputFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $gqlType = $this->mapJavaTypeToGqlType($this->mapDbTypeToJavaType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName; // Use original column name
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $types = <<<GQL
type $ucCamelName {
$fields}

input {$ucCamelName}Input {
$inputFields}

type {$ucCamelName}Page {
    items: [$ucCamelName],
    total: Int,
    limit: Int,
    page: Int,
    totalPages: Int,
    hasNext: Boolean,
    hasPrevious: Boolean
}
GQL;

        $queries = "    {$camelName}(id: ID!): $ucCamelName\n";
        $queries .= "    {$pluralCamelName}(limit: Int, offset: Int, page: Int, size: Int, orderBy: [SortInput], filter: [FilterInput]): {$ucCamelName}Page\n";

        $mutations = "    create{$ucCamelName}(input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    update{$ucCamelName}(id: ID!, input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    delete{$ucCamelName}(id: ID!): Boolean\n";

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    private function generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields) {
        $typesString = implode("\n", $allSchemaParts);
        $queriesString = implode("", $allQueryFields);
        $mutationsString = implode("", $allMutationFields);

        return <<<GQL
enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Object
    operator: FilterOperator
}

$typesString

type Query {
$queriesString}

scalar Object

type Mutation {
$mutationsString}
GQL;
    }

    private function generateFilterInputDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.model.dto;

import lombok.Data;

@Data
public class FilterInput {
    private String field;
    private Object value;
    private String operator;
}
JAVA;
    }

    private function generateSortInputDto() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.model.dto;

import lombok.Data;

@Data
public class SortInput {
    private String field;
    private String direction;

    public String getDirection() {
        return (direction == null || direction.isEmpty()) ? "ASC" : direction;
    }
}
JAVA;
    }

    private function generateObjectScalar() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.config;

import graphql.language.ArrayValue;
import graphql.language.BooleanValue;
import graphql.language.FloatValue;
import graphql.language.IntValue;
import graphql.language.ObjectField;
import graphql.language.ObjectValue;
import graphql.language.StringValue;
import graphql.language.Value;
import graphql.schema.Coercing;
import graphql.schema.CoercingParseLiteralException;
import graphql.schema.CoercingParseValueException;
import graphql.schema.CoercingSerializeException;
import graphql.schema.GraphQLScalarType;
import java.util.stream.Collectors;

public class ObjectScalar implements Coercing<Object, Object> {

    public static final GraphQLScalarType INSTANCE = GraphQLScalarType.newScalar()
            .name("Object")
            .description("A custom scalar that can represent any JSON-like object.")
            .coercing(new ObjectScalar())
            .build();

    @Override
    public Object serialize(Object dataFetcherResult) throws CoercingSerializeException {
        return dataFetcherResult;
    }

    @Override
    public Object parseValue(Object input) throws CoercingParseValueException {
        return input;
    }

    @Override
    public Object parseLiteral(Object input) throws CoercingParseLiteralException {
        if (input instanceof StringValue) {
            return ((StringValue) input).getValue();
        } else if (input instanceof IntValue) {
            return ((IntValue) input).getValue();
        } else if (input instanceof FloatValue) {
            return ((FloatValue) input).getValue();
        } else if (input instanceof BooleanValue) {
            return ((BooleanValue) input).isValue();
        } else if (input instanceof ArrayValue) {
            return ((ArrayValue) input).getValues().stream().map(this::parseLiteral).collect(Collectors.toList());
        } else if (input instanceof ObjectValue) {
            return ((ObjectValue) input).getObjectFields().stream()
                    .collect(Collectors.toMap(ObjectField::getName, field -> parseLiteral(field.getValue())));
        }
        return null;
    }
}
JAVA;
    }

    private function generateGraphQlConfig() {
        $package = $this->projectConfig['packageName'];
        return <<<JAVA
package $package.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.graphql.execution.RuntimeWiringConfigurer;

@Configuration
public class GraphQlConfig {

    @Bean
    public RuntimeWiringConfigurer runtimeWiringConfigurer() {
        return wiringBuilder -> wiringBuilder.scalar(ObjectScalar.INSTANCE);
    }
}
JAVA;
    }
}