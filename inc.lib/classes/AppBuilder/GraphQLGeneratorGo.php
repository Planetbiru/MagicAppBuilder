<?php

namespace AppBuilder;

use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorGo` class is a tool to automatically generate a complete Go (Golang) GraphQL API 
 * from a JSON file that defines database entities. It inspects the schema to understand tables, columns, 
 * primary keys, and foreign key relationships. Based on this analysis, it produces Go code for models (structs), 
 * data access logic using GORM, GraphQL resolvers, and schema files, along with a comprehensive API manual.
 * This class streamlines the process of scaffolding a GraphQL API in Go, reducing manual effort and ensuring 
 * consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorGo extends GraphQLGeneratorBase // NOSONAR
{
    /**
     * @var array<string, string> Project configuration for go.mod and package structure.
     */
    private $projectConfig = array();

    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use caching (placeholder for Go).
     * @param array $projectConfig Project configuration details.
     * @param bool $requireLogin Whether the generated application should require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'moduleName' => 'planet-app',
            'goVersion' => '1.21',
            'appName' => 'GraphQL App',
            'appDescription' => 'GraphQL API generated by MagicAppBuilder',
            'requireLogin' => $requireLogin
        ), $projectConfig);

        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoType($dbType, $length = null) // NOSONAR
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int32';
        }
        return 'string'; // Default fallback
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoTypeAsModel($dbType, $length = null) // NOSONAR
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int32';
        }
        return 'string'; // Default fallback
    }

    /**
     * Main function to generate all files for the Go project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();

        // 1. Go Module file
        $files[] = ['name' => 'go.mod', 'content' => $this->generateGoMod()];

        // 2. GraphQL setup
        $files[] = ['name' => 'schema/schema.graphqls', 'content' => $this->generateCombinedSchema()];

        // 3. Models (Entities and DTOs)
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $files[] = ['name' => 'model/' . $this->camelCaseToSnakeCase($tableName) . '.go', 'content' => $this->generateModelFile($tableName, $tableInfo)];
        }

        // 4. Resolvers
        
        $resolvers = $this->generateResolvers();

        $files[] = ['name' => 'resolver/app_resolver_root.go', 'content' => $this->generateResolverRoot()];

        $files = array_merge($files, $resolvers);

        // 5. Security and Auth
        $files[] = ['name' => 'handler/auth.go', 'content' => $this->generateAuthGo()];

        // 6. Manual
        $files[] = ['name' => 'manual.md', 'content' => $this->generateManual()];

        return $files;
    }

    /**
     * Generates the root GraphQL resolver interface and implementation.
     *
     * The generated code includes:
     * - `ResolverRoot` interface: Defines contract for all entity resolvers.
     * - `RootResolver` struct: Stores shared dependencies such as the DB
     *   connection and resolver instances.
     * - `NewRootResolver`: Instantiates a root resolver and initializes all
     *   table-specific query resolvers.
     *
     * This acts as the central point that gqlgen / graphql-go uses to
     * resolve all queries and mutations.
     *
     * @return string The generated Go source code for resolver/root_resolver.go
     */
    private function generateResolverRoot()
    {
        $types1 = [];
        $types2 = [];
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);

            $pkType = '';
            foreach($tableInfo['columns'] as $col)
            {
                if($col['isPrimaryKey'])
                {
                    $pkType = $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']);
                    break;
                }
            }
            $types1[] = "\t{$pascalName}(ctx context.Context, args struct{ ID $pkType }) (*{$pascalName}Resolver, error)";
            $types2[] = "\t*{$pascalName}QueryResolver";
            $types3[] = "\troot.{$pascalName}QueryResolver = New{$pascalName}QueryResolver(root)";
        }
        $code1 = implode("\r\n", $types1);
        $code2 = implode("\r\n", $types2);
        $code3 = implode("\r\n", $types3);
        return <<<GO
package resolver

import (
	"context"
	"database/sql"
)

type ResolverRoot interface {
	DBConnection() *sql.DB
$code1
}

func (r *RootResolver) DBConnection() *sql.DB {
	return r.db
}

type RootResolver struct {
	db *sql.DB
$code2
}

func NewRootResolver(db *sql.DB) *RootResolver {
	root := &RootResolver{db: db}
$code3
    return root
}
GO;
    }

    /**
     * Generates resolver files for every analyzed database table.
     *
     * Each resolver file includes:
     * - Type definitions
     * - Query resolvers
     * - Mutation resolvers (if implemented)
     * - Field resolvers for foreign-key relationships
     *
     * @return array List of generated resolver files, each containing filename and content.
     */
    private function generateResolvers()
    {
        $resolvers = [];
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $resolvers[] = ['name' => "resolver/{$tableName}.go", 'content' => $this->generateResolver($tableName, $tableInfo)];
        }
        return $resolvers;
    }

    /**
     * Generates the complete resolver file for a specific database table.
     *
     * A resolver file contains:
     * - Required import statements
     * - Type resolver definitions
     * - Field-level resolver methods
     * - Query resolvers (single and paginated list)
     * - Foreign key relationship resolvers
     *
     * @param string $tableName The database table name.
     * @param array $tableInfo  Metadata describing the table structure.
     *
     * @return string The complete Go resolver source file for this entity.
     */
    private function generateResolver($tableName, $tableInfo)
    {
        $contents = [];
        $contents[] = "package resolver";
        $contents[] = "";
        $contents[] = $this->generateResolverImport($tableInfo);
        $contents[] = $this->generateResolverType($tableName);
        $contents[] = $this->generateResolverQuery($tableName, $tableInfo);
        $contents[] = $this->generateResolverMutation($tableName, $tableInfo);

        return implode("\r\n", $contents);
    }

    /**
     * Generates the import section for a resolver file.
     *
     * Imports are determined dynamically based on:
     * - Project module name
     * - Whether the table uses UUID auto-generation
     * - Whether PostgreSQL-specific behavior may be needed
     *
     * @param array $tableInfo Metadata describing the table structure.
     *
     * @return string A formatted import block.
     */
    private function generateResolverImport($tableInfo)
    {
        $packageName = $this->projectConfig['moduleName'];
        $libraries = [];
        $libraries[] = "\t\"context\"";
        $libraries[] = "\t\"database/sql\"";
        $libraries[] = "\t\"errors\"";
        $libraries[] = "\t\"fmt\"";
        $libraries[] = "\t\"{$packageName}/config\"";
        $libraries[] = "\t\"{$packageName}/constant\"";
        $libraries[] = "\t\"{$packageName}/input\"";
        $libraries[] = "\t\"{$packageName}/model\"";
        $libraries[] = "\t\"{$packageName}/util\"";
        $libraries[] = "\t\"strings\"";
        $libraries[] = "\t\"time\"";

        $autogenerated = false;
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey'] && $col['primaryKeyValue'] == 'autogenerated') {
                $autogenerated = true;
                break;
            }
        }

        if($autogenerated)
        {
            $libraries[] = "\r\n\t\"github.com/google/uuid\"";
        }
        
        return "import(\r\n".implode("\r\n", $libraries)."\r\n)\r\n";
        
    }

    /**
     * Generates Go type declarations for an entity resolver.
     *
     * Includes:
     * - Query resolver struct for entity-level operations
     * - Item resolver struct for field-level access
     * - Page resolver struct for paginated list responses
     *
     * @param string $tableName The database table name.
     *
     * @return string Resolver type definitions as Go source code.
     */
    private function generateResolverType($tableName)
    {
        $resolverName = $this->pascalCase($tableName);
        $resolverNamePlural = $this->pluralize($resolverName);
        $contents = [];
        $contents[] = "// {$resolverName}QueryResolver handles all queries and mutations for the {$resolverName} entity.
type {$resolverName}QueryResolver struct {
	root ResolverRoot
}

// {$resolverName}Resolver contains data for a single {$resolverName} object.
type {$resolverName}Resolver struct {
	m *model.{$resolverName}
	r *{$resolverName}QueryResolver
}

// {$resolverName}PageResolver contains data for a page/list of {$resolverNamePlural}.
type {$resolverName}PageResolver struct {
	items      []*{$resolverName}Resolver
	total      int32
	limit      int32
	page       int32
	totalPages int32
	hasNext    bool
	hasPrev    bool
}
";
        return implode("\r\n", $contents);
    }
    
    /**
     * Formats an array of method description strings by aligning the text
     * that appears before the specified delimiter. This creates a neatly
     * aligned column-style output for improved readability.
     *
     * Each element in the $methods array is expected to contain the $search
     * delimiter. The part before the delimiter will be padded with spaces
     * so that all delimiters align vertically.
     *
     * Example:
     *     Input:
     *         [
     *             "getId => Get the ID",
     *             "getFullName => Get full name"
     *         ]
     *
     *     Output (aligned):
     *         [
     *             "getId       => Get the ID",
     *             "getFullName => Get full name"
     *         ]
     *
     * @param string[] $methods
     *     The list of method strings to be formatted.
     *
     * @param string $search
     *     The delimiter used to split the method name and its description.
     *
     * @return string[]
     *     A new array of formatted strings with aligned delimiters.
     */
    private function prettifyMethods($methods, $search)
    {
        if(!isset($methods) || empty($methods))
        {
            return array();
        }
        $max = 1;
        foreach($methods as $method)
        {
            $arr = explode($search, $method, 2);
            if(count($arr) == 2)
            {
                $length = strlen(rtrim($arr[0], " "));
                if($max < $length)
                {
                    $max = $length;
                }
            }
        }
        foreach($methods as $index => $method)
        {
            $arr = explode($search, $method, 2);
            if(count($arr) == 2)
            {
                $methods[$index] = sprintf("%-{$max}s %s%s", rtrim($arr[0], " "), $search, $arr[1]);
            }
        }
        return $methods;
    }

    /**
     * Generates GraphQL query resolver methods for a database entity.
     *
     * The generated methods include:
     * - Field resolver methods for every column
     * - Relationship resolvers for foreign keys
     * - A single-item query (fetch by primary key)
     * - A paginated list query with filtering and sorting
     *
     * Pagination, filtering, and sorting are delegated to the query builder,
     * while this resolver focuses on translating the data into model objects.
     *
     * @param string $tableName The database table name.
     * @param array $tableInfo  Metadata describing the table structure.
     *
     * @return string Query resolver implementations as Go source code.
     */
    private function generateResolverQuery($tableName, $tableInfo) // NOSONAR
    {
        $pascalName = $this->pascalCase($tableName);
        $pascalNamePlural = $this->pluralize($pascalName);
        $singleResolver = "{$pascalName}Resolver";
        $pageResolver = "{$pascalName}PageResolver";

        $methods = [];
        $columnInfo = [];
        $maxLength = 1;
        $pkName = '';
        $columNames = [];
        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($maxLength < strlen($columnName))
            {
                $maxLength = strlen($columnName);
            }
            if($col['isPrimaryKey'] && empty($pkName))
            {
                $pkName = $columnName;
                $pkType = $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']);
            }
            $columnInfo[] = [
                //"name" => ucfirst($columnName),
                "name" => $this->pascalCase($columnName),
                "type" => $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']),
                "pointer" => $col['isPrimaryKey']
            ];
            $columNames[] = $columnName;
        }
        foreach($columnInfo as $info)
        {
            $goName = $this->goName($this->pascalCase($info['name']));
            $methods[] = sprintf("func (r *$singleResolver) %s() *%s { return %sr.m.$goName }", $info['name'], $info['type'], $info['pointer'] ? '&' : '');
        }
        $methods = $this->prettifyMethods($methods, "{ return");
        $entityMethods = implode("\r\n", $methods);

        $addCols = [];

        $relMethods = [];

        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($col['isForeignKey'])
            {
                $colType = $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']);
                $relEntity = $col['references'];
                $pascalEntityName = $this->pascalCase($relEntity);
                $fkName = $this->goName($this->pascalCase($columnName));
                $relMethods[] = "
// $pascalEntityName resolves the related $relEntity for this $pascalName.
func (r *$singleResolver) {$pascalEntityName}(ctx context.Context) (*{$pascalEntityName}Resolver, error) {
	if r.m.{$fkName} == nil {
		return nil, nil
	}
	return r.r.root.$pascalEntityName(ctx, struct{ ID $colType } { ID: *r.m.{$fkName} })
}
";
                
            }
            $goName = $this->goName($this->pascalCase($columnName));
            $addCols[] = "\t\t\t&m.{$goName},";
        }

        $relationMethods = implode("", $relMethods);
        
        $addresOfColumns1 = implode("\r\n", $addCols);
        $addresOfColumns1 = str_replace("\t\t\t", "\t\t", $addresOfColumns1);
        $addresOfColumns2 = implode("\r\n", $addCols);

        $columnList = implode(", ", $columNames);
        
        $listMethods = <<<GO
func (r *{$pageResolver}) Items() *[]*$singleResolver { return &r.items }
func (r *{$pageResolver}) Total() *int32 { return &r.total }
func (r *{$pageResolver}) Limit() *int32 { return &r.limit }
func (r *{$pageResolver}) Page() *int32 { return &r.page }
func (r *{$pageResolver}) TotalPages() *int32 { return &r.totalPages }
func (r *{$pageResolver}) HasNext() *bool { return &r.hasNext }
func (r *{$pageResolver}) HasPrevious() *bool { return &r.hasPrev }
GO;
        $listMethodsArr = explode("\n", $listMethods);
        $listMethodsArr = $this->prettifyMethods($listMethodsArr, "{ return");
        $listMethods = implode("\n", $listMethodsArr);
        
        return <<<GO
// New{$pascalName}QueryResolver creates a new resolver for {$pascalName} queries.
func New{$pascalName}QueryResolver(root ResolverRoot) *{$pascalName}QueryResolver {
	return &{$pascalName}QueryResolver{root: root}
}

// Getter methods for $pascalName properties
$entityMethods
$relationMethods
// Methods for $pascalNamePlural
$listMethods

// {$pascalName} fetches a single {$tableName} by its ID.
func (r *{$pascalName}QueryResolver) {$pascalName}(ctx context.Context, args struct{ ID $pkType }) (*$singleResolver, error) {
	
	tableName := "{$tableName}"
	columns := "$columnList"
	primaryKey := "{$pkName}"
	
	sqlQuery := fmt.Sprintf("SELECT %s FROM %s WHERE %s = ?", columns, tableName, primaryKey)
	row := r.root.DBConnection().QueryRowContext(ctx, sqlQuery, args.ID)
	m := model.{$pascalName}{}
	err := row.Scan(
$addresOfColumns1
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &$singleResolver{m: &m, r: r}, nil
}

// {$pascalNamePlural} fetches a paginated list of {$pascalNamePlural}.
func (r *{$pascalName}QueryResolver) {$pascalNamePlural}(ctx context.Context, args struct {
	Limit   *int32
	Offset  *int32
	Page    *int32
	Size    *int32
	OrderBy *[]*input.SortInput
	Filter  *[]*input.FilterInput
}) (*{$pageResolver}, error) {

	tableName := "{$tableName}"
	columns := "$columnList"

	// Pagination
	limit, page, offset := input.GetPagination(input.PaginationArgs{
		Limit:  args.Limit,
		Offset: args.Offset,
		Page:   args.Page,
		Size:   args.Size,
	})

	// Build query

	whereSQL, orderSQL, params := input.BuildQuery(args.Filter, args.OrderBy, config.IsPostgres)
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM %s %s", tableName, whereSQL)

	// Count total items
	var total int32
	err := r.root.DBConnection().QueryRowContext(ctx, countQuery, params...).Scan(&total)
	if err != nil {
		return nil, err
	}

	// Fetch items
	queryParams := append(params, limit, offset)
	queryQuery := fmt.Sprintf("SELECT %s FROM %s %s %s LIMIT ? OFFSET ?", columns, tableName, whereSQL, orderSQL)
	rows, err := r.root.DBConnection().QueryContext(ctx, queryQuery, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := []*$singleResolver{}
	for rows.Next() {
		m := model.{$pascalName}{}
		err := rows.Scan(
$addresOfColumns2
		)
		if err != nil {
			return nil, err
		}
		items = append(items, &$singleResolver{m: &m, r: r})
	}

	totalPages := int32(0)
	if total > 0 {
		totalPages = (total + limit - 1) / limit
	}

	return &{$pageResolver}{
		items:      items,
		total:      total,
		limit:      limit,
		page:       page,
		totalPages: totalPages,
		hasNext:    page < totalPages,
		hasPrev:    page > 1,
	}, nil
}
GO;
    }

    /**
     * Generates Go GraphQL resolver mutation code for the specified database table.
     *
     * This method analyzes table metadata (columns, primary key, auto-increment,
     * auto-generated fields, backend-handled fields, etc.) and produces complete
     * mutation implementations for:
     * - Create
     * - Update
     * - Delete
     * - ToggleActive
     *
     * The generated Go code includes:
     * - Input struct definitions
     * - Field type mappings based on database column types
     * - INSERT and UPDATE query builders
     * - Automatic handling for backend-managed fields such as:
     *   - Creation time (timeCreate)
     *   - Update time (timeEdit)
     *   - Creation IP (ipCreate)
     *   - Update IP (ipEdit)
     *   - Admin ID for creation (adminCreate)
     *   - Admin ID for update (adminEdit)
     * - Support for UUID auto-generation when required
     * - Dynamic update field building based on non-null input values
     *
     * @param string $tableName
     *     Name of the database table to generate resolver mutations for.
     *
     * @param array $tableInfo
     *     Table structure information, including:
     *     - columns: array of column definitions
     *     - primary key properties
     *     - auto-increment or auto-generated indicators
     *
     * @return string
     *     A complete Go-language source code block containing all mutation
     *     resolvers for the specified table, ready to be written into a .go file.
     *
     * @throws Exception
     *     Throws an exception if required metadata is missing or inconsistent.
     */
    private function generateResolverMutation($tableName, $tableInfo) // NOSONAR
    {
        $pascalName = $this->pascalCase($tableName);
        $activeField = $this->activeField;
        $activeFieldPascal = $this->pascalCase($this->activeField);
        $pkName = '';
        $colInfo = [];
        $maxLength = 1;
        $pkType = '';
        $getLastId = '';
        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($col['isPrimaryKey'] && empty($pkName))
            {
                $pkName = $columnName;
                $pkType = $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']);
            }
            
            $colInfo[] = [
                'name' => $this->goName($this->pascalCase($columnName)),
                'columnName' => $columnName,
                'type' => $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length'])
            ];
            if($maxLength < strlen($columnName))
            {
                $maxLength = strlen($columnName);
            }
        }
        $autoincrement = false;
        $autogenerated = false;
        $columnToInsert = [];
        $updateCode = [];
        $toggleCode = [];
        $placeholderUpdate = [];
        $par = [];
        $paramInsert = [];
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        $autogeneratedCol = '';
        $primaryKeyCol = '';
        $primaryKeyValue = '';
        foreach ($tableInfo['columns'] as $colName => $col) {
            if ($col['isPrimaryKey'])
            {
                $primaryKeyCol = $colName;
                $primaryKeyValue = $col['primaryKeyValue'];
            }
            if ($col['isPrimaryKey'] && ($col['primaryKeyValue'] == 'autoincrement') && !$autoincrement) {
                $autoincrement = true;
                continue;
            }
            if ($col['isPrimaryKey'] && ($col['primaryKeyValue'] == 'autogenerated') && !$autogenerated) {
                $autogenerated = true;
                $autogeneratedCol = $colName;
                continue;
            }
            if(in_array($colName, $backendHandledColumnNames))
            {
                continue;
            }
            if ($col['isPrimaryKey'])
            {
                continue;
            }
            $gn = $this->goName($this->pascalCase($colName));
            $columnToInsert[] = $colName;
            $placeholderUpdate[] = "?";
            $par[] = "\tparams = append(params, args.Input.".$gn.")";
            $paramInsert[] = "\tfields = append(fields, \"{$colName}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, args.Input.".$gn.")\r\n";

            $updateCode[] = <<<GO
    if args.Input.{$gn} != nil {
        fields = append(fields, "{$colName} = ?")
        params = append(params, *args.Input.{$gn})
    }

GO;
        }
        $entityColumns = [];
        foreach ($tableInfo['columns'] as $colName => $col) {
            $entityColumns[] = $colName;
        }
        $tp = [];

        $toggleCode[] = <<<GO
    fields = append(fields, "{$activeField} = ?")
    params = append(params, args.{$activeFieldPascal})

GO;

        foreach($this->backendHandledColumns as $k=>$v)
        {
            if(($k == 'timeCreate' || $k == 'timeEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($placeholderUpdate, "?");
                array_push($par, "\tparams = append(params, time.Now().Format(constant.DateTimeFormat))"); 
                if($k == 'timeEdit')
                {
                    $updateCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, time.Now().Format(constant.DateTimeFormat))

GO;
                    $toggleCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, time.Now().Format(constant.DateTimeFormat))

GO;
                }
                $paramInsert[] = "\tfields = append(fields, \"{$v['columnName']}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, time.Now().Format(constant.DateTimeFormat))\r\n";
            }
            if(($k == 'ipCreate' || $k == 'ipEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($placeholderUpdate, "?");
                array_push($par, "\tparams = append(params, ctx.Value(constant.RemoteAddr).(string))"); 
                if($k == 'ipEdit')
                {
                    $updateCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.RemoteAddr).(string))

GO;
                    $toggleCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.RemoteAddr).(string))

GO;
                }
                $paramInsert[] = "\tfields = append(fields, \"{$v['columnName']}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, ctx.Value(constant.RemoteAddr).(string))\r\n";
            }
            if(($k == 'adminCreate' || $k == 'adminEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($placeholderUpdate, "?");
                array_push($par, "\tparams = append(params, ctx.Value(constant.SessionAdminId).(string))"); 
                if($k == 'adminEdit')
                {
                    $updateCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.SessionAdminId).(string))

GO;
                    $toggleCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.SessionAdminId).(string))

GO;
                }
                $paramInsert[] = "\tfields = append(fields, \"{$v['columnName']}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, ctx.Value(constant.SessionAdminId).(string))\r\n";
            }
        }

        $tp[] = "{$this->activeField} = ?";

        $uuid = "";
        $goCol = $this->goName($this->camelCase($primaryKeyCol));
        if($autogenerated)
        {
            array_unshift($columnToInsert, $autogeneratedCol);
            array_unshift($placeholderUpdate, "?");
            array_unshift($paramInsert, "\tfields = append(fields, \"{$autogeneratedCol}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, id)\r\n");
            $uuid = "\r\n\tid := uuid.New().String()\r\n";
        }
        else if($autoincrement)
        {
            $getLastId = "	var insertId int64
	insertId, err = result.LastInsertId()
    if err != nil {
        return nil, errors.New(util.T(ctx, \"failed_to_get_last_insert_id\", err))
    } else {
		id = fmt.Sprintf(\"%v\", insertId)
	}
";
        }
        else
        {
            $getLastId = "";
            $uuid = "\r\n\tid := \"\"
    if args.Input.{$goCol} != nil {
        id = *args.Input.{$goCol}
    }";
        }

        if($primaryKeyValue == 'manual-all')
        {
            array_unshift($paramInsert, "\tfields = append(fields, \"{$primaryKeyCol}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, *args.Input.$goCol)\r\n");

            $returnUpdateCodes = "    if args.Input.$goCol != nil && *args.Input.$goCol != args.ID {
		query = fmt.Sprintf(\"UPDATE %s SET %s = ? WHERE %s = ?\", tableName, primaryKey, primaryKey)
		_, err = r.root.DBConnection().ExecContext(ctx, query, args.Input.$goCol, args.ID)
		if err != nil {
			return nil, errors.New(util.T(ctx, \"failed_to_update_item\", tableName, err))
		}
		return r.$pascalName(ctx, struct{ ID $pkType }{ID: *args.Input.$goCol})
	} else {
		return r.$pascalName(ctx, struct{ ID $pkType }{ID: args.ID})
	}";
        }
        else
        {
            $returnUpdateCodes = "    return r.{$pascalName}(ctx, struct{ ID $pkType }{ID: args.ID})";
        }

        $paramSet = implode("\r\n", $paramInsert);
        $updateCodes = implode("\r\n", $updateCode);
        $toggleCodes = implode("\r\n", $toggleCode);

        $defs = [];
        foreach($colInfo as $info)
        {
            if(in_array($info['columnName'], $backendHandledColumnNames))
            {
                continue;
            }
            $defs[] = sprintf("\t%-{$maxLength}s *%s", $info['name'], $info['type']);
        }
        $typeDefinitions = implode("\r\n", $defs);

        $activeField = $this->activeField;

        return <<<GO
// --- Mutations ---

type {$pascalName}Input struct {
$typeDefinitions
}

// Create{$pascalName} creates a new {$tableName}.
func (r *{$pascalName}QueryResolver) Create{$pascalName}(ctx context.Context, args struct{ Input {$pascalName}Input }) (*{$pascalName}Resolver, error) {

	tableName := "{$tableName}"
$uuid
    var fields []string
    var placeholders []string
    var params []interface{}

$paramSet

	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)", tableName, strings.Join(fields, ", "), strings.Join(placeholders, ", "))
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, errors.New(util.T(ctx, "failed_to_create_item", tableName, err))
	}
$getLastId	return r.{$pascalName}(ctx, struct{ ID $pkType }{ID: id})
}

// Update{$pascalName} updates an existing {$tableName}.
func (r *{$pascalName}QueryResolver) Update{$pascalName}(ctx context.Context, args struct {
	ID    string
	Input {$pascalName}Input
}) (*{$pascalName}Resolver, error) {

	tableName := "{$tableName}"
	primaryKey := "{$pkName}"

	var fields []string
	var params []interface{}

$updateCodes
    params = append(params, args.ID)

	if len(fields) == 0 {
		return nil, errors.New(util.T(ctx, "no_fields_to_update"))
	}

	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?", tableName, strings.Join(fields, ", "), primaryKey)
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, errors.New(util.T(ctx, "failed_to_update_item", tableName, err))
	}
$returnUpdateCodes
}

// Delete{$pascalName} deletes a {$tableName} by its ID.
func (r *{$pascalName}QueryResolver) Delete{$pascalName}(ctx context.Context, args struct{ ID $pkType }) (bool, error) {

	tableName := "{$tableName}"
	primaryKey := "{$pkName}"

	sqlQuery := fmt.Sprintf("DELETE FROM %s WHERE %s = ?", tableName, primaryKey)

	result, err := r.root.DBConnection().ExecContext(ctx, sqlQuery, args.ID)
	if err != nil {
		return false, errors.New(util.T(ctx, "failed_to_delete_item", tableName, err))
	}

	rowsAffected, err := result.RowsAffected()
	if err != nil {
		return false, errors.New(util.T(ctx, "failed_to_check_rows_affected", err))
	}
	if rowsAffected == 0 {
		return false, errors.New(util.T(ctx, "no_item_found_with_id", tableName, args.ID))
	}

	return true, nil
}

// Toggle{$pascalName}Active changes the active status of a {$tableName}.
func (r *{$pascalName}QueryResolver) Toggle{$pascalName}Active(ctx context.Context, args struct {
	ID $pkType
	{$activeFieldPascal} bool
}) (*{$pascalName}Resolver, error) {
	tableName := "{$tableName}"
	primaryKey := "{$pkName}"
	activeField := "{$activeField}"

    var fields []string
	var params []interface{}

$toggleCodes
    params = append(params, args.ID)

	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?", tableName, strings.Join(fields, ", "), primaryKey)
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, errors.New(util.T(ctx, "failed_to_change_status", tableName, activeField, err))
	}
	return r.{$pascalName}(ctx, struct{ ID $pkType }{ID: args.ID})
}
GO;
    }

    /**
     * Generates the content for the go.mod file.
     *
     * @return string The content for go.mod.
     */
    public function generateGoMod()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $goVersion = $this->projectConfig['goVersion'];

        return <<<MOD
module $moduleName

go 1.24.0

require (
	github.com/go-sql-driver/mysql v1.9.3
	github.com/google/uuid v1.6.0
	github.com/gorilla/sessions v1.4.0
	github.com/graph-gophers/graphql-go v1.8.0
	github.com/joho/godotenv v1.5.1
	modernc.org/sqlite v1.40.1
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/dustin/go-humanize v1.0.1 // indirect
	github.com/gorilla/securecookie v1.1.2 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/ncruces/go-strftime v0.1.9 // indirect
	github.com/remyoudompheng/bigfft v0.0.0-20230129092748-24d4a6f8daec // indirect
	golang.org/x/exp v0.0.0-20250620022241-b7579e27df2b // indirect
	golang.org/x/sys v0.36.0 // indirect
	modernc.org/libc v1.66.10 // indirect
	modernc.org/mathutil v1.7.1 // indirect
	modernc.org/memory v1.11.0 // indirect
)

MOD;
    }

    /**
     * Converts a given name into a Go-style exported field name.
     *
     * This method first transforms the input into PascalCase, ensuring that
     * the generated name follows Go's exported identifier convention.
     * Additionally, it normalizes any trailing "Id" into the Go-preferred "ID".
     *
     * Examples:
     * - "user_id"   → "UserID"
     * - "adminName" → "AdminName"
     * - "roleId"    → "RoleID"
     *
     * @param string $name The original column or field name.
     * @return string The transformed Go-style field name.
     */
    private function goName($name)
    {
        $name = $this->pascalCase($name);
        if(PicoStringUtil::endsWith($name, 'Id'))
        {
            $name = substr($name, 0, strlen($name) - 2).'ID';
        }
        return $name;
    }

    /**
     * Generates a model file (struct) for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the model file.
     */
    private function generateModelFile($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $structFields = "";
        $fieldNames = [];
        $fieldTypes = [];
        $maxLength = 1;
        $index = 0;
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $goType = $this->mapDbTypeToGoTypeAsModel($colInfo['type'], $colInfo['length']);
            $fieldName = $this->goName($colName);
            if(strlen($fieldName) > $maxLength)
            {
                $maxLength = strlen($fieldName);
            }

            if (!$colInfo['isPrimaryKey']) {
                $goType = "*".$goType;
            }

            $fieldNames[$index] = $fieldName;
            $fieldTypes[$index] = $goType;
            $index++;
        }
        foreach($fieldNames as $index => $fieldName)
        {
            $structFields .= sprintf("\t%-{$maxLength}s %s\r\n", $fieldName, $fieldTypes[$index]);
        }


        return <<<GO
package model

// $pascalName represents the $tableName table.
type $pascalName struct {
$structFields}
GO;
    }

    /**
     * Generates the resolver.go file.
     *
     * @return string The content of resolver.go.
     */
    public function generateResolverGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package graph

import (
    "{$moduleName}/config"
    "gorm.io/gorm"
)

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

type Resolver struct{
    DB *gorm.DB
    Cfg *config.Config
}
GO;
    }

    /**
     * Generates the combined GraphQL schema file.
     *
     * @return string The content of schema.graphqlss.
     */
    private function generateCombinedSchema()
    {
        $allTypes = "";
        $allQueries = "";
        $allMutations = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allTypes .= $schemaParts['types'] . "\n";
            $allQueries .= $schemaParts['queries'] . "\n";
            $allMutations .= $schemaParts['mutations'] . "\n";
        }

        return <<<GQL
scalar Any

enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Any
    operator: FilterOperator
}

$allTypes

type Query {
$allQueries
}

type Mutation {
$allMutations
}
GQL;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $camelName = $this->camelCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $typeFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName;
            $typeFields .= "    $fieldName: $gqlType\n";

            if ($colInfo['isForeignKey']) {
                $refPascalName = $this->pascalCase($colInfo['references']);
                $refFieldName = $colInfo['references'];
                $typeFields .= "    $refFieldName: $refPascalName\n";
            }
        }

        // Input fields
        $inputFields = "";
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            $gqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName;
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $pkGqlType = 'String!';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($col['type'], $col['length'])) . '!';
                break;
            }
        }

        $types = <<<GQL
type $pascalName {
$typeFields}

input {$pascalName}Input {
$inputFields}

type {$pascalName}Page {
    items: [$pascalName]
    total: Int
    page: Int
    limit: Int
    totalPages: Int
    hasNext: Boolean
    hasPrevious: Boolean
}
GQL;
        $camelMethodName = $camelName;
        $pluralMethodName = $pluralCamelName;

        $queries = "    $camelMethodName(id: $pkGqlType): $pascalName\n";
        $queries .= "    $pluralMethodName(limit: Int, offset: Int, page: Int, orderBy: [SortInput], filter: [FilterInput]): {$pascalName}Page\n";

        $mutations = "    create{$pascalName}(input: {$pascalName}Input!): $pascalName\n";
        $mutations .= "    update{$pascalName}(id: $pkGqlType, input: {$pascalName}Input!): $pascalName\n";
        $mutations .= "    delete{$pascalName}(id: $pkGqlType): Boolean!\n";

        if ($tableInfo['hasActiveColumn']) {
            $activeField = $this->camelCase($this->activeField);
            $mutations .= "    toggle{$pascalName}Active(id: {$pkGqlType}, $activeField: Boolean!): $pascalName\n";
        }

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Generates the auth.go file for login/logout logic.
     *
     * @return string The content of auth.go.
     */
    public function generateAuthGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package handler

import (
	"crypto/sha1"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"{$moduleName}/constant"
	"log"
	"net/http"
	"strings"

	"github.com/gorilla/sessions"
)

type AuthHandler struct {
	DB    *sql.DB
	Store sessions.Store
}

// doubleSha1 calculates sha1(sha1(password)).
func doubleSha1(input string) string {
	h1 := sha1.New()
	h1.Write([]byte(input))
	step1 := hex.EncodeToString(h1.Sum(nil))

	h2 := sha1.New()
	h2.Write([]byte(step1))
	return hex.EncodeToString(h2.Sum(nil))
}

// singleSha1 calculates sha1(password) to be stored in the session.
func singleSha1(input string) string {
	h := sha1.New()
	h.Write([]byte(input))
	return hex.EncodeToString(h.Sum(nil))
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// === CONTENT TYPE VALIDATION ===
	ct := r.Header.Get("Content-Type")

	if ct == "" {
		h.respondAuthError(w, "Invalid content type")
		return
	}

	// multipart/form-data
	if strings.HasPrefix(ct, "multipart/form-data") {
		if err := r.ParseMultipartForm(10 << 20); err != nil { // 10 MB
			h.respondAuthError(w, "Invalid multipart form")
			return
		}
	} else if strings.HasPrefix(ct, "application/x-www-form-urlencoded") {
		if err := r.ParseForm(); err != nil {
			h.respondAuthError(w, "Invalid urlencoded form")
			return
		}
	} else {
		h.respondAuthError(w, "Unsupported content type: "+ct)
		return
	}

	// Now FormValue works
	username := r.FormValue("username")
	password := r.FormValue("password")

	if username == "" || password == "" {
		h.respondAuthError(w, "Invalid credentials")
		return
	}

	// Fetch full user, like PHP: SELECT * FROM admin WHERE username = :username
	var dbAdminId, dbUsername, dbPassword string
	err := h.DB.QueryRow(
		"SELECT admin_id, username, password FROM admin WHERE username = ?",
		username,
	).Scan(&dbAdminId, &dbUsername, &dbPassword)

	if err != nil {
		if err != sql.ErrNoRows {
			log.Printf("Login database error: %v", err)
		}
		h.respondAuthError(w, "Invalid credentials")
		return
	}

	// Compare sha1(sha1(password))
	if doubleSha1(password) != dbPassword {
		h.respondAuthError(w, "Invalid credentials")
		return
	}

	// Success -> save session
	session, _ := h.Store.Get(r, constant.SessionKey)
	session.Values[constant.SessionUsername] = dbUsername
	session.Values[constant.SessionPassword] = singleSha1(password)
	session.Values[constant.SessionAdminId] = dbAdminId
	session.Save(r, w)

	// Header + JSON output
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

// Logout
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	session, err := h.Store.Get(r, constant.SessionKey)
	if err != nil {
		log.Printf("Could not get session on logout: %v", err)
	}
	session.Options.MaxAge = -1
	session.Save(r, w)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func (h *AuthHandler) respondAuthError(w http.ResponseWriter, msg string) {
	w.Header().Set("HTTP/1.1", "401 Unauthorized")
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(http.StatusUnauthorized)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": false,
		"message": msg,
	})
}
GO;
    }

    /**
     * Generates the Admin model struct.
     *
     * @return string The content of admin.go.
     */
    public function generateAdminModelGo()
    {
        return <<<GO
package modelcore

// Admin represents the admin table.
type Admin struct {
	AdminID      string `json:"adminId" gorm:"column:admin_id;primaryKey"`
	Username     string `json:"username" gorm:"column:username"`
	Password     string `json:"password" gorm:"column:password"`
	Name         string `json:"name" gorm:"column:name"`
	Email        string `json:"email" gorm:"column:email"`
	AdminLevelID string `json:"adminLevelId" gorm:"column:admin_level_id"`
	Active       bool   `json:"active" gorm:"column:active"`
}
GO;
    }

    /**
     * Maps a Java type to a GraphQL type for schema generation.
     *
     * @param string $goType The Go type.
     * @return string The corresponding GraphQL type.
     */
    private function mapGoTypeToGqlType($goType) // NOSONAR
    {
        switch ($goType) {
            case 'int':
            case 'int32':
            case 'int64':
                return 'Int';
            case 'float32':
            case 'float64':
                return 'Float';
            case 'bool':
                return 'Boolean';
            case 'time.Time':
                return 'String';
            case 'string':
            default:
                return 'String';
        }
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $moduleName = $this->projectConfig['moduleName'];
        // This is a simplified version. A full implementation would be similar to the Java one.
        $manualContent = "# GraphQL API Manual (Go)\r\n\r\n";
        $manualContent .= "This document provides examples for your Go GraphQL API.\r\n\r\n";
        $manualContent .= "## How to Run\r\n\r\n";
        $manualContent .= "1.  Ensure you have Go " . $this->projectConfig['goVersion'] . " or later installed.\n";
        $manualContent .= "2.  Create a `.env` file in the root directory and configure your database connection:\n\n";
        $manualContent .= "    ```\n";
        $manualContent .= "    DB_HOST=localhost\n";
        $manualContent .= "    DB_PORT=3306\n";
        $manualContent .= "    DB_USER=your_user\n";
        $manualContent .= "    DB_PASS=your_password\n";
        $manualContent .= "    DB_NAME=your_database\n";
        $manualContent .= "    DB_FILE=your_sqlite_file\n";
        $manualContent .= "    DB_DRIVER=mysql\n";
        $manualContent .= "    SERVER_PORT=8080\n";
        $manualContent .= "    SESSION_SECRET=change-this-to-a-random-string\n";
        $manualContent .= "    REQUIRE_LOGIN=" . ($this->requireLogin ? 'true' : 'false') . "\n";
        $manualContent .= "    ```\n\n"; // NOSONAR
        $manualContent .= "3.  Install dependencies:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go mod init $moduleName\n";
        $manualContent .= "    go get github.com/graph-gophers/graphql-go\n";
        $manualContent .= "    go get github.com/graph-gophers/graphql-go/relay\n";
        $manualContent .= "    go get github.com/go-sql-driver/mysql\n";
        $manualContent .= "    go get modernc.org/sqlite\n";
        $manualContent .= "    go get github.com/google/uuid\n";
        $manualContent .= "    go get github.com/joho/godotenv\n";
        $manualContent .= "    go get github.com/gorilla/sessions\n";
        $manualContent .= "    go mod tidy\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "4.  Run the application:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go run .\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "The GraphQL playground will be available at `http://localhost:8080/`.\n";

        $manualContent .= $this->generateExample();

        return $manualContent;
    }
}