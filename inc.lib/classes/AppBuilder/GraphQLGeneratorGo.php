<?php

namespace AppBuilder;

use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorGo` class is a tool to automatically generate a complete Go (Golang) GraphQL API 
 * from a JSON file that defines database entities. It inspects the schema to understand tables, columns, 
 * primary keys, and foreign key relationships. Based on this analysis, it produces Go code for models (structs), 
 * data access logic using GORM, GraphQL resolvers, and schema files, along with a comprehensive API manual.
 * This class streamlines the process of scaffolding a GraphQL API in Go, reducing manual effort and ensuring 
 * consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorGo extends GraphQLGeneratorBase
{
    /**
     * @var array<string, string> Project configuration for go.mod and package structure.
     */
    private $projectConfig = array();

    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use caching (placeholder for Go).
     * @param array $projectConfig Project configuration details.
     * @param bool $requireLogin Whether the generated application should require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'moduleName' => 'planet-app',
            'goVersion' => '1.21',
            'appName' => 'GraphQL App',
            'appDescription' => 'GraphQL API generated by MagicAppBuilder',
            'requireLogin' => $requireLogin
        ), $projectConfig);

        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int32';
        }
        return 'string'; // Default fallback
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoTypeAsModel($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int32';
        }
        return 'string'; // Default fallback
    }

    /**
     * Main function to generate all files for the Go project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();

        // 1. Go Module file
        $files[] = ['name' => 'go.mod', 'content' => $this->generateGoMod()];

        // 2. Main application file
        $files[] = ['name' => 'main.go', 'content' => $this->generateMainGo()];

        // 3. GraphQL setup
        $files[] = ['name' => 'schema/schema.graphql', 'content' => $this->generateCombinedSchema()];

        // 4. Models (Entities and DTOs)
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $files[] = ['name' => 'model/' . $this->camelCaseToSnakeCase($tableName) . '.go', 'content' => $this->generateModelFile($tableName, $tableInfo)];
        }

        $files[] = ['name' => 'constant/constant.go', 'content' => $this->geterateConstant()];
        $files[] = ['name' => 'input/any_scalar.go', 'content' => $this->geterateAnyScalar()];
        $files[] = ['name' => 'input/input.go', 'content' => $this->geterateInput()];
        $files[] = ['name' => 'input/query_builder.go', 'content' => $this->geterateQueryBuilder()];
        $files[] = ['name' => 'config/config.go', 'content' => $this->geterateConfig()];

        // 5. Resolvers
        
        $resolvers = $this->generateResolvers();

        $files[] = ['name' => 'resolver/app_resolver_root.go', 'content' => $this->generateResolverRoot()];

        $files = array_merge($files, $resolvers);

        // 6. Security and Auth
        // $files[] = ['name' => 'auth/auth.go', 'content' => $this->generateAuthGo()];
        // $files[] = ['name' => 'modelcore/admin.go', 'content' => $this->generateAdminModelGo()];

        // 7. Utility
        // $files[] = ['name' => 'util/util.go', 'content' => $this->generateUtilGo()];

        // 8. Manual
        $files[] = ['name' => 'manual.md', 'content' => $this->generateManual()];

        return $files;
    }

    private function geterateConfig()
    {
        return <<<GO
package config

import (
	"os"
	"strings"
)

// IsPostgres is a flag that is true if the configured database driver is PostgreSQL.
// It is initialized based on the DB_DRIVER environment variable.
var IsPostgres bool

func init() {
	dbDriver := os.Getenv("DB_DRIVER")
	dbDriver = strings.ToLower(dbDriver)
	IsPostgres = strings.Contains(dbDriver, "postgre")
}
GO;
    }

    private function geterateQueryBuilder()
    {
        return <<<GO
package input

import (
	"fmt"
	"strings"
)

// BuildQuery constructs WHERE and ORDER BY clauses for SQL queries based on GraphQL inputs.
// It returns the WHERE clause, ORDER BY clause, and a slice of parameters for safe querying.
func BuildQuery(filter *[]*FilterInput, orderBy *[]*SortInput, isPostgres bool) (string, string, []interface{}) {
	var whereClauses []string
	var orderClauses []string
	var params []interface{}

	// Build WHERE clause from filter
	// Build WHERE clause from filter
	if filter != nil {
		for _, f := range *filter {
			if f == nil || f.Value == nil {
				continue
			}
			// Default operator is EQUALS
			op := "="
			val := f.Value.Value()

			if f.Operator != nil {
				operator := fmt.Sprintf("%v", *f.Operator)
				switch strings.ToUpper(operator) {
				case "NOT_EQUALS":
					op = "!="
				case "CONTAINS":
					// Use ILIKE for PostgreSQL for case-insensitive search, LIKE for others (e.g., MySQL).
					if isPostgres {
						op = "ILIKE"
					} else {
						op = "LIKE"
					}
					val = fmt.Sprintf("%%%v%%", val)
				case "GREATER_THAN":
					op = ">"
				case "GREATER_THAN_OR_EQUALS":
					op = ">="
				case "LESS_THAN":
					op = "<"
				case "LESS_THAN_OR_EQUALS":
					op = "<="
				case "IN", "NOT_IN":
					// For IN/NOT_IN, the value is a comma-separated string. We need to create placeholders.
					valStr := fmt.Sprintf("%v", val)
					values := strings.Split(valStr, ",")
					if len(values) > 0 {
						placeholders := strings.Repeat("?,", len(values))
						placeholders = strings.TrimSuffix(placeholders, ",")
						operator := fmt.Sprintf("%v", *f.Operator)
						whereClauses = append(whereClauses, fmt.Sprintf("%s %s (%s)", f.Field, strings.ToUpper(operator), placeholders))
						for _, v := range values {
							params = append(params, strings.TrimSpace(v))
						}
					}
					continue // Skip the generic param append at the end
				}
			}
			whereClauses = append(whereClauses, fmt.Sprintf("%s %s ?", f.Field, op))
			params = append(params, val)
		}
	}

	// Build ORDER BY clause
	if orderBy != nil {
		for _, s := range *orderBy {
			if s == nil || s.Field == "" {
				continue
			}
			dir := "ASC" // Default direction
			if s.Direction != nil && strings.ToUpper(*s.Direction) == "DESC" {
				dir = "DESC"
			}
			orderClauses = append(orderClauses, fmt.Sprintf("%s %s", s.Field, dir))
		}
	}

	whereSQL := ""
	if len(whereClauses) > 0 {
		whereSQL = "WHERE " + strings.Join(whereClauses, " AND ")
	}

	orderSQL := ""
	if len(orderClauses) > 0 {
		orderSQL = "ORDER BY " + strings.Join(orderClauses, ", ")
	}

	return whereSQL, orderSQL, params
}

// PaginationArgs holds common pagination arguments from GraphQL queries.
type PaginationArgs struct {
	Limit  *int32
	Offset *int32
	Page   *int32
	Size   *int32
}

// GetPagination calculates limit, page, and offset from pagination arguments.
// It sets default values and allows overriding them.
func GetPagination(args PaginationArgs) (limit, page, offset int32) {
	limit = 10 // Default limit
	if args.Limit != nil {
		limit = *args.Limit
	}
	// 'size' is an alias for 'limit'
	if args.Size != nil {
		limit = *args.Size
	}

	page = 1 // Default page
	if args.Page != nil {
		page = *args.Page
	}

	offset = (page - 1) * limit // Calculate offset from page and limit
	if args.Offset != nil {
		offset = *args.Offset // Allow direct offset override
	}

	return limit, page, offset
}
GO;
    }
    private function geterateInput()
    {
        return <<<GO
package input

// FilterInput corresponds to the GraphQL FilterInput type.
type FilterInput struct {
	Field    string
	Value    *Any // Must be a pointer for custom scalar unmarshalling
	Operator *string
}

// SortInput corresponds to the GraphQL SortInput type.
type SortInput struct {
	Field     string
	Direction *string
}
GO;
    }

    private function geterateAnyScalar()
    {
return <<<GO
package input

import (
	"fmt"
)

// Any is a custom scalar type that can represent any value.
// It's used for the 'value' field in the FilterInput.
type Any struct{ v interface{} }

// ImplementsGraphQLType returns the name of the GraphQL type.
func (Any) ImplementsGraphQLType(name string) bool { return name == "Any" }

// UnmarshalGraphQL is called when a value is received from a client.
func (a *Any) UnmarshalGraphQL(input interface{}) error {
	a.v = input
	return nil
}

// MarshalJSON is called when sending a value to a client.
func (a Any) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.v)), nil
}

// Value returns the underlying value of the Any scalar.
func (a *Any) Value() interface{} {
	return a.v
}
GO;
    }

    private function geterateConstant()
    {
        return <<<GO
package constant

const (
	DateTimeFormat string = "2006-01-02 15:04:05"
    RemoteAddr string     = "RemoteAddr"
)
GO;
    }

    private function generateResolverRoot()
    {
        $packageName = $this->projectConfig['moduleName'];
        return <<<GO
package resolver

import (
	"context"
	"database/sql"
)

type ResolverRoot interface {
	DBConnection() *sql.DB
	Lantai(ctx context.Context, args struct{ ID string }) (*LantaiResolver, error)
	Blok(ctx context.Context, args struct{ ID string }) (*BlokResolver, error)
    Rak(ctx context.Context, args struct{ ID string }) (*RakResolver, error)
}

func (r *RootResolver) DBConnection() *sql.DB {
	return r.db
}

type RootResolver struct {
	db *sql.DB
	*LantaiQueryResolver
	*BlokQueryResolver
	*RakQueryResolver
}

func NewRootResolver(db *sql.DB) *RootResolver {
	root := &RootResolver{db: db}
	root.LantaiQueryResolver = NewLantaiQueryResolver(root)
	root.BlokQueryResolver = NewBlokQueryResolver(root)
	root.RakQueryResolver = NewRakQueryResolver(root)
	return root
}
GO;
    }

    private function generateResolvers()
    {
        $resolvers = [];
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $resolvers[] = ['name' => "resolver/{$tableName}.go", 'content' => $this->generateResolver($tableName, $tableInfo)];
        }
        return $resolvers;
    }

    private function generateResolver($tableName, $tableInfo)
    {
        $contents = [];
        $contents[] = "package resolver";
        $contents[] = "";
        $contents[] = $this->generateResolverImport($tableInfo);
        $contents[] = $this->generateResolverType($tableName, $tableInfo);
        $contents[] = $this->generateResolverQuery($tableName, $tableInfo);
        $contents[] = $this->generateResolverMutation($tableName, $tableInfo);

        return implode("\r\n", $contents);
    }

    private function generateResolverImport($tableInfo)
    {
        $packageName = $this->projectConfig['moduleName'];
        $libraries = [];
        $libraries[] = "\t\"context\"";
        $libraries[] = "\t\"database/sql\"";
        $libraries[] = "\t\"fmt\"";
        $libraries[] = "\t\"{$packageName}/config\"";
        $libraries[] = "\t\"{$packageName}/constant\"";
        $libraries[] = "\t\"{$packageName}/input\"";
        $libraries[] = "\t\"{$packageName}/model\"";
        $libraries[] = "\t\"strings\"";
        $libraries[] = "\t\"time\"";

        $autogenerated = false;
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey'] && $col['primaryKeyValue'] == 'autogenerated') {
                $autogenerated = true;
                break;
            }
        }

        if($autogenerated)
        {
             $libraries[] = "\r\n\t\"github.com/google/uuid\"";
        }
        
        return "import(\r\n".implode("\r\n", $libraries)."\r\n)\r\n";
        
    }

    private function generateResolverType($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $resolverName = $this->pascalCase($tableName);
        $resolverNamePlural = $this->pluralize($resolverName);
        $contents = [];
        $contents[] = "// {$resolverName}QueryResolver handles all queries and mutations for the {$resolverName} entity.
type {$resolverName}QueryResolver struct {
	root ResolverRoot
}

// {$resolverName}Resolver contains data for a single {$resolverName} object.
type {$resolverName}Resolver struct {
	m *model.{$resolverName}
	r *{$resolverName}QueryResolver
}

// {$resolverName}PageResolver contains data for a page/list of {$resolverNamePlural}.
type {$resolverName}PageResolver struct {
	items      []*{$resolverName}Resolver
	total      int32
	limit      int32
	page       int32
	totalPages int32
	hasNext    bool
	hasPrev    bool
}
";
        return implode("\r\n", $contents);
    }

    private function generateResolverQuery($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $pascalNamePlural = $this->pluralize($pascalName);
        $singleResolver = "{$pascalName}Resolver";
        $pageResolver = "{$pascalName}PageResolver";


        $methods = [];
        $columnInfo = [];
        $maxLength = 1;
        $pkName = '';
        $columNames = [];
        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($maxLength < strlen($columnName))
            {
                $maxLength = strlen($columnName);
            }
            if($col['isPrimaryKey'] && empty($pkName))
            {
                $pkName = $columnName;
            }
            $columnInfo[] = [
                "name" => ucfirst($columnName),
                "type" => $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']),
                "pointer" => $col['isPrimaryKey']
            ];
            $columNames[] = $columnName;
        }
        foreach($columnInfo as $info)
        {
            $goName = $this->goName($this->pascalCase($info['name']));
            $methods[] = sprintf("func (r *$singleResolver) %s() *%s    { return %sr.m.$goName }", $info['name'], $info['type'], $info['pointer'] ? '&' : '');
        }
        $entityMethods = implode("\r\n", $methods);

        $addCols = [];
        /*
        &m.BlokID,
		&m.Nama,
		&m.LantaiID,
		&m.SortOrder,
		&m.AdminBuat,
		&m.AdminUbah,
		&m.WaktuBuat,
		&m.WaktuUbah,
		&m.IpBuat,
		&m.IpUbah,
		&m.Aktif,
        */
        $relMethods = [];

        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($col['isForeignKey'])
            {
                $relEntity = $col['references'];
                $pascalEntityName = $this->pascalCase($relEntity);
                $fkName = $this->goName($this->pascalCase($columnName));
                $relMethods[] = "
// $relEntity resolves the related $relEntity for this $pascalName.
func (r *$singleResolver) {$pascalEntityName}(ctx context.Context) (*{$pascalEntityName}Resolver, error) {
	if r.m.{$fkName} == nil {
		return nil, nil
	}
	return r.r.root.$pascalEntityName(ctx, struct{ ID string }{ID: *r.m.{$fkName}})
}

";
                
            }
            $goName = $this->goName($this->pascalCase($columnName));
            $addCols[] = "\t\t\t&m.{$goName},";
        }

        $relationMethods = implode("\r\n", $relMethods);

        /*
// Lantai resolves the related Lantai for this Blok.
func (r *$singleResolver) Lantai(ctx context.Context) (*LantaiResolver, error) {
	if r.m.LantaiID == nil {
		return nil, nil
	}
	return r.r.root.Lantai(ctx, struct{ ID string }{ID: *r.m.LantaiID})
}
*/

        /*
func (r *$singleResolver) Blok_id() *string    { return &r.m.BlokID }
func (r *$singleResolver) Nama() *string       { return r.m.Nama }
func (r *$singleResolver) Lantai_id() *string  { return r.m.LantaiID }
func (r *$singleResolver) Sort_order() *int32  { return r.m.SortOrder }
func (r *$singleResolver) Admin_buat() *string { return r.m.AdminBuat }
func (r *$singleResolver) Admin_ubah() *string { return r.m.AdminUbah }
func (r *$singleResolver) Waktu_buat() *string { return r.m.WaktuBuat }
func (r *$singleResolver) Waktu_ubah() *string { return r.m.WaktuUbah }
func (r *$singleResolver) Ip_buat() *string    { return r.m.IpBuat }
func (r *$singleResolver) Ip_ubah() *string    { return r.m.IpUbah }
func (r *$singleResolver) Aktif() *bool        { return r.m.Aktif }
*/
        
        $addresOfColumns1 = implode("\r\n", $addCols);
        $addresOfColumns1 = str_replace("\t\t\t", "\t\t", $addresOfColumns1);
        $addresOfColumns2 = implode("\r\n", $addCols);

        $columnList = implode(", ", $columNames);
        $queries = <<<GO
// New{$pascalName}QueryResolver creates a new resolver for {$pascalName} queries.
func New{$pascalName}QueryResolver(root ResolverRoot) *{$pascalName}QueryResolver {
	return &{$pascalName}QueryResolver{root: root}
}

// Methods specific to $pascalName
$entityMethods

$relationMethods
func (r *{$pageResolver}) Items() *[]*$singleResolver { return &r.items }
func (r *{$pageResolver}) Total() *int32           { return &r.total }
func (r *{$pageResolver}) Limit() *int32           { return &r.limit }
func (r *{$pageResolver}) Page() *int32            { return &r.page }
func (r *{$pageResolver}) TotalPages() *int32      { return &r.totalPages }
func (r *{$pageResolver}) HasNext() *bool          { return &r.hasNext }
func (r *{$pageResolver}) HasPrevious() *bool      { return &r.hasPrev }

// {$pascalName} fetches a single {$tableName} by its ID.
func (r *{$pascalName}QueryResolver) {$pascalName}(ctx context.Context, args struct{ ID string }) (*$singleResolver, error) {
	
	tableName := "{$tableName}"
	columns := "$columnList"
	primaryKey := "{$pkName}"
	
	sqlQuery := fmt.Sprintf("SELECT %s FROM %s WHERE %s = ?", columns, tableName, primaryKey)
	row := r.root.DBConnection().QueryRowContext(ctx, sqlQuery, args.ID)
	m := model.{$pascalName}{}
	err := row.Scan(
$addresOfColumns1
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &$singleResolver{m: &m, r: r}, nil
}

// {$pascalNamePlural} fetches a paginated list of {$pascalNamePlural}.
func (r *{$pascalName}QueryResolver) {$pascalNamePlural}(ctx context.Context, args struct {
	Limit   *int32
	Offset  *int32
	Page    *int32
	Size    *int32
	OrderBy *[]*input.SortInput
	Filter  *[]*input.FilterInput
}) (*{$pageResolver}, error) {

	tableName := "{$tableName}"
	columns := "$columnList"

	// Pagination
	limit, page, offset := input.GetPagination(input.PaginationArgs{
		Limit:  args.Limit,
		Offset: args.Offset,
		Page:   args.Page,
		Size:   args.Size,
	})

	// Build query

	whereSQL, orderSQL, params := input.BuildQuery(args.Filter, args.OrderBy, config.IsPostgres)
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM %s %s", tableName, whereSQL)

	// Count total items
	var total int32
	err := r.root.DBConnection().QueryRowContext(ctx, countQuery, params...).Scan(&total)
	if err != nil {
		return nil, err
	}

	// Fetch items
	queryParams := append(params, limit, offset)
	queryQuery := fmt.Sprintf("SELECT %s FROM %s %s %s LIMIT ? OFFSET ?", columns, tableName, whereSQL, orderSQL)
	rows, err := r.root.DBConnection().QueryContext(ctx, queryQuery, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := []*$singleResolver{}
	for rows.Next() {
		m := model.{$pascalName}{}
		err := rows.Scan(
$addresOfColumns2
		)
		if err != nil {
			return nil, err
		}
		items = append(items, &$singleResolver{m: &m, r: r})
	}

	totalPages := int32(0)
	if total > 0 {
		totalPages = (total + limit - 1) / limit
	}

	return &{$pageResolver}{
		items:      items,
		total:      total,
		limit:      limit,
		page:       page,
		totalPages: totalPages,
		hasNext:    page < totalPages,
		hasPrev:    page > 1,
	}, nil
}
GO;
        return $queries;
    }

    private function generateResolverMutation($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $pkName = '';
        $colInfo = [];
        $maxLength = 1;
        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($col['isPrimaryKey'] && empty($pkName))
            {
                $pkName = $columnName;
            }
            
            $colInfo[] = [
                'name' => $this->goName($this->pascalCase($columnName)),
                'type' => $this->mapDbTypeToGoType($col['type'], $col['length'])
            ];
            if($maxLength < strlen($columnName))
            {
                $maxLength = strlen($columnName);
            }
        }
        $autoincrement = false;
        $autogenerated = false;
        $columnToInsert = [];
        $ph = [];
        $par = [];
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        $autogeneratedCol = '';
        foreach ($tableInfo['columns'] as $colName => $col) {
            if ($col['isPrimaryKey'] && ($col['primaryKeyValue'] == 'autoincrement') && $autoincrement) {
                $autoincrement = true;
                continue;
            }
            if ($col['isPrimaryKey'] && ($col['primaryKeyValue'] == 'autogenerated') && !$autogenerated) {
                $autogenerated = true;
                $autogeneratedCol = $colName;
                continue;
            }
            if(in_array($colName, $backendHandledColumnNames))
            {
                continue;
            }
            $gn = $this->goName($this->pascalCase($colName));
            $columnToInsert[] = $colName;
            $ph[] = "?";
            $par[] = "\tparams = append(params, args.Input.".$gn.")";

            $updateCode[] = <<<GO
    if args.Input.{$gn} != nil {
        fields = append(fields, "{$colName} = ?")
        params = append(params, *args.Input.{$gn})
    }
GO;
        }
        $entityColumns = [];
        foreach ($tableInfo['columns'] as $colName => $col) {
            $entityColumns[] = $colName;
        }
        foreach($this->backendHandledColumns as $k=>$v)
        {
            if(($k == 'timeCreate' || $k == 'timeEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($ph, "?");
                array_push($par, "\tparams = append(params, time.Now().Format(constant.DateTimeFormat))"); 
                if($k == 'timeEdit')
                {
                    $updateCode[] = <<<GO
    if args.Input.{$gn} != nil {
        fields = append(fields, "{$v['columnName']} = ?")
        params = append(params, time.Now().Format(constant.DateTimeFormat))
    }

GO;
                }
            }
            if(($k == 'ipCreate' || $k == 'ipEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($ph, "?");
                array_push($par, "\tparams = append(params, ctx.Value(constant.RemoteAddr).(string))"); 
                if($k == 'ipEdit')
                {
                    $updateCode[] = <<<GO
    if args.Input.{$gn} != nil {
        fields = append(fields, "{$v['columnName']} = ?")
        params = append(params, ctx.Value(constant.RemoteAddr).(string))
    }

GO;
                }
            }
        }

        $uuid = "";
        if($autogenerated)
        {
            array_unshift($columnToInsert, $autogeneratedCol);
            array_unshift($ph, "?");
            array_unshift($par, "\tparams = append(params, id)");
            $uuid = "\tid := uuid.New().String()";
        }

        $columns = implode(", ", $columnToInsert);
        $placeholders = implode(", ", $ph);
        $paramSet = implode("\r\n", $par);
        $updateCodes = implode("\r\n", $updateCode);

        $defs = [];
        foreach($colInfo as $info)
        {
            $defs[] = sprintf("\t%-{$maxLength}s *%s", $info['name'], $info['type']);
        }
        $typeDefinitions = implode("\r\n", $defs);

        $activeField = $this->activeField;

        $mutation = <<<GO
// --- Mutations ---

type {$pascalName}Input struct {
$typeDefinitions
}

// Create{$pascalName} creates a new {$tableName}.
func (r *{$pascalName}QueryResolver) Create{$pascalName}(ctx context.Context, args struct{ Input {$pascalName}Input }) (*{$pascalName}Resolver, error) {

	tableName := "{$tableName}"
	columns := "$columns"
	placeholders := "$placeholders"

$uuid

    var params []interface{}

$paramSet

	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)", tableName, columns, placeholders)
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, fmt.Errorf("failed to create %s: %w", tableName, err)
	}
	return r.{$pascalName}(ctx, struct{ ID string }{ID: id})
}

// Update{$pascalName} updates an existing {$tableName}.
func (r *{$pascalName}QueryResolver) Update{$pascalName}(ctx context.Context, args struct {
	ID    string
	Input {$pascalName}Input
}) (*{$pascalName}Resolver, error) {

	tableName := "{$tableName}"
	primaryKey := "{$pkName}"

	var fields []string
	var params []interface{}

$updateCodes

	if len(fields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	fields = append(fields, "waktu_ubah = ?")
	params = append(params, time.Now().Format(constant.DateTimeFormat))
	params = append(params, args.ID)

	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?", tableName, strings.Join(fields, ", "), primaryKey)
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, fmt.Errorf("failed to update %s: %w", tableName, err)
	}
	return r.{$pascalName}(ctx, struct{ ID string }{ID: args.ID})
}

// Delete{$pascalName} deletes a {$tableName} by its ID.
func (r *{$pascalName}QueryResolver) Delete{$pascalName}(ctx context.Context, args struct{ ID string }) (bool, error) {

	tableName := "{$tableName}"
	primaryKey := "{$pkName}"

	sqlQuery := fmt.Sprintf("DELETE FROM %s WHERE %s = ?", tableName, primaryKey)

	_, err := r.root.DBConnection().ExecContext(ctx, sqlQuery, args.ID)
	if err != nil {
		return false, fmt.Errorf("failed to delete %s: %w", tableName, err)
	}
	return true, nil
}

// Toggle{$pascalName}Active changes the active status of a {$tableName}.
func (r *{$pascalName}QueryResolver) Toggle{$pascalName}Active(ctx context.Context, args struct {
	ID    string
	Aktif bool
}) (*{$pascalName}Resolver, error) {
	tableName := "{$tableName}"
	primaryKey := "{$pkName}"
	activeField := "{$activeField}"

	sqlQuery := fmt.Sprintf("UPDATE %s SET %s = ? WHERE %s = ?", tableName, activeField, primaryKey)
	_, err := r.root.DBConnection().ExecContext(ctx, sqlQuery, args.Aktif, args.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to change %s.%s status: %w", tableName, activeField, err)
	}
	return r.{$pascalName}(ctx, struct{ ID string }{ID: args.ID})
}
GO;
        return $mutation;
    }

    /**
     * Generates the content for the go.mod file.
     *
     * @return string The content for go.mod.
     */
    public function generateGoMod()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $goVersion = $this->projectConfig['goVersion'];

        return <<<MOD
module $moduleName

go $goVersion

require (
	github.com/go-sql-driver/mysql v1.9.3
	github.com/graph-gophers/graphql-go v1.8.0
	github.com/google/uuid v1.6.0
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/joho/godotenv v1.5.1
)
MOD;
    }

    /**
     * Generates the main.go file.
     *
     * @return string The content of main.go.
     */
    public function generateMainGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"$moduleName/constant"
	"$moduleName/resolver"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/graph-gophers/graphql-go"
	"github.com/graph-gophers/graphql-go/relay"
	"github.com/joho/godotenv"
)

// ipMiddleware injects the client's IP address into the request context.
func ipMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ip := GetClientIP(r)
		ctx := context.WithValue(r.Context(), constant.RemoteAddr, ip)
		next.ServeHTTP(w, r.WithContext(ctx))
	})
}
func GetClientIP(r *http.Request) string {
	// Check for X-Forwarded-For header, which can be a comma-separated list.
	// The client's IP is typically the first one.
	if forwardedFor := r.Header.Get("X-Forwarded-For"); forwardedFor != "" {
		// Split the list and return the first IP
		ips := strings.Split(forwardedFor, ",")
		if len(ips) > 0 {
			return strings.TrimSpace(ips[0])
		}
	}

	// Check for X-Real-IP header.
	if realIP := r.Header.Get("X-Real-IP"); realIP != "" {
		return realIP
	}

	// Fallback to the remote address.
	ip, _, _ := net.SplitHostPort(r.RemoteAddr)
	return ip
}

func main() {
	// Load variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Println("Warning: Could not load .env file. Using system environment variables.")
	}

	// Build DSN (Data Source Name) from environment variables
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s",
		os.Getenv("DB_USER"),
		os.Getenv("DB_PASS"),
		os.Getenv("DB_HOST"),
		os.Getenv("DB_PORT"),
		os.Getenv("DB_NAME"),
	)

	driver := os.Getenv("DB_DRIVER")

	// Open database connection
	db, err := sql.Open(driver, dsn)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Read GraphQL schema from file
	schemaPath := os.Getenv("GRAPHQL_SCHEMA")
	schemaData, err := os.ReadFile(schemaPath)
	if err != nil {
		log.Fatalf("Failed to read schema file %s: %v", schemaPath, err)
	}

	// Parse GraphQL schema
	schema := graphql.MustParseSchema(string(schemaData), resolver.NewRootResolver(db))

	// Set handler for GraphQL endpoint
	graphqlEndpoint := os.Getenv("GRAPHQL_ENDPOINT")
	http.Handle(graphqlEndpoint, ipMiddleware(&relay.Handler{Schema: schema}))

	// Handler for serving static assets from the /assets directory
	http.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir("static/assets"))))

	// Handler for serving language from the /langs directory
	http.Handle("/langs/", http.StripPrefix("/langs/", http.FileServer(http.Dir("static/langs"))))

	// Handler for available themes, mimicking the PHP logic.
	http.HandleFunc("/available-theme", func(w http.ResponseWriter, r *http.Request) {
		themesPath := "static/assets/themes"

		type Theme struct {
			Name  string `json:"name"`
			Title string `json:"title"`
		}

		var themes []Theme

		entries, err := os.ReadDir(themesPath)
		if err != nil {
			log.Printf("Warning: Could not read themes directory '%s': %v", themesPath, err)
			// Return empty list if directory doesn't exist, similar to PHP's glob behavior.
		} else {
			for _, entry := range entries {
				if entry.IsDir() {
					themeName := entry.Name()
					cssPath := filepath.Join(themesPath, themeName, "style.min.css")
					if _, err := os.Stat(cssPath); err == nil {
						// File exists, add it to the list.
						title := strings.Title(strings.ToLower(strings.ReplaceAll(strings.ReplaceAll(themeName, "-", " "), "_", " ")))
						themes = append(themes, Theme{Name: themeName, Title: title})
					}
				}
			}
		}

		// Set headers for JSON content type and caching
		cacheTime := 86400 // 24 hours in seconds
		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Cache-Control", fmt.Sprintf("public, max-age=%d", cacheTime))
		w.Header().Set("Expires", time.Now().Add(time.Second*time.Duration(cacheTime)).Format(http.TimeFormat))

		json.NewEncoder(w).Encode(themes)
	})

	// Handler for serving the static index.html file
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		// If the path is not the root, return a 404 to avoid this handler
		// catching all undefined paths.
		if r.URL.Path != "/" && r.URL.Path != "/index.html" {
			http.NotFound(w, r)
			return
		}
		http.ServeFile(w, r, "static/index.html")
	})

	// Handler for frontend configuration, served with no-cache headers.
	http.HandleFunc("/frontend-config", func(w http.ResponseWriter, r *http.Request) {
		// Set headers to prevent caching by the browser.
		w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		w.Header().Set("Surrogate-Control", "no-store")

		http.ServeFile(w, r, "static/config/frontend-config.json")
	})

	// Handler for favicon.ico
	http.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "static/favicon.ico")
	})

	// Run HTTP server
	serverPort := os.Getenv("SERVER_PORT")
	log.Printf("Server is running at: http://localhost:%s%s", serverPort, graphqlEndpoint)
	log.Printf("Serving static index.html on http://localhost:%s/", serverPort)
	log.Fatal(http.ListenAndServe(":"+serverPort, nil))
}
GO;
    }

    private function goName($name)
    {
        $name = $this->pascalCase($name);
        if(PicoStringUtil::endsWith($name, 'Id'))
        {
            $name = substr($name, 0, strlen($name) - 2).'ID';
        }
        return $name;
    }

    /**
     * Generates a model file (struct) for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the model file.
     */
    private function generateModelFile($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $structFields = "";
        $fieldNames = [];
        $fieldTypes = [];
        $maxLength = 1;
        $index = 0;
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $goType = $this->mapDbTypeToGoTypeAsModel($colInfo['type'], $colInfo['length']);
            $fieldName = $this->goName($colName);
            if(strlen($fieldName) > $maxLength)
            {
                $maxLength = strlen($fieldName);
            }

            if (!$colInfo['isPrimaryKey']) {
                $goType = "*".$goType;
            }

            $fieldNames[$index] = $fieldName;
            $fieldTypes[$index] = $goType;
            $index++;
        }
        foreach($fieldNames as $index => $fieldName)
        {
            $structFields .= sprintf("\t%-{$maxLength}s %s\r\n", $fieldName, $fieldTypes[$index]);
        }


        return <<<GO
package model

// $pascalName represents the $tableName table.
type $pascalName struct {
$structFields}
GO;
    }

    /**
     * Generates the resolver.go file.
     *
     * @return string The content of resolver.go.
     */
    public function generateResolverGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package graph

import (
    "{$moduleName}/config"
    "gorm.io/gorm"
)

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

type Resolver struct{
    DB *gorm.DB
    Cfg *config.Config
}
GO;
    }

    /**
     * Generates the combined GraphQL schema file.
     *
     * @return string The content of schema.graphqls.
     */
    private function generateCombinedSchema()
    {
        $allTypes = "";
        $allQueries = "";
        $allMutations = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allTypes .= $schemaParts['types'] . "\n";
            $allQueries .= $schemaParts['queries'] . "\n";
            $allMutations .= $schemaParts['mutations'] . "\n";
        }

        return <<<GQL
scalar Any

enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Any
    operator: FilterOperator
}

$allTypes

type Query {
$allQueries
}

type Mutation {
$allMutations
}
GQL;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $camelName = $this->camelCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $typeFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName;
            $typeFields .= "    $fieldName: $gqlType\n";

            if ($colInfo['isForeignKey']) {
                $refPascalName = $this->pascalCase($colInfo['references']);
                $refFieldName = $this->camelCase($colInfo['references']);
                $typeFields .= "    $refFieldName: $refPascalName\n";
            }
        }

        // Input fields
        $inputFields = "";
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            $gqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName;
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $pkGqlType = 'String!';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($col['type'], $col['length'])) . '!';
                break;
            }
        }

        $types = <<<GQL
type $pascalName {
$typeFields}

input {$pascalName}Input {
$inputFields}

type {$pascalName}Page {
    items: [$pascalName]
    total: Int
    page: Int
    limit: Int
    totalPages: Int
    hasNext: Boolean
    hasPrevious: Boolean
}
GQL;
        $camelMethodName = $camelName;
        $pluralMethodName = $pluralCamelName;

        $queries = "    $camelMethodName(id: $pkGqlType): $pascalName\n";
        $queries .= "    $pluralMethodName(limit: Int, offset: Int, page: Int, orderBy: [SortInput], filter: [FilterInput]): {$pascalName}Page\n";

        $mutations = "    create{$pascalName}(input: {$pascalName}Input!): $pascalName\n";
        $mutations .= "    update{$pascalName}(id: $pkGqlType, input: {$pascalName}Input!): $pascalName\n";
        $mutations .= "    delete{$pascalName}(id: $pkGqlType): Boolean!\n";

        if ($tableInfo['hasActiveColumn']) {
            $activeField = $this->camelCase($this->activeField);
            $mutations .= "    toggle{$pascalName}Active(id: {$pkGqlType}, $activeField: Boolean!): $pascalName\n";
        }

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Generates the auth.go file for login/logout logic.
     *
     * @return string The content of auth.go.
     */
    public function generateAuthGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package auth

import (
	"crypto/sha1"
	"encoding/hex"
	"net/http"

	"{$moduleName}/graph/model"
	"github.com/gin-contrib/sessions"
	"github.com/gin-gonic/gin"
	"gorm.io/gorm"
)

type AuthController struct {
	DB *gorm.DB
}

func NewAuthController(db *gorm.DB) *AuthController {
	return &AuthController{DB: db}
}

type LoginRequest struct {
	Username string `json:"username" form:"username" binding:"required"`
	Password string `json:"password" form:"password" binding:"required"`
}

func (ac *AuthController) Login(c *gin.Context) {
	var req LoginRequest
	if err := c.ShouldBind(&req); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	var admin model.Admin
	if err := ac.DB.Where("username = ?", req.Username).First(&admin).Error; err != nil {
		c.JSON(http.StatusUnauthorized, gin.H{"success": false, "message": "Invalid credentials"})
		return
	}

	// MagicAppBuilder uses sha1(sha1(password))
	hashedPassword := doubleSha1(req.Password)

	if admin.Password != hashedPassword {
		c.JSON(http.StatusUnauthorized, gin.H{"success": false, "message": "Invalid credentials"})
		return
	}

	session := sessions.Default(c)
	session.Set("adminId", admin.AdminID)
	session.Set("username", admin.Username)
	if err := session.Save(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save session"})
		return
	}

	c.JSON(http.StatusOK, gin.H{"success": true, "message": "Login successful"})
}

func (ac *AuthController) Logout(c *gin.Context) {
	session := sessions.Default(c)
	session.Clear()
	if err := session.Save(); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to save session"})
		return
	}
	c.JSON(http.StatusOK, gin.H{"success": true, "message": "Logout successful"})
}

func doubleSha1(s string) string {
	h1 := sha1.New()
	h1.Write([]byte(s))
	firstHash := hex.EncodeToString(h1.Sum(nil))

	h2 := sha1.New()
	h2.Write([]byte(firstHash))
	return hex.EncodeToString(h2.Sum(nil))
}
GO;
    }

    /**
     * Generates the Admin model struct.
     *
     * @return string The content of admin.go.
     */
    public function generateAdminModelGo()
    {
        return <<<GO
package modelcore

// Admin represents the admin table.
type Admin struct {
	AdminID      string `json:"adminId" gorm:"column:admin_id;primaryKey"`
	Username     string `json:"username" gorm:"column:username"`
	Password     string `json:"password" gorm:"column:password"`
	Name         string `json:"name" gorm:"column:name"`
	Email        string `json:"email" gorm:"column:email"`
	AdminLevelID string `json:"adminLevelId" gorm:"column:admin_level_id"`
	Active       bool   `json:"active" gorm:"column:active"`
}
GO;
    }

    /**
     * Generates the util.go file with helper functions.
     *
     * @return string The content of util.go.
     */
    public function generateUtilGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $backendHandledColumns = $this->getBackendHandledColumnNames();
        $timeCreateCol = isset($this->backendHandledColumns['timeCreate']) ? $this->pascalCase($this->backendHandledColumns['timeCreate']['columnName']) : '';
        $adminCreateCol = isset($this->backendHandledColumns['adminCreate']) ? $this->pascalCase($this->backendHandledColumns['adminCreate']['columnName']) : '';
        $timeEditCol = isset($this->backendHandledColumns['timeEdit']) ? $this->pascalCase($this->backendHandledColumns['timeEdit']['columnName']) : '';
        $adminEditCol = isset($this->backendHandledColumns['adminEdit']) ? $this->pascalCase($this->backendHandledColumns['adminEdit']['columnName']) : '';

        $setCreateFields = "";
        if ($timeCreateCol) $setCreateFields .= "    setField(model, \"{$timeCreateCol}\", time.Now())\n";
        if ($adminCreateCol) $setCreateFields .= "    setField(model, \"{$adminCreateCol}\", adminID)\n";

        $setUpdateFields = "";
        if ($timeEditCol) $setUpdateFields .= "    setField(model, \"{$timeEditCol}\", time.Now())\n";
        if ($adminEditCol) $setUpdateFields .= "    setField(model, \"{$adminEditCol}\", adminID)\n";

        return <<<GO
package util

import (
	"context"
	"fmt"
	"reflect"
	"strings"
	"time"

	"{$moduleName}/auth"
	"{$moduleName}/graph/model"
	"gorm.io/gorm"
)

// Paginator holds pagination data
type Paginator struct {
	Limit  int
	Offset int
	Page   int
}

// NewPaginator creates a Paginator from GraphQL arguments
func NewPaginator(limit, offset, page *int) *Paginator {
	p := &Paginator{Limit: 20, Page: 1} // Defaults

	if limit != nil {
		p.Limit = *limit
	}
	if page != nil && *page > 0 {
		p.Page = *page
		p.Offset = (*page - 1) * p.Limit
	} else if offset != nil {
		p.Offset = *offset
		if p.Limit > 0 {
			p.Page = (*offset / p.Limit) + 1
		}
	}
	return p
}

func (p *Paginator) TotalPages(total int) int {
	if p.Limit == 0 {
		return 0
	}
	return (total + p.Limit - 1) / p.Limit
}

func (p *Paginator) HasNext(total int) bool {
	return p.Page < p.TotalPages(total)
}

func (p *Paginator) HasPrev() bool {
	return p.Page > 1
}

// ApplyFilter applies a single filter to a GORM query
func ApplyFilter(db *gorm.DB, filter model.FilterInput) *gorm.DB {
	op := " = ?" // Default operator
	var val interface{} = filter.Value

	if filter.Operator != nil {
		switch strings.ToUpper(string(*filter.Operator)) {
		case "NOT_EQUALS":
			op = " <> ?"
		case "CONTAINS":
			op = " LIKE ?"
			val = fmt.Sprintf("%%%s%%", filter.Value)
		case "GREATER_THAN":
			op = " > ?"
		case "GREATER_THAN_OR_EQUALS":
			op = " >= ?"
		case "LESS_THAN":
			op = " < ?"
		case "LESS_THAN_OR_EQUALS":
			op = " <= ?"
		case "IN":
			op = " IN (?)"
			val = strings.Split(fmt.Sprintf("%v", filter.Value), ",")
		case "NOT_IN":
			op = " NOT IN (?)"
			val = strings.Split(fmt.Sprintf("%v", filter.Value), ",")
		}
	}
	return db.Where(ToSnakeCase(filter.Field)+op, val)
}

// ApplyOrderBy applies sorting to a GORM query
func ApplyOrderBy(db *gorm.DB, sort model.SortInput) *gorm.DB {
	direction := "ASC"
	if sort.Direction != nil && strings.ToUpper(string(*sort.Direction)) == "DESC" {
		direction = "DESC"
	}
	return db.Order(fmt.Sprintf("%s %s", ToSnakeCase(sort.Field), direction))
}

// ToSnakeCase converts a string from camelCase to snake_case.
func ToSnakeCase(str string) string {
	var result []rune
	for i, r := range str {
		if r >= 'A' && r <= 'Z' {
			if i > 0 {
				result = append(result, '_')
			}
			result = append(result, r+('a'-'A'))
		} else {
			result = append(result, r)
		}
	}
	return string(result)
}

// MapInputToModel maps fields from an input struct to a model struct.
func MapInputToModel(input interface{}, model interface{}) {
	inputValue := reflect.ValueOf(input)
	modelValue := reflect.ValueOf(model).Elem()

	for i := 0; i < inputValue.NumField(); i++ {
		inputField := inputValue.Field(i)
		if inputField.IsNil() {
			continue
		}

		fieldName := inputValue.Type().Field(i).Name
		modelField := modelValue.FieldByName(fieldName)

		if modelField.IsValid() && modelField.CanSet() {
			modelField.Set(inputField.Elem())
		}
	}
}

// SetAuditFieldsForCreate sets creation audit fields on a model.
func SetAuditFieldsForCreate(model interface{}, ctx context.Context) {
	adminID := ctx.Value(auth.AdminIDKey)
$setCreateFields
}

// SetAuditFieldsForUpdate sets update audit fields on a model.
func SetAuditFieldsForUpdate(model interface{}, ctx context.Context) {
	adminID := ctx.Value(auth.AdminIDKey)
$setUpdateFields
}

func setField(obj interface{}, fieldName string, value interface{}) {
    v := reflect.ValueOf(obj).Elem()
    field := v.FieldByName(fieldName)
    if field.IsValid() && field.CanSet() {
        field.Set(reflect.ValueOf(value))
    }
}
GO;
    }

    /**
     * Maps a Java type to a GraphQL type for schema generation.
     *
     * @param string $goType The Go type.
     * @return string The corresponding GraphQL type.
     */
    private function mapGoTypeToGqlType($goType)
    {
        switch ($goType) {
            case 'int':
            case 'int32':
            case 'int64':
                return 'Int';
            case 'float32':
            case 'float64':
                return 'Float';
            case 'bool':
                return 'Boolean';
            case 'time.Time':
                return 'String';
            case 'string':
            default:
                return 'String';
        }
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $moduleName = $this->projectConfig['moduleName'];
        // This is a simplified version. A full implementation would be similar to the Java one.
        $manualContent = "# GraphQL API Manual (Go)\r\n\r\n";
        $manualContent .= "This document provides examples for your Go GraphQL API.\r\n\r\n";
        $manualContent .= "## How to Run\r\n\r\n";
        $manualContent .= "1.  Ensure you have Go " . $this->projectConfig['goVersion'] . " or later installed.\n";
        $manualContent .= "2.  Create a `.env` file in the root directory and configure your database connection:\n\n";
        $manualContent .= "    ```\n";
        $manualContent .= "    DB_HOST=localhost\n";
        $manualContent .= "    DB_PORT=3306\n";
        $manualContent .= "    DB_USER=your_user\n";
        $manualContent .= "    DB_PASS=your_password\n";
        $manualContent .= "    DB_NAME=your_database\n";
        $manualContent .= "    DB_DRIVER=mysql\n";
        $manualContent .= "    SERVER_PORT=8080\n";
        $manualContent .= "    SESSION_SECRET=change-this-to-a-random-string\n";
        $manualContent .= "    REQUIRE_LOGIN=" . ($this->requireLogin ? 'true' : 'false') . "\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "3.  Install dependencies:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go mod init $moduleName\n";
        $manualContent .= "    go get github.com/graph-gophers/graphql-go\n";
        $manualContent .= "    go get github.com/graph-gophers/graphql-go/relay\n";
        $manualContent .= "    go get github.com/go-sql-driver/mysql\n";
        $manualContent .= "    go get github.com/google/uuid\n";
        $manualContent .= "    go get github.com/joho/godotenv\n";
        $manualContent .= "    go mod tidy\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "5.  Run the application:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go run main.go\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "The GraphQL playground will be available at `http://localhost:8080/`.\n";

        // Add query/mutation examples similar to the Java generator
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pascalName = $this->pascalCase($tableName);

            $manualContent .= "\r\n## " . $pascalName . "\r\n\r\n";
            $manualContent .= "### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $pascalName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-id\") {\r\n";
            $manualContent .= "    # ... fields\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        return $manualContent;
    }
}