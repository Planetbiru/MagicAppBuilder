<?php

namespace AppBuilder;

use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorGo` class is a tool to automatically generate a complete Go (Golang) GraphQL API 
 * from a JSON file that defines database entities. It inspects the schema to understand tables, columns, 
 * primary keys, and foreign key relationships. Based on this analysis, it produces Go code for models (structs), 
 * data access logic using GORM, GraphQL resolvers, and schema files, along with a comprehensive API manual.
 * This class streamlines the process of scaffolding a GraphQL API in Go, reducing manual effort and ensuring 
 * consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorGo extends GraphQLGeneratorBase
{
    /**
     * @var array<string, string> Project configuration for go.mod and package structure.
     */
    private $projectConfig = array();

    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use caching (placeholder for Go).
     * @param array $projectConfig Project configuration details.
     * @param bool $requireLogin Whether the generated application should require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'moduleName' => 'planet-app',
            'goVersion' => '1.21',
            'appName' => 'GraphQL App',
            'appDescription' => 'GraphQL API generated by MagicAppBuilder',
            'requireLogin' => $requireLogin
        ), $projectConfig);

        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'time.Time';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int32';
        }
        return 'string'; // Default fallback
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoTypeAsModel($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'int32';
        }
        return 'string'; // Default fallback
    }

    /**
     * Main function to generate all files for the Go project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();

        // 1. Go Module file
        $files[] = ['name' => 'go.mod', 'content' => $this->generateGoMod()];

        // 2. Main application file
        $files[] = ['name' => 'main.go', 'content' => $this->generateMainGo()];

        // 3. GraphQL setup
        $files[] = ['name' => 'schema/schema.graphqls', 'content' => $this->generateCombinedSchema()];

        // 4. Models (Entities and DTOs)
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $files[] = ['name' => 'model/' . $this->camelCaseToSnakeCase($tableName) . '.go', 'content' => $this->generateModelFile($tableName, $tableInfo)];
        }

        $files[] = ['name' => 'constant/constant.go', 'content' => $this->geterateConstant()];
        $files[] = ['name' => 'input/any_scalar.go', 'content' => $this->geterateAnyScalar()];
        $files[] = ['name' => 'input/input.go', 'content' => $this->geterateInput()];
        $files[] = ['name' => 'input/query_builder.go', 'content' => $this->geterateQueryBuilder()];
        $files[] = ['name' => 'config/config.go', 'content' => $this->geterateConfig()];

        // 5. Resolvers
        
        $resolvers = $this->generateResolvers();

        $files[] = ['name' => 'resolver/app_resolver_root.go', 'content' => $this->generateResolverRoot()];

        $files = array_merge($files, $resolvers);

        // 6. Security and Auth
        $files[] = ['name' => 'handler/auth.go', 'content' => $this->generateAuthGo()];

        // 7. Manual
        $files[] = ['name' => 'manual.md', 'content' => $this->generateManual()];

        return $files;
    }

    /**
     * Generates the Go configuration file.
     *
     * This file initializes a global `IsPostgres` flag based on the `DB_DRIVER`
     * environment variable. The flag allows other components (e.g., query
     * builders or resolvers) to apply PostgreSQL-specific behavior such as
     * using ILIKE instead of LIKE.
     *
     * @return string The generated Go source code for config/config.go
     */
    private function geterateConfig()
    {
        return <<<GO
package config

import (
	"os"
	"strings"
)

// IsPostgres is a flag that is true if the configured database driver is PostgreSQL.
// It is initialized based on the DB_DRIVER environment variable.
var IsPostgres bool

func init() {
	dbDriver := os.Getenv("DB_DRIVER")
	dbDriver = strings.ToLower(dbDriver)
	IsPostgres = strings.Contains(dbDriver, "postgre")
}
GO;
    }

    /**
     * Generates the Go query builder utilities.
     *
     * This includes:
     * - `BuildQuery`: Generates SQL WHERE and ORDER BY clauses based on
     *   GraphQL-style filter and sort inputs. Supports dynamic operators,
     *   PostgreSQL-specific LIKE/ILIKE rules, and safe parameter binding.
     *
     * - `PaginationArgs`: Represents incoming pagination-related fields.
     *
     * - `GetPagination`: Computes page, limit, and offset values based
     *   on GraphQL pagination inputs, supporting default values and overrides.
     *
     * @return string The generated Go source code for input/query_builder.go
     */
    private function geterateQueryBuilder()
    {
        return <<<GO
package input

import (
	"fmt"
	"strings"
)

// BuildQuery constructs WHERE and ORDER BY clauses for SQL queries based on GraphQL inputs.
// It returns the WHERE clause, ORDER BY clause, and a slice of parameters for safe querying.
func BuildQuery(filter *[]*FilterInput, orderBy *[]*SortInput, isPostgres bool) (string, string, []interface{}) {
	var whereClauses []string
	var orderClauses []string
	var params []interface{}

	// Build WHERE clause from filter
	// Build WHERE clause from filter
	if filter != nil {
		for _, f := range *filter {
			if f == nil || f.Value == nil {
				continue
			}
			// Default operator is EQUALS
			op := "="
			val := f.Value.Value()

			if f.Operator != nil {
				operator := fmt.Sprintf("%v", *f.Operator)
				switch strings.ToUpper(operator) {
				case "NOT_EQUALS":
					op = "!="
				case "CONTAINS":
					// Use ILIKE for PostgreSQL for case-insensitive search, LIKE for others (e.g., MySQL).
					if isPostgres {
						op = "ILIKE"
					} else {
						op = "LIKE"
					}
					val = fmt.Sprintf("%%%v%%", val)
				case "GREATER_THAN":
					op = ">"
				case "GREATER_THAN_OR_EQUALS":
					op = ">="
				case "LESS_THAN":
					op = "<"
				case "LESS_THAN_OR_EQUALS":
					op = "<="
				case "IN", "NOT_IN":
					// For IN/NOT_IN, the value is a comma-separated string. We need to create placeholders.
					valStr := fmt.Sprintf("%v", val)
					values := strings.Split(valStr, ",")
					if len(values) > 0 {
						placeholders := strings.Repeat("?,", len(values))
						placeholders = strings.TrimSuffix(placeholders, ",")
						operator := fmt.Sprintf("%v", *f.Operator)
						whereClauses = append(whereClauses, fmt.Sprintf("%s %s (%s)", f.Field, strings.ToUpper(operator), placeholders))
						for _, v := range values {
							params = append(params, strings.TrimSpace(v))
						}
					}
					continue // Skip the generic param append at the end
				}
			}
			whereClauses = append(whereClauses, fmt.Sprintf("%s %s ?", f.Field, op))
			params = append(params, val)
		}
	}

	// Build ORDER BY clause
	if orderBy != nil {
		for _, s := range *orderBy {
			if s == nil || s.Field == "" {
				continue
			}
			dir := "ASC" // Default direction
			if s.Direction != nil && strings.ToUpper(*s.Direction) == "DESC" {
				dir = "DESC"
			}
			orderClauses = append(orderClauses, fmt.Sprintf("%s %s", s.Field, dir))
		}
	}

	whereSQL := ""
	if len(whereClauses) > 0 {
		whereSQL = "WHERE " + strings.Join(whereClauses, " AND ")
	}

	orderSQL := ""
	if len(orderClauses) > 0 {
		orderSQL = "ORDER BY " + strings.Join(orderClauses, ", ")
	}

	return whereSQL, orderSQL, params
}

// PaginationArgs holds common pagination arguments from GraphQL queries.
type PaginationArgs struct {
	Limit  *int32
	Offset *int32
	Page   *int32
	Size   *int32
}

// GetPagination calculates limit, page, and offset from pagination arguments.
// It sets default values and allows overriding them.
func GetPagination(args PaginationArgs) (limit, page, offset int32) {
	limit = 10 // Default limit
	if args.Limit != nil {
		limit = *args.Limit
	}
	// 'size' is an alias for 'limit'
	if args.Size != nil {
		limit = *args.Size
	}

	page = 1 // Default page
	if args.Page != nil {
		page = *args.Page
	}

	offset = (page - 1) * limit // Calculate offset from page and limit
	if args.Offset != nil {
		offset = *args.Offset // Allow direct offset override
	}

	return limit, page, offset
}
GO;
    }
    /**
     * Generates Go structs that represent GraphQL input types.
     *
     * Includes:
     * - `FilterInput`: Defines a filter rule with a field name, operator,
     *   and dynamic value using the custom `Any` scalar.
     * - `SortInput`: Defines sort order, including optional direction.
     *
     * These types are used when building dynamic filter and sorting queries.
     *
     * @return string The generated Go source code for input/input.go
     */
    private function geterateInput()
    {
        return <<<GO
package input

// FilterInput corresponds to the GraphQL FilterInput type.
type FilterInput struct {
	Field    string
	Value    *Any // Must be a pointer for custom scalar unmarshalling
	Operator *string
}

// SortInput corresponds to the GraphQL SortInput type.
type SortInput struct {
	Field     string
	Direction *string
}
GO;
    }

    /**
     * Generates the implementation of the custom `Any` GraphQL scalar.
     *
     * This scalar:
     * - Accepts any JSON value from the client.
     * - Stores it internally as an empty interface.
     * - Implements GraphQL unmarshalling for incoming values.
     * - Implements JSON marshaling when returning values.
     *
     * It is used primarily for dynamic filtering values.
     *
     * @return string The generated Go source code for input/any_scalar.go
     */
    private function geterateAnyScalar()
    {
return <<<GO
package input

import (
	"fmt"
)

// Any is a custom scalar type that can represent any value.
// It's used for the 'value' field in the FilterInput.
type Any struct{ v interface{} }

// ImplementsGraphQLType returns the name of the GraphQL type.
func (Any) ImplementsGraphQLType(name string) bool { return name == "Any" }

// UnmarshalGraphQL is called when a value is received from a client.
func (a *Any) UnmarshalGraphQL(input interface{}) error {
	a.v = input
	return nil
}

// MarshalJSON is called when sending a value to a client.
func (a Any) MarshalJSON() ([]byte, error) {
	return []byte(fmt.Sprintf("%q", a.v)), nil
}

// Value returns the underlying value of the Any scalar.
func (a *Any) Value() interface{} {
	return a.v
}
GO;
    }

    /**
     * Generates a Go file containing constant values used across the
     * GraphQL application. These constants cover:
     *
     * - Standard datetime formatting
     * - Keys used for storing and retrieving session values
     * - Keys for retrieving contextual metadata such as the client IP
     *
     * @return string The generated Go source code for constant/constant.go
     */
    private function geterateConstant()
    {
        return <<<GO
package constant

const (
	DateTimeFormat string  = "2006-01-02 15:04:05"
    RemoteAddr string      = "RemoteAddr"
	SessionKey string      = "SessionKey"
	SessionUsername string = "SessionUsername"
	SessionPassword string = "SessionPassword"
	SessionAdminId string  = "SessionAdminId"
)
GO;
    }

    /**
     * Generates the root GraphQL resolver interface and implementation.
     *
     * The generated code includes:
     * - `ResolverRoot` interface: Defines contract for all entity resolvers.
     * - `RootResolver` struct: Stores shared dependencies such as the DB
     *   connection and resolver instances.
     * - `NewRootResolver`: Instantiates a root resolver and initializes all
     *   table-specific query resolvers.
     *
     * This acts as the central point that gqlgen / graphql-go uses to
     * resolve all queries and mutations.
     *
     * @return string The generated Go source code for resolver/root_resolver.go
     */
    private function generateResolverRoot()
    {
        $packageName = $this->projectConfig['moduleName'];
        $types1 = [];
        $types2 = [];
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $types1[] = "\t{$pascalName}(ctx context.Context, args struct{ ID string }) (*{$pascalName}Resolver, error)";
            $types2[] = "\t*{$pascalName}QueryResolver";
            $types3[] = "\troot.{$pascalName}QueryResolver = New{$pascalName}QueryResolver(root)";
        }
        $code1 = implode("\r\n", $types1);
        $code2 = implode("\r\n", $types2);
        $code3 = implode("\r\n", $types3);
        return <<<GO
package resolver

import (
	"context"
	"database/sql"
)

type ResolverRoot interface {
	DBConnection() *sql.DB
$code1
}

func (r *RootResolver) DBConnection() *sql.DB {
	return r.db
}

type RootResolver struct {
	db *sql.DB
$code2
}

func NewRootResolver(db *sql.DB) *RootResolver {
	root := &RootResolver{db: db}
$code3
    return root
}
GO;
    }

    /**
     * Generates resolver files for every analyzed database table.
     *
     * Each resolver file includes:
     * - Type definitions
     * - Query resolvers
     * - Mutation resolvers (if implemented)
     * - Field resolvers for foreign-key relationships
     *
     * @return array List of generated resolver files, each containing filename and content.
     */
    private function generateResolvers()
    {
        $resolvers = [];
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $resolvers[] = ['name' => "resolver/{$tableName}.go", 'content' => $this->generateResolver($tableName, $tableInfo)];
        }
        return $resolvers;
    }

    /**
     * Generates the complete resolver file for a specific database table.
     *
     * A resolver file contains:
     * - Required import statements
     * - Type resolver definitions
     * - Field-level resolver methods
     * - Query resolvers (single and paginated list)
     * - Foreign key relationship resolvers
     *
     * @param string $tableName The database table name.
     * @param array $tableInfo  Metadata describing the table structure.
     *
     * @return string The complete Go resolver source file for this entity.
     */
    private function generateResolver($tableName, $tableInfo)
    {
        $contents = [];
        $contents[] = "package resolver";
        $contents[] = "";
        $contents[] = $this->generateResolverImport($tableInfo);
        $contents[] = $this->generateResolverType($tableName, $tableInfo);
        $contents[] = $this->generateResolverQuery($tableName, $tableInfo);
        $contents[] = $this->generateResolverMutation($tableName, $tableInfo);

        return implode("\r\n", $contents);
    }

    /**
     * Generates the import section for a resolver file.
     *
     * Imports are determined dynamically based on:
     * - Project module name
     * - Whether the table uses UUID auto-generation
     * - Whether PostgreSQL-specific behavior may be needed
     *
     * @param array $tableInfo Metadata describing the table structure.
     *
     * @return string A formatted import block.
     */
    private function generateResolverImport($tableInfo)
    {
        $packageName = $this->projectConfig['moduleName'];
        $libraries = [];
        $libraries[] = "\t\"context\"";
        $libraries[] = "\t\"database/sql\"";
        $libraries[] = "\t\"fmt\"";
        $libraries[] = "\t\"{$packageName}/config\"";
        $libraries[] = "\t\"{$packageName}/constant\"";
        $libraries[] = "\t\"{$packageName}/input\"";
        $libraries[] = "\t\"{$packageName}/model\"";
        $libraries[] = "\t\"strings\"";
        $libraries[] = "\t\"time\"";

        $autogenerated = false;
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey'] && $col['primaryKeyValue'] == 'autogenerated') {
                $autogenerated = true;
                break;
            }
        }

        if($autogenerated)
        {
            $libraries[] = "\r\n\t\"github.com/google/uuid\"";
        }
        
        return "import(\r\n".implode("\r\n", $libraries)."\r\n)\r\n";
        
    }

    /**
     * Generates Go type declarations for an entity resolver.
     *
     * Includes:
     * - Query resolver struct for entity-level operations
     * - Item resolver struct for field-level access
     * - Page resolver struct for paginated list responses
     *
     * @param string $tableName The database table name.
     * @param array $tableInfo  Metadata describing the table structure.
     *
     * @return string Resolver type definitions as Go source code.
     */
    private function generateResolverType($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $resolverName = $this->pascalCase($tableName);
        $resolverNamePlural = $this->pluralize($resolverName);
        $contents = [];
        $contents[] = "// {$resolverName}QueryResolver handles all queries and mutations for the {$resolverName} entity.
type {$resolverName}QueryResolver struct {
	root ResolverRoot
}

// {$resolverName}Resolver contains data for a single {$resolverName} object.
type {$resolverName}Resolver struct {
	m *model.{$resolverName}
	r *{$resolverName}QueryResolver
}

// {$resolverName}PageResolver contains data for a page/list of {$resolverNamePlural}.
type {$resolverName}PageResolver struct {
	items      []*{$resolverName}Resolver
	total      int32
	limit      int32
	page       int32
	totalPages int32
	hasNext    bool
	hasPrev    bool
}
";
        return implode("\r\n", $contents);
    }
    
    /**
     * Undocumented function
     *
     * @param string[] $methods
     * @param string $search
     * @return string[]
     */
    private function prettifyMethods($methods, $search)
    {
        if(!isset($methods) || empty($methods))
        {
            return array();
        }
        $max = 1;
        foreach($methods as $method)
        {
            $arr = explode($search, $method, 2);
            if(count($arr) == 2)
            {
                $length = strlen(rtrim($arr[0], " "));
                if($max < $length)
                {
                    $max = $length;
                }
            }
        }
        foreach($methods as $index => $method)
        {
            $arr = explode($search, $method, 2);
            if(count($arr) == 2)
            {
                $methods[$index] = sprintf("%-{$max}s %s%s", rtrim($arr[0], " "), $search, $arr[1]);
            }
        }
        return $methods;
    }

    /**
     * Generates GraphQL query resolver methods for a database entity.
     *
     * The generated methods include:
     * - Field resolver methods for every column
     * - Relationship resolvers for foreign keys
     * - A single-item query (fetch by primary key)
     * - A paginated list query with filtering and sorting
     *
     * Pagination, filtering, and sorting are delegated to the query builder,
     * while this resolver focuses on translating the data into model objects.
     *
     * @param string $tableName The database table name.
     * @param array $tableInfo  Metadata describing the table structure.
     *
     * @return string Query resolver implementations as Go source code.
     */
    private function generateResolverQuery($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $pascalNamePlural = $this->pluralize($pascalName);
        $singleResolver = "{$pascalName}Resolver";
        $pageResolver = "{$pascalName}PageResolver";

        $methods = [];
        $columnInfo = [];
        $maxLength = 1;
        $pkName = '';
        $columNames = [];
        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($maxLength < strlen($columnName))
            {
                $maxLength = strlen($columnName);
            }
            if($col['isPrimaryKey'] && empty($pkName))
            {
                $pkName = $columnName;
            }
            $columnInfo[] = [
                "name" => ucfirst($columnName),
                "type" => $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length']),
                "pointer" => $col['isPrimaryKey']
            ];
            $columNames[] = $columnName;
        }
        foreach($columnInfo as $info)
        {
            $goName = $this->goName($this->pascalCase($info['name']));
            $methods[] = sprintf("func (r *$singleResolver) %s() *%s { return %sr.m.$goName }", $info['name'], $info['type'], $info['pointer'] ? '&' : '');
        }
        $methods = $this->prettifyMethods($methods, "{ return");
        $entityMethods = implode("\r\n", $methods);

        $addCols = [];

        $relMethods = [];

        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($col['isForeignKey'])
            {
                $relEntity = $col['references'];
                $pascalEntityName = $this->pascalCase($relEntity);
                $fkName = $this->goName($this->pascalCase($columnName));
                $relMethods[] = "
// $pascalEntityName resolves the related $relEntity for this $pascalName.
func (r *$singleResolver) {$pascalEntityName}(ctx context.Context) (*{$pascalEntityName}Resolver, error) {
	if r.m.{$fkName} == nil {
		return nil, nil
	}
	return r.r.root.$pascalEntityName(ctx, struct{ ID string } { ID: *r.m.{$fkName} })
}
";
                
            }
            $goName = $this->goName($this->pascalCase($columnName));
            $addCols[] = "\t\t\t&m.{$goName},";
        }

        $relationMethods = implode("", $relMethods);
        
        $addresOfColumns1 = implode("\r\n", $addCols);
        $addresOfColumns1 = str_replace("\t\t\t", "\t\t", $addresOfColumns1);
        $addresOfColumns2 = implode("\r\n", $addCols);

        $columnList = implode(", ", $columNames);
        
        $listMethods = <<<GO
func (r *{$pageResolver}) Items() *[]*$singleResolver { return &r.items }
func (r *{$pageResolver}) Total() *int32 { return &r.total }
func (r *{$pageResolver}) Limit() *int32 { return &r.limit }
func (r *{$pageResolver}) Page() *int32 { return &r.page }
func (r *{$pageResolver}) TotalPages() *int32 { return &r.totalPages }
func (r *{$pageResolver}) HasNext() *bool { return &r.hasNext }
func (r *{$pageResolver}) HasPrevious() *bool { return &r.hasPrev }
GO;
        $listMethodsArr = explode("\n", $listMethods);
        $listMethodsArr = $this->prettifyMethods($listMethodsArr, "{ return");
        $listMethods = implode("\n", $listMethodsArr);
        
        $queries = <<<GO
// New{$pascalName}QueryResolver creates a new resolver for {$pascalName} queries.
func New{$pascalName}QueryResolver(root ResolverRoot) *{$pascalName}QueryResolver {
	return &{$pascalName}QueryResolver{root: root}
}

// Getter methods for $pascalName properties
$entityMethods
$relationMethods
// Methods for $pascalNamePlural
$listMethods

// {$pascalName} fetches a single {$tableName} by its ID.
func (r *{$pascalName}QueryResolver) {$pascalName}(ctx context.Context, args struct{ ID string }) (*$singleResolver, error) {
	
	tableName := "{$tableName}"
	columns := "$columnList"
	primaryKey := "{$pkName}"
	
	sqlQuery := fmt.Sprintf("SELECT %s FROM %s WHERE %s = ?", columns, tableName, primaryKey)
	row := r.root.DBConnection().QueryRowContext(ctx, sqlQuery, args.ID)
	m := model.{$pascalName}{}
	err := row.Scan(
$addresOfColumns1
	)
	if err != nil {
		if err == sql.ErrNoRows {
			return nil, nil
		}
		return nil, err
	}
	return &$singleResolver{m: &m, r: r}, nil
}

// {$pascalNamePlural} fetches a paginated list of {$pascalNamePlural}.
func (r *{$pascalName}QueryResolver) {$pascalNamePlural}(ctx context.Context, args struct {
	Limit   *int32
	Offset  *int32
	Page    *int32
	Size    *int32
	OrderBy *[]*input.SortInput
	Filter  *[]*input.FilterInput
}) (*{$pageResolver}, error) {

	tableName := "{$tableName}"
	columns := "$columnList"

	// Pagination
	limit, page, offset := input.GetPagination(input.PaginationArgs{
		Limit:  args.Limit,
		Offset: args.Offset,
		Page:   args.Page,
		Size:   args.Size,
	})

	// Build query

	whereSQL, orderSQL, params := input.BuildQuery(args.Filter, args.OrderBy, config.IsPostgres)
	countQuery := fmt.Sprintf("SELECT COUNT(*) FROM %s %s", tableName, whereSQL)

	// Count total items
	var total int32
	err := r.root.DBConnection().QueryRowContext(ctx, countQuery, params...).Scan(&total)
	if err != nil {
		return nil, err
	}

	// Fetch items
	queryParams := append(params, limit, offset)
	queryQuery := fmt.Sprintf("SELECT %s FROM %s %s %s LIMIT ? OFFSET ?", columns, tableName, whereSQL, orderSQL)
	rows, err := r.root.DBConnection().QueryContext(ctx, queryQuery, queryParams...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	items := []*$singleResolver{}
	for rows.Next() {
		m := model.{$pascalName}{}
		err := rows.Scan(
$addresOfColumns2
		)
		if err != nil {
			return nil, err
		}
		items = append(items, &$singleResolver{m: &m, r: r})
	}

	totalPages := int32(0)
	if total > 0 {
		totalPages = (total + limit - 1) / limit
	}

	return &{$pageResolver}{
		items:      items,
		total:      total,
		limit:      limit,
		page:       page,
		totalPages: totalPages,
		hasNext:    page < totalPages,
		hasPrev:    page > 1,
	}, nil
}
GO;
        return $queries;
    }

    /**
     * Generates Go GraphQL resolver mutation code for the specified database table.
     *
     * This method analyzes table metadata (columns, primary key, auto-increment,
     * auto-generated fields, backend-handled fields, etc.) and produces complete
     * mutation implementations for:
     * - Create
     * - Update
     * - Delete
     * - ToggleActive
     *
     * The generated Go code includes:
     * - Input struct definitions
     * - Field type mappings based on database column types
     * - INSERT and UPDATE query builders
     * - Automatic handling for backend-managed fields such as:
     *   - Creation time (timeCreate)
     *   - Update time (timeEdit)
     *   - Creation IP (ipCreate)
     *   - Update IP (ipEdit)
     *   - Admin ID for creation (adminCreate)
     *   - Admin ID for update (adminEdit)
     * - Support for UUID auto-generation when required
     * - Dynamic update field building based on non-null input values
     *
     * @param string $tableName
     *     Name of the database table to generate resolver mutations for.
     *
     * @param array $tableInfo
     *     Table structure information, including:
     *     - columns: array of column definitions
     *     - primary key properties
     *     - auto-increment or auto-generated indicators
     *
     * @return string
     *     A complete Go-language source code block containing all mutation
     *     resolvers for the specified table, ready to be written into a .go file.
     *
     * @throws Exception
     *     Throws an exception if required metadata is missing or inconsistent.
     */
    private function generateResolverMutation($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $activeField = $this->activeField;
        $activeFieldPascal = $this->pascalCase($this->activeField);
        $pkName = '';
        $colInfo = [];
        $maxLength = 1;
        foreach($tableInfo['columns'] as $columnName => $col)
        {
            if($col['isPrimaryKey'] && empty($pkName))
            {
                $pkName = $columnName;
            }
            
            $colInfo[] = [
                'name' => $this->goName($this->pascalCase($columnName)),
                'columnName' => $columnName,
                'type' => $this->mapDbTypeToGoTypeAsModel($col['type'], $col['length'])
            ];
            if($maxLength < strlen($columnName))
            {
                $maxLength = strlen($columnName);
            }
        }
        $autoincrement = false;
        $autogenerated = false;
        $columnToInsert = [];
        $updateCode = [];
        $toggleCode = [];
        $placeholderUpdate = [];
        $par = [];
        $paramInsert = [];
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        $autogeneratedCol = '';
        foreach ($tableInfo['columns'] as $colName => $col) {
            if ($col['isPrimaryKey'] && ($col['primaryKeyValue'] == 'autoincrement') && $autoincrement) {
                $autoincrement = true;
                continue;
            }
            if ($col['isPrimaryKey'] && ($col['primaryKeyValue'] == 'autogenerated') && !$autogenerated) {
                $autogenerated = true;
                $autogeneratedCol = $colName;
                continue;
            }
            if(in_array($colName, $backendHandledColumnNames))
            {
                continue;
            }
            $gn = $this->goName($this->pascalCase($colName));
            $columnToInsert[] = $colName;
            $placeholderUpdate[] = "?";
            $par[] = "\tparams = append(params, args.Input.".$gn.")";
            $paramInsert[] = "\tfields = append(fields, \"{$colName}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, args.Input.".$gn.")\r\n";

            $updateCode[] = <<<GO
    if args.Input.{$gn} != nil {
        fields = append(fields, "{$colName} = ?")
        params = append(params, *args.Input.{$gn})
    }

GO;
        }
        $entityColumns = [];
        foreach ($tableInfo['columns'] as $colName => $col) {
            $entityColumns[] = $colName;
        }
        $tp = [];

        $toggleCode[] = <<<GO
    fields = append(fields, "{$activeField} = ?")
    params = append(params, args.{$activeFieldPascal})

GO;

        foreach($this->backendHandledColumns as $k=>$v)
        {
            $gn = $this->goName($this->pascalCase($v['columnName']));
            if(($k == 'timeCreate' || $k == 'timeEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($placeholderUpdate, "?");
                array_push($par, "\tparams = append(params, time.Now().Format(constant.DateTimeFormat))"); 
                if($k == 'timeEdit')
                {
                    $updateCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, time.Now().Format(constant.DateTimeFormat))

GO;
                    $toggleCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, time.Now().Format(constant.DateTimeFormat))

GO;
                }
                $paramInsert[] = "\tfields = append(fields, \"{$v['columnName']}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, time.Now().Format(constant.DateTimeFormat))\r\n";
            }
            if(($k == 'ipCreate' || $k == 'ipEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($placeholderUpdate, "?");
                array_push($par, "\tparams = append(params, ctx.Value(constant.RemoteAddr).(string))"); 
                if($k == 'ipEdit')
                {
                    $updateCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.RemoteAddr).(string))

GO;
                    $toggleCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.RemoteAddr).(string))

GO;
                }
                $paramInsert[] = "\tfields = append(fields, \"{$v['columnName']}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, ctx.Value(constant.RemoteAddr).(string))\r\n";
            }
            if(($k == 'adminCreate' || $k == 'adminEdit') && in_array($v['columnName'], $entityColumns))
            {
                array_push($columnToInsert, $v['columnName']);
                array_push($placeholderUpdate, "?");
                array_push($par, "\tparams = append(params, ctx.Value(constant.SessionAdminId).(string))"); 
                if($k == 'adminEdit')
                {
                    $updateCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.SessionAdminId).(string))

GO;
                    $toggleCode[] = <<<GO
    fields = append(fields, "{$v['columnName']} = ?")
    params = append(params, ctx.Value(constant.SessionAdminId).(string))

GO;
                }
                $paramInsert[] = "\tfields = append(fields, \"{$v['columnName']}\")\r\n\tplaceholders = append(placeholders, \"?\")\r\n\tparams = append(params, ctx.Value(constant.SessionAdminId).(string))\r\n";
            }
        }

        $tp[] = "{$this->activeField} = ?";

        $uuid = "";
        if($autogenerated)
        {
            array_unshift($columnToInsert, $autogeneratedCol);
            array_unshift($placeholderUpdate, "?");
            array_unshift($par, "\tparams = append(params, id)");
            $uuid = "\r\n\tid := uuid.New().String()\r\n";
        }

        $paramSet = implode("\r\n", $paramInsert);
        $updateCodes = implode("\r\n", $updateCode);
        $toggleCodes = implode("\r\n", $toggleCode);

        $defs = [];
        foreach($colInfo as $info)
        {
            if(in_array($info['columnName'], $backendHandledColumnNames))
            {
                continue;
            }
            $defs[] = sprintf("\t%-{$maxLength}s *%s", $info['name'], $info['type']);
        }
        $typeDefinitions = implode("\r\n", $defs);

        $activeField = $this->activeField;

        $mutation = <<<GO
// --- Mutations ---

type {$pascalName}Input struct {
$typeDefinitions
}

// Create{$pascalName} creates a new {$tableName}.
func (r *{$pascalName}QueryResolver) Create{$pascalName}(ctx context.Context, args struct{ Input {$pascalName}Input }) (*{$pascalName}Resolver, error) {

	tableName := "{$tableName}"
$uuid
    var fields []string
    var placeholders []string
    var params []interface{}

$paramSet

	query := fmt.Sprintf("INSERT INTO %s (%s) VALUES (%s)", tableName, strings.Join(fields, ", "), strings.Join(placeholders, ", "))
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, fmt.Errorf("failed to create %s: %w", tableName, err)
	}
	return r.{$pascalName}(ctx, struct{ ID string }{ID: id})
}

// Update{$pascalName} updates an existing {$tableName}.
func (r *{$pascalName}QueryResolver) Update{$pascalName}(ctx context.Context, args struct {
	ID    string
	Input {$pascalName}Input
}) (*{$pascalName}Resolver, error) {

	tableName := "{$tableName}"
	primaryKey := "{$pkName}"

	var fields []string
	var params []interface{}

$updateCodes
    params = append(params, args.ID)

	if len(fields) == 0 {
		return nil, fmt.Errorf("no fields to update")
	}

	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?", tableName, strings.Join(fields, ", "), primaryKey)
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, fmt.Errorf("failed to update %s: %w", tableName, err)
	}
	return r.{$pascalName}(ctx, struct{ ID string }{ID: args.ID})
}

// Delete{$pascalName} deletes a {$tableName} by its ID.
func (r *{$pascalName}QueryResolver) Delete{$pascalName}(ctx context.Context, args struct{ ID string }) (bool, error) {

	tableName := "{$tableName}"
	primaryKey := "{$pkName}"

	sqlQuery := fmt.Sprintf("DELETE FROM %s WHERE %s = ?", tableName, primaryKey)

	_, err := r.root.DBConnection().ExecContext(ctx, sqlQuery, args.ID)
	if err != nil {
		return false, fmt.Errorf("failed to delete %s: %w", tableName, err)
	}
	return true, nil
}

// Toggle{$pascalName}Active changes the active status of a {$tableName}.
func (r *{$pascalName}QueryResolver) Toggle{$pascalName}Active(ctx context.Context, args struct {
	ID string
	{$activeFieldPascal} bool
}) (*{$pascalName}Resolver, error) {
	tableName := "{$tableName}"
	primaryKey := "{$pkName}"
	activeField := "{$activeField}"

    var fields []string
	var params []interface{}

$toggleCodes
    params = append(params, args.ID)

	query := fmt.Sprintf("UPDATE %s SET %s WHERE %s = ?", tableName, strings.Join(fields, ", "), primaryKey)
	_, err := r.root.DBConnection().ExecContext(ctx, query, params...)
	if err != nil {
		return nil, fmt.Errorf("failed to change %s.%s status: %w", tableName, activeField, err)
	}
	return r.{$pascalName}(ctx, struct{ ID string }{ID: args.ID})
}
GO;
        return $mutation;
    }

    /**
     * Generates the content for the go.mod file.
     *
     * @return string The content for go.mod.
     */
    public function generateGoMod()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $goVersion = $this->projectConfig['goVersion'];

        return <<<MOD
module $moduleName

go $goVersion

require (
	github.com/go-sql-driver/mysql v1.9.3
	github.com/google/uuid v1.6.0
	github.com/gorilla/sessions v1.4.0
	github.com/graph-gophers/graphql-go v1.8.0
	github.com/joho/godotenv v1.5.1
)

require (
	filippo.io/edwards25519 v1.1.0 // indirect
	github.com/gorilla/securecookie v1.1.2 // indirect
)
MOD;
    }

    /**
     * Generates the main.go file.
     *
     * @return string The content of main.go.
     */
    public function generateMainGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package main

import (
	"context"
	"database/sql"
	"encoding/json"
	"fmt"
	"$moduleName/constant"
	"$moduleName/handler"
	"$moduleName/resolver"
	"log"
	"net"
	"net/http"
	"os"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	_ "github.com/go-sql-driver/mysql"
	"github.com/gorilla/sessions"
	"github.com/graph-gophers/graphql-go"
	"github.com/graph-gophers/graphql-go/relay"
	"github.com/joho/godotenv"
)

var store *sessions.CookieStore

// ipMiddleware injects the client's IP address into the request context.
func ipMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		ip := GetClientIP(r)

		session, err := store.Get(r, constant.SessionKey)
		if err != nil {
			log.Printf("session error: %v", err)
		}

		var adminId string
		if v, ok := session.Values[constant.SessionAdminId]; ok {
			if s, ok2 := v.(string); ok2 {
				adminId = s
			}
		}

		ctx := r.Context()
		ctx = context.WithValue(ctx, constant.RemoteAddr, ip)
		ctx = context.WithValue(ctx, constant.SessionAdminId, adminId)

		next.ServeHTTP(w, r.WithContext(ctx))
	})
}

// authMiddleware checks if a user is logged in before allowing access to a handler.
// It only enforces the check if the REQUIRE_LOGIN environment variable is set to "true".
func authMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Only check for login if REQUIRE_LOGIN is explicitly true
		if os.Getenv("REQUIRE_LOGIN") != "true" {
			next.ServeHTTP(w, r)
			return
		}

		session, _ := store.Get(r, constant.SessionKey)
		username, ok := session.Values[constant.SessionUsername].(string)

		if !ok || username == "" {
			http.Error(w, "Unauthorized", http.StatusUnauthorized)
			return
		}

		next.ServeHTTP(w, r)
	})
}
func GetClientIP(r *http.Request) string {
	// Check for X-Forwarded-For header, which can be a comma-separated list.
	// The client's IP is typically the first one.
	if forwardedFor := r.Header.Get("X-Forwarded-For"); forwardedFor != "" {
		// Split the list and return the first IP
		ips := strings.Split(forwardedFor, ",")
		if len(ips) > 0 {
			return strings.TrimSpace(ips[0])
		}
	}

	// Check for X-Real-IP header.
	if realIP := r.Header.Get("X-Real-IP"); realIP != "" {
		return realIP
	}

	// Fallback to the remote address.
	ip, _, _ := net.SplitHostPort(r.RemoteAddr)
	return ip
}

func main() {
	// Load variables from .env file
	err := godotenv.Load()
	if err != nil {
		log.Println("Warning: Could not load .env file. Using system environment variables.")
	}

	// Initialize session store
	sessionSecret := os.Getenv("SESSION_SECRET")
	if sessionSecret == "" {
		log.Fatal("SESSION_SECRET environment variable is not set")
	}
	store = sessions.NewCookieStore([]byte(sessionSecret))

	// Build DSN (Data Source Name) from environment variables
	dsn := fmt.Sprintf("%s:%s@tcp(%s:%s)/%s",
		os.Getenv("DB_USER"),
		os.Getenv("DB_PASS"),
		os.Getenv("DB_HOST"),
		os.Getenv("DB_PORT"),
		os.Getenv("DB_NAME"),
	)

	driver := os.Getenv("DB_DRIVER")

	// Open database connection
	db, err := sql.Open(driver, dsn)
	if err != nil {
		log.Fatal(err)
	}
	defer db.Close()

	// Read GraphQL schema from file
	schemaPath := os.Getenv("GRAPHQL_SCHEMA")
	schemaData, err := os.ReadFile(schemaPath)
	if err != nil {
		log.Fatalf("Failed to read schema file %s: %v", schemaPath, err)
	}

	// Parse GraphQL schema
	schema := graphql.MustParseSchema(string(schemaData), resolver.NewRootResolver(db))

	// Set handler for GraphQL endpoint
	graphqlEndpoint := os.Getenv("GRAPHQL_ENDPOINT")
	http.Handle(graphqlEndpoint, ipMiddleware(&relay.Handler{Schema: schema}))

	// Initialize and register authentication handlers
	authHandler := &handler.AuthHandler{
		DB:    db,
		Store: store,
	}
	http.HandleFunc("/login", authHandler.Login)
	http.HandleFunc("/logout", authHandler.Logout)

	// Handler for available themes, mimicking the PHP logic.
	http.HandleFunc("/available-theme", func(w http.ResponseWriter, r *http.Request) {
		themesPath := "static/assets/themes"

		type Theme struct {
			Name  string `json:"name"`
			Title string `json:"title"`
		}

		var themes []Theme

		entries, err := os.ReadDir(themesPath)
		if err != nil {
			log.Printf("Warning: Could not read themes directory '%s': %v", themesPath, err)
			// Return empty list if directory doesn't exist, similar to PHP's glob behavior.
		} else {
			for _, entry := range entries {
				if entry.IsDir() {
					themeName := entry.Name()
					cssPath := filepath.Join(themesPath, themeName, "style.min.css")
					if _, err := os.Stat(cssPath); err == nil {
						// File exists, add it to the list.
						title := strings.Title(strings.ToLower(strings.ReplaceAll(strings.ReplaceAll(themeName, "-", " "), "_", " ")))
						themes = append(themes, Theme{Name: themeName, Title: title})
					}
				}
			}
		}

		// Set headers for JSON content type and caching
		cacheTimeStr := os.Getenv("THEME_CACHE_TIME")
		cacheTime, err := strconv.Atoi(cacheTimeStr)
		if err != nil || cacheTime <= 0 {
			cacheTime = 86400 // Default to 24 hours (86400 seconds)
		}

		w.Header().Set("Content-Type", "application/json")
		w.Header().Set("Cache-Control", fmt.Sprintf("public, max-age=%d", cacheTime))
		w.Header().Set("Expires", time.Now().Add(time.Duration(cacheTime)*time.Second).Format(http.TimeFormat))

		json.NewEncoder(w).Encode(themes)
	})

	// Handler for serving static assets from the /assets directory
	assetsPath := "/assets/"
	assetsDir := "static/assets"
	http.Handle("/assets/", http.StripPrefix("/assets/", http.FileServer(http.Dir("static/assets"))))
	http.Handle("/langs/", http.StripPrefix("/langs/", http.FileServer(http.Dir("static/langs"))))

	// Handler for frontend configuration, now protected by authMiddleware.
	frontendConfigHandler := http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Set headers to prevent caching by the browser.
		w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, proxy-revalidate")
		w.Header().Set("Pragma", "no-cache")
		w.Header().Set("Expires", "0")
		w.Header().Set("Surrogate-Control", "no-store")

		http.ServeFile(w, r, "static/config/frontend-config.json")
	})
	http.Handle("/frontend-config", authMiddleware(frontendConfigHandler))

	// Handler for serving the static index.html file
	http.HandleFunc("/", func(w http.ResponseWriter, r *http.Request) {
		// If the path is not the root, return a 404 to avoid this handler
		// catching all undefined paths.
		if r.URL.Path != "/" && r.URL.Path != "/index.html" {
			http.NotFound(w, r)
			return
		}
		http.ServeFile(w, r, "static/index.html")
	})
	http.HandleFunc("/favicon.ico", func(w http.ResponseWriter, r *http.Request) {
		http.ServeFile(w, r, "static/favicon.ico")
	})

	// Run HTTP server
	serverPort := os.Getenv("SERVER_PORT")
	log.Printf("Server is running at: http://localhost:%s%s", serverPort, graphqlEndpoint)
	log.Printf("Logout endpoint is available at http://localhost:%s/logout", serverPort)
	log.Printf("Login endpoint is available at http://localhost:%s/login", serverPort)
	log.Printf("Serving available themes on http://localhost:%s/available-theme", serverPort)
	log.Printf("Serving frontend config on http://localhost:%s/frontend-config", serverPort)
	log.Printf("Serving assets from ./%s on http://localhost:%s%s", assetsDir, serverPort, assetsPath)
	log.Printf("Serving web page index.html on http://localhost:%s/", serverPort)
	log.Fatal(http.ListenAndServe(":"+serverPort, nil))
}
GO;
    }

    /**
     * Converts a given name into a Go-style exported field name.
     *
     * This method first transforms the input into PascalCase, ensuring that
     * the generated name follows Go's exported identifier convention.
     * Additionally, it normalizes any trailing "Id" into the Go-preferred "ID".
     *
     * Examples:
     * - "user_id"   → "UserID"
     * - "adminName" → "AdminName"
     * - "roleId"    → "RoleID"
     *
     * @param string $name The original column or field name.
     * @return string The transformed Go-style field name.
     */
    private function goName($name)
    {
        $name = $this->pascalCase($name);
        if(PicoStringUtil::endsWith($name, 'Id'))
        {
            $name = substr($name, 0, strlen($name) - 2).'ID';
        }
        return $name;
    }

    /**
     * Generates a model file (struct) for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the model file.
     */
    private function generateModelFile($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $structFields = "";
        $fieldNames = [];
        $fieldTypes = [];
        $maxLength = 1;
        $index = 0;
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $goType = $this->mapDbTypeToGoTypeAsModel($colInfo['type'], $colInfo['length']);
            $fieldName = $this->goName($colName);
            if(strlen($fieldName) > $maxLength)
            {
                $maxLength = strlen($fieldName);
            }

            if (!$colInfo['isPrimaryKey']) {
                $goType = "*".$goType;
            }

            $fieldNames[$index] = $fieldName;
            $fieldTypes[$index] = $goType;
            $index++;
        }
        foreach($fieldNames as $index => $fieldName)
        {
            $structFields .= sprintf("\t%-{$maxLength}s %s\r\n", $fieldName, $fieldTypes[$index]);
        }


        return <<<GO
package model

// $pascalName represents the $tableName table.
type $pascalName struct {
$structFields}
GO;
    }

    /**
     * Generates the resolver.go file.
     *
     * @return string The content of resolver.go.
     */
    public function generateResolverGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package graph

import (
    "{$moduleName}/config"
    "gorm.io/gorm"
)

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

type Resolver struct{
    DB *gorm.DB
    Cfg *config.Config
}
GO;
    }

    /**
     * Generates the combined GraphQL schema file.
     *
     * @return string The content of schema.graphqlss.
     */
    private function generateCombinedSchema()
    {
        $allTypes = "";
        $allQueries = "";
        $allMutations = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allTypes .= $schemaParts['types'] . "\n";
            $allQueries .= $schemaParts['queries'] . "\n";
            $allMutations .= $schemaParts['mutations'] . "\n";
        }

        return <<<GQL
scalar Any

enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: Any
    operator: FilterOperator
}

$allTypes

type Query {
$allQueries
}

type Mutation {
$allMutations
}
GQL;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo)
    {
        $pascalName = $this->pascalCase($tableName);
        $camelName = $this->camelCase($tableName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $typeFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName;
            $typeFields .= "    $fieldName: $gqlType\n";

            if ($colInfo['isForeignKey']) {
                $refPascalName = $this->pascalCase($colInfo['references']);
                $refFieldName = $colInfo['references'];
                $typeFields .= "    $refFieldName: $refPascalName\n";
            }
        }

        // Input fields
        $inputFields = "";
        $backendHandledColumnNames = $this->getBackendHandledColumnNames();
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            $gqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']));
            $fieldName = $colName;
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $pkGqlType = 'String!';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkGqlType = $this->mapGoTypeToGqlType($this->mapDbTypeToGoType($col['type'], $col['length'])) . '!';
                break;
            }
        }

        $types = <<<GQL
type $pascalName {
$typeFields}

input {$pascalName}Input {
$inputFields}

type {$pascalName}Page {
    items: [$pascalName]
    total: Int
    page: Int
    limit: Int
    totalPages: Int
    hasNext: Boolean
    hasPrevious: Boolean
}
GQL;
        $camelMethodName = $camelName;
        $pluralMethodName = $pluralCamelName;

        $queries = "    $camelMethodName(id: $pkGqlType): $pascalName\n";
        $queries .= "    $pluralMethodName(limit: Int, offset: Int, page: Int, orderBy: [SortInput], filter: [FilterInput]): {$pascalName}Page\n";

        $mutations = "    create{$pascalName}(input: {$pascalName}Input!): $pascalName\n";
        $mutations .= "    update{$pascalName}(id: $pkGqlType, input: {$pascalName}Input!): $pascalName\n";
        $mutations .= "    delete{$pascalName}(id: $pkGqlType): Boolean!\n";

        if ($tableInfo['hasActiveColumn']) {
            $activeField = $this->camelCase($this->activeField);
            $mutations .= "    toggle{$pascalName}Active(id: {$pkGqlType}, $activeField: Boolean!): $pascalName\n";
        }

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Generates the auth.go file for login/logout logic.
     *
     * @return string The content of auth.go.
     */
    public function generateAuthGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package handler

import (
	"crypto/sha1"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"{$moduleName}/constant"
	"log"
	"net/http"
	"strings"

	"github.com/gorilla/sessions"
)

type AuthHandler struct {
	DB    *sql.DB
	Store sessions.Store
}

// doubleSha1 calculates sha1(sha1(password)).
func doubleSha1(input string) string {
	h1 := sha1.New()
	h1.Write([]byte(input))
	step1 := hex.EncodeToString(h1.Sum(nil))

	h2 := sha1.New()
	h2.Write([]byte(step1))
	return hex.EncodeToString(h2.Sum(nil))
}

// singleSha1 calculates sha1(password) to be stored in the session.
func singleSha1(input string) string {
	h := sha1.New()
	h.Write([]byte(input))
	return hex.EncodeToString(h.Sum(nil))
}

func (h *AuthHandler) Login(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)
		return
	}

	// === CONTENT TYPE VALIDATION ===
	ct := r.Header.Get("Content-Type")

	if ct == "" {
		h.respondAuthError(w, "Invalid content type")
		return
	}

	// multipart/form-data
	if strings.HasPrefix(ct, "multipart/form-data") {
		if err := r.ParseMultipartForm(10 << 20); err != nil { // 10 MB
			h.respondAuthError(w, "Invalid multipart form")
			return
		}
	} else if strings.HasPrefix(ct, "application/x-www-form-urlencoded") {
		if err := r.ParseForm(); err != nil {
			h.respondAuthError(w, "Invalid urlencoded form")
			return
		}
	} else {
		h.respondAuthError(w, "Unsupported content type: "+ct)
		return
	}

	// Now FormValue works
	username := r.FormValue("username")
	password := r.FormValue("password")

	if username == "" || password == "" {
		h.respondAuthError(w, "Invalid credentials")
		return
	}

	// Fetch full user, like PHP: SELECT * FROM admin WHERE username = :username
	var dbAdminId, dbUsername, dbPassword string
	err := h.DB.QueryRow(
		"SELECT admin_id, username, password FROM admin WHERE username = ?",
		username,
	).Scan(&dbAdminId, &dbUsername, &dbPassword)

	if err != nil {
		if err != sql.ErrNoRows {
			log.Printf("Login database error: %v", err)
		}
		h.respondAuthError(w, "Invalid credentials")
		return
	}

	// Compare sha1(sha1(password))
	if doubleSha1(password) != dbPassword {
		h.respondAuthError(w, "Invalid credentials")
		return
	}

	// Success -> save session
	session, _ := h.Store.Get(r, constant.SessionKey)
	session.Values[constant.SessionUsername] = dbUsername
	session.Values[constant.SessionPassword] = singleSha1(password)
	session.Values[constant.SessionAdminId] = dbAdminId
	session.Save(r, w)

	// Header + JSON output
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")

	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

// Logout
func (h *AuthHandler) Logout(w http.ResponseWriter, r *http.Request) {
	session, err := h.Store.Get(r, constant.SessionKey)
	if err != nil {
		log.Printf("Could not get session on logout: %v", err)
	}
	session.Options.MaxAge = -1
	session.Save(r, w)

	w.Header().Set("Content-Type", "application/json")
	json.NewEncoder(w).Encode(map[string]bool{"success": true})
}

func (h *AuthHandler) respondAuthError(w http.ResponseWriter, msg string) {
	w.Header().Set("HTTP/1.1", "401 Unauthorized")
	w.Header().Set("Content-Type", "application/json; charset=utf-8")
	w.Header().Set("Access-Control-Allow-Origin", "*")
	w.WriteHeader(http.StatusUnauthorized)
	json.NewEncoder(w).Encode(map[string]interface{}{
		"success": false,
		"message": msg,
	})
}
GO;
    }

    /**
     * Generates the Admin model struct.
     *
     * @return string The content of admin.go.
     */
    public function generateAdminModelGo()
    {
        return <<<GO
package modelcore

// Admin represents the admin table.
type Admin struct {
	AdminID      string `json:"adminId" gorm:"column:admin_id;primaryKey"`
	Username     string `json:"username" gorm:"column:username"`
	Password     string `json:"password" gorm:"column:password"`
	Name         string `json:"name" gorm:"column:name"`
	Email        string `json:"email" gorm:"column:email"`
	AdminLevelID string `json:"adminLevelId" gorm:"column:admin_level_id"`
	Active       bool   `json:"active" gorm:"column:active"`
}
GO;
    }

    /**
     * Maps a Java type to a GraphQL type for schema generation.
     *
     * @param string $goType The Go type.
     * @return string The corresponding GraphQL type.
     */
    private function mapGoTypeToGqlType($goType)
    {
        switch ($goType) {
            case 'int':
            case 'int32':
            case 'int64':
                return 'Int';
            case 'float32':
            case 'float64':
                return 'Float';
            case 'bool':
                return 'Boolean';
            case 'time.Time':
                return 'String';
            case 'string':
            default:
                return 'String';
        }
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $moduleName = $this->projectConfig['moduleName'];
        // This is a simplified version. A full implementation would be similar to the Java one.
        $manualContent = "# GraphQL API Manual (Go)\r\n\r\n";
        $manualContent .= "This document provides examples for your Go GraphQL API.\r\n\r\n";
        $manualContent .= "## How to Run\r\n\r\n";
        $manualContent .= "1.  Ensure you have Go " . $this->projectConfig['goVersion'] . " or later installed.\n";
        $manualContent .= "2.  Create a `.env` file in the root directory and configure your database connection:\n\n";
        $manualContent .= "    ```\n";
        $manualContent .= "    DB_HOST=localhost\n";
        $manualContent .= "    DB_PORT=3306\n";
        $manualContent .= "    DB_USER=your_user\n";
        $manualContent .= "    DB_PASS=your_password\n";
        $manualContent .= "    DB_NAME=your_database\n";
        $manualContent .= "    DB_DRIVER=mysql\n";
        $manualContent .= "    SERVER_PORT=8080\n";
        $manualContent .= "    SESSION_SECRET=change-this-to-a-random-string\n";
        $manualContent .= "    REQUIRE_LOGIN=" . ($this->requireLogin ? 'true' : 'false') . "\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "3.  Install dependencies:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go mod init $moduleName\n";
        $manualContent .= "    go get github.com/graph-gophers/graphql-go\n";
        $manualContent .= "    go get github.com/graph-gophers/graphql-go/relay\n";
        $manualContent .= "    go get github.com/go-sql-driver/mysql\n";
        $manualContent .= "    go get github.com/google/uuid\n";
        $manualContent .= "    go get github.com/joho/godotenv\n";
        $manualContent .= "    go get github.com/gorilla/sessions\n";
        $manualContent .= "    go mod tidy\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "4.  Run the application:\n\n";
        $manualContent .= "    ```bash\n";
        $manualContent .= "    go run .\n";
        $manualContent .= "    ```\n\n";
        $manualContent .= "The GraphQL playground will be available at `http://localhost:8080/`.\n";

        // Add query/mutation examples similar to the Java generator
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $ucCamelName = ucfirst($camelName);

            $manualContent .= "## " . $ucCamelName . "\r\n\r\n";

            // --- Get Fields for examples ---
            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true); // No relations for mutation return

            // --- Query Examples ---
            $manualContent .= "### Queries\r\n\r\n";

            // Get Single Item
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $ucCamelName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-" . $camelName . "-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Get List
            $manualContent .= "#### Get a list of " . $pluralCamelName . " (with filter & sort)\r\n\r\n";
            $manualContent .= "Supports `limit`, `offset`, `orderBy`, and `filter`.\r\n\r\n";

            // Find a good column for the filter example
            $filterField = $tableInfo['primaryKey'];
            $filterValue = '"your-' . $camelName . '-id"';
            $filterOperator = 'EQUALS';

            // Prefer 'name' or 'title' for a CONTAINS filter
            foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
                if (($columnName === 'name' || $columnName === 'title') && !$columnInfo['isForeignKey']) {
                    $filterField = $columnName;
                    $filterValue = '"some-text"';
                    $filterOperator = 'CONTAINS';
                    break;
                }
            }

            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . ucfirst($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(\r\n    limit: 10, \r\n    offset: 0, \r\n    orderBy: [{field: \"" . $tableInfo['primaryKey'] . "\", direction: DESC}],\r\n    filter: [{field: \"" . $filterField . "\", value: " . $filterValue . ", operator: " . $filterOperator . "}]\r\n  ) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString); // Indent fields
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "    limit\r\n";
            $manualContent .= "    page\r\n";
            $manualContent .= "    totalPages\r\n";
            $manualContent .= "    hasNext\r\n";
            $manualContent .= "    hasPrevious\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // --- Mutation Examples ---
            $manualContent .= "### Mutations\r\n\r\n";

            // Get Input Fields for mutations
            list($inputFieldsString, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            // Create
            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $ucCamelName . " {\r\n";
            $manualContent .= "  create" . $ucCamelName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Update
            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $ucCamelName . " {\r\n";
            $manualContent .= "  update" . $ucCamelName . "(id: \"your-" . $camelName . "-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Delete
            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "Returns `true` on success.\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $ucCamelName . " {\r\n";
            $manualContent .= "  delete" . $ucCamelName . "(id: \"your-" . $camelName . "-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        // --- API Reference Guide ---
        $manualContent .= "## API Reference Guide\r\n\r\n";
        $manualContent .= "This section provides a reference for common arguments used in list queries.\r\n\r\n";

        // Filtering
        $manualContent .= "### Filtering (`filter`)\r\n\r\n";
        $manualContent .= "The `filter` argument allows you to narrow down results based on field values. It accepts a list of filter objects, which are combined with `AND` logic.\r\n\r\n";
        $manualContent .= "| Operator       | Description                                      | Example                                                |\r\n";
        $manualContent .= "|----------------|--------------------------------------------------|--------------------------------------------------------|\r\n";
        $manualContent .= "| `EQUALS`       | Finds records where the field exactly matches the value. | `{field: \"status\", value: \"published\"}`                |\r\n";
        $manualContent .= "| `NOT_EQUALS`   | Finds records where the field does not match the value. | `{field: \"status\", value: \"archived\", operator: NOT_EQUALS}` |\r\n";
        $manualContent .= "| `CONTAINS`     | Finds records where the text field contains the value (`LIKE '%value%'`). | `{field: \"title\", value: \"love\", operator: CONTAINS}` |\r\n";
        $manualContent .= "| `GREATER_THAN_OR_EQUALS` | Finds records where the numeric/date field is greater than or equal to the value. | `{field: \"price\", value: \"99.99\", operator: GREATER_THAN_OR_EQUALS}` |\r\n";
        $manualContent .= "| `GREATER_THAN` | Finds records where the numeric/date field is greater than the value. | `{field: \"price\", value: \"100\", operator: GREATER_THAN}` |\r\n";
        $manualContent .= "| `LESS_THAN_OR_EQUALS`    | Finds records where the numeric/date field is less than or equal to the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN_OR_EQUALS}`   |\r\n";
        $manualContent .= "| `LESS_THAN`    | Finds records where the numeric/date field is less than the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN}`   |\r\n";
        $manualContent .= "| `IN` / `NOT_IN` | Finds records where the field value is in (or not in) a comma-separated list of values. | `{field: \"category_id\", value: \"1,2,3\", operator: IN}` |\r\n\r\n";

        // Sorting
        $manualContent .= "### Sorting (`orderBy`)\r\n\r\n";
        $manualContent .= "The `orderBy` argument sorts the results. It accepts a list of sort objects.\r\n\r\n";
        $manualContent .= "- `field`: The name of the field to sort by (e.g., `\"name\"`).\r\n";
        $manualContent .= "- `direction`: The sort direction. Can be `ASC` (ascending) or `DESC` (descending). Defaults to `ASC`.\r\n\r\n";
        $manualContent .= "**Example:** `orderBy: [{field: \"release_date\", direction: DESC}]`\r\n\r\n";

        // Pagination
        $manualContent .= "### Pagination (`limit` & `offset`)\r\n\r\n";
        $manualContent .= "- `limit`: Specifies the maximum number of records to return.\r\n";
        $manualContent .= "- `offset`: Specifies the number of records to skip from the beginning.\r\n\r\n";
        $manualContent .= "**Example:** To get the second page of 10 items: `limit: 10, offset: 10`\r\n\r\n";

        return $manualContent;
    }
}