<?php

namespace AppBuilder;

/**
 * The `GraphQLGeneratorGo` class is a powerful tool designed to automatically generate a complete Go GraphQL API from a JSON file that defines database entities.
 * It inspects the schema to understand tables, columns, primary keys, and foreign key relationships.
 * Based on this analysis, it produces Go code for models (structs), repositories, GraphQL resolvers, and schema files, along with a comprehensive API manual in Markdown format.
 * This class streamlines the process of scaffolding a GraphQL API in Go, reducing manual effort and ensuring consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorGo extends GraphQLGeneratorBase
{
    /**
     * @var array<string, string> Project configuration for go.mod and package structure.
     */
    private $projectConfig = array();

    /**
     * @var bool Whether to enable verbose logging in the generated application.
     */
    private $verboseLogging = false;

    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * @var bool Whether to generate with an integrated frontend.
     */
    private $withFrontend = false;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use in-memory caching for queries.
     * @param array $projectConfig Project configuration details.
     * @param bool $verboseLogging Whether to enable verbose logging.
     * @param bool $requireLogin Whether the generated application should require login.
     * @param bool $withFrontend Whether to generate with an integrated frontend.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $verboseLogging = false, $requireLogin = true, $withFrontend = false)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache, $withFrontend);

        $this->projectConfig = array_merge(array(
            'moduleName' => 'magicapp/generated-api',
            'goVersion' => '1.22',
            'appName' => 'GraphQL App',
            'description' => 'GraphQL API generated by MagicAppBuilder',
            'verboseLogging' => $verboseLogging,
            'requireLogin' => $requireLogin
        ), $projectConfig);

        $this->verboseLogging = $verboseLogging;
        $this->requireLogin = $requireLogin;
        $this->withFrontend = $withFrontend;
    }

    /**
     * Maps a database type to a Go type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Go type string.
     */
    private function mapDbTypeToGoType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'string';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return '*time.Time';
        }
        if (strpos($dbType, 'date') !== false) {
            return '*time.Time';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'float64';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'bool';
        }
        if (strpos($dbType, 'int') !== false) {
            // Differentiate between int sizes if possible, otherwise default to int
            if (strpos($dbType, 'bigint') !== false) {
                return 'int64';
            }
            if (strpos($dbType, 'smallint') !== false) {
                return 'int16';
            }
            if (strpos($dbType, 'tinyint') !== false) {
                return 'int8';
            }
            return 'int';
        }
        return 'string'; // Default fallback
    }

    /**
     * Maps a database type to a GraphQL type for the schema.
     *
     * @param string $dbType The database column type.
     * @param int|null $length The length of the column.
     * @return string The corresponding GraphQL type.
     */
    public function mapDbTypeToGqlType($dbType, $length = null)
    {
        $goType = $this->mapDbTypeToGoType($dbType, $length);
        switch ($goType) {
            case 'int':
            case 'int8':
            case 'int16':
            case 'int32':
            case 'int64':
                return 'Int';
            case 'float32':
            case 'float64':
                return 'Float';
            case 'bool':
                return 'Boolean';
            case '*time.Time':
                return 'String'; // Represent dates as ISO-8601 strings
            case 'string':
            default:
                return 'String';
        }
    }

    /**
     * Main function to generate all files for the Go project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();

        // 1. go.mod
        $files[] = ['name' => 'go.mod', 'content' => $this->generateGoMod()];

        // 2. Main application file
        $files[] = ['name' => 'main.go', 'content' => $this->generateMainGo()];

        // 3. Server setup
        $files[] = ['name' => 'server/server.go', 'content' => $this->generateServerGo()];

        // 4. Database configuration
        $files[] = ['name' => 'database/database.go', 'content' => $this->generateDatabaseGo()];

        // 5. GraphQL generated files (will be created by `go run github.com/99designs/gqlgen generate`)
        $files[] = ['name' => 'graph/generated/generated.go', 'content' => "// THIS FILE IS AUTOGENERATED BY GQLGEN.\n// DO NOT EDIT IT MANUALLY.\n\npackage generated\n"];
        $files[] = ['name' => 'graph/models_generated.go', 'content' => "// THIS FILE IS AUTOGENERATED BY GQLGEN.\n// DO NOT EDIT IT MANUALLY.\n\npackage graph\n"];

        // 6. GraphQL schema, resolvers, and models
        $allSchemaParts = array();
        $allQueryFields = array();
        $allMutationFields = array();
        $resolverImplementations = "";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $ucCamelName = ucfirst($this->camelCase($tableName));

            // Go Model (Entity)
            $files[] = ['name' => 'models/' . $this->camelCaseToSnakeCase($tableName) . '.go', 'content' => $this->generateModelStruct($tableName, $tableInfo)];

            // Collect schema parts
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];

            // Resolver implementations
            $resolverImplementations .= $this->generateResolverImplementationForTable($tableName, $tableInfo) . "\n";
        }

        // 7. Combined GraphQL schema
        $files[] = ['name' => 'graph/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        // 8. Main resolver file
        $files[] = ['name' => 'graph/resolver.go', 'content' => $this->generateMainResolverGo($resolverImplementations)];

        // 9. gqlgen.yml configuration file
        $files[] = ['name' => 'gqlgen.yml', 'content' => $this->generateGqlgenYml()];

        // 10. .env file for configuration
        $files[] = ['name' => '.env', 'content' => $this->generateEnvFile()];

        // 11. Manual
        $files[] = ['name' => 'manual.md', 'content' => $this->generateManual()];

        return $files;
    }

    /**
     * Generates the content for the go.mod file.
     *
     * @return string The content for go.mod.
     */
    public function generateGoMod()
    {
        $config = $this->projectConfig;
        return <<<GO
module {$config['moduleName']}

go {$config['goVersion']}

require (
	github.com/99designs/gqlgen v0.17.45
	github.com/gin-contrib/static v1.1.5
	github.com/gin-gonic/gin v1.10.0
	github.com/joho/godotenv v1.5.1
	gorm.io/driver/mysql v1.5.6
	gorm.io/driver/postgres v1.5.7
	gorm.io/driver/sqlite v1.5.5
	gorm.io/driver/sqlserver v1.5.3
	gorm.io/gorm v1.25.10
)

require (
	github.com/agnivade/levenshtein v1.1.1 // indirect
	github.com/bytedance/sonic v1.13.2 // indirect
	github.com/bytedance/sonic/loader v0.2.4 // indirect
	github.com/cloudwego/base64x v0.1.5 // indirect
	github.com/gabriel-vasile/mimetype v1.4.8 // indirect
	github.com/gin-contrib/sse v1.0.0 // indirect
	github.com/go-playground/locales v0.14.1 // indirect
	github.com/go-playground/universal-translator v0.18.1 // indirect
	github.com/go-playground/validator/v10 v10.26.0 // indirect
	github.com/go-sql-driver/mysql v1.7.0 // indirect
	github.com/goccy/go-json v0.10.5 // indirect
	github.com/golang-sql/civil v0.0.0-20220223132316-b832511892a9 // indirect
	github.com/golang-sql/sqlexp v0.1.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/gorilla/websocket v1.5.0 // indirect
	github.com/hashicorp/golang-lru/v2 v2.0.7 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20221227161230-091c0ba34f0a // indirect
	github.com/jackc/pgx/v5 v5.4.3 // indirect
	github.com/jinzhu/inflection v1.0.0 // indirect
	github.com/jinzhu/now v1.1.5 // indirect
	github.com/json-iterator/go v1.1.12 // indirect
	github.com/klauspost/cpuid/v2 v2.2.10 // indirect
	github.com/kr/text v0.2.0 // indirect
	github.com/leodido/go-urn v1.4.0 // indirect
	github.com/mattn/go-isatty v0.0.20 // indirect
	github.com/mattn/go-sqlite3 v1.14.17 // indirect
	github.com/microsoft/go-mssqldb v1.6.0 // indirect
	github.com/mitchellh/mapstructure v1.5.0 // indirect
	github.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect
	github.com/modern-go/reflect2 v1.0.2 // indirect
	github.com/pelletier/go-toml/v2 v2.2.3 // indirect
	github.com/sosodev/duration v1.2.0 // indirect
	github.com/twitchyliquid64/golang-asm v0.15.1 // indirect
	github.com/ugorji/go/codec v1.2.12 // indirect
	github.com/vektah/gqlparser/v2 v2.5.11 // indirect
	golang.org/x/arch v0.16.0 // indirect
	golang.org/x/crypto v0.37.0 // indirect
	golang.org/x/net v0.38.0 // indirect
	golang.org/x/sys v0.32.0 // indirect
	golang.org/x/text v0.24.0 // indirect
	google.golang.org/protobuf v1.36.6 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

GO;
    }

    /**
     * Generates the main.go file.
     *
     * @return string The content of main.go.
     */
    private function generateMainGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package main

import (
	"log"

	"{$moduleName}/database"
	"{$moduleName}/server"
	"github.com/joho/godotenv"
)

func main() {
	// Load .env file
	err := godotenv.Load()
	if err != nil {
		log.Println("No .env file found, using default environment variables")
	}

	// Initialize Database
	database.Init()

	// Initialize Server
	srv := server.NewServer()

	log.Println("Server is running on port 8080")
	if err := srv.Run(); err != nil {
		log.Fatalf("Failed to run server: %v", err)
	}
}
GO;
    }

    /**
     * Generates the server/server.go file for setting up the Gin router and GraphQL handler.
     *
     * @return string The content of server.go.
     */
    private function generateServerGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package server

import (
	"{$moduleName}/database"
	"{$moduleName}/graph"
	"{$moduleName}/graph/generated"
	"github.com/99designs/gqlgen/graphql/handler"
	"github.com/gin-contrib/static"
	"net/http"
	"os"
	"github.com/99designs/gqlgen/graphql/playground"
	"github.com/gin-gonic/gin"
)

// Server struct holds the router.
type Server struct {
	router *gin.Engine
}

// NewServer creates a new server with all routes configured.
func NewServer() *Server {
	router := gin.Default()

	s := &Server{
		router: router,
	}

	s.registerRoutes()

	return s
}

// Run starts the HTTP server.
func (s *Server) Run() error {
	port := os.Getenv("SERVER_PORT")
	if port == "" {
		port = "8080" // Default port
	}
	return s.router.Run(":" + port)
}

// graphqlHandler returns a Gin handler for the GraphQL endpoint.
func graphqlHandler() gin.HandlerFunc {
	// NewExecutableSchema and Config are in the generated.go file
	// Resolver is the root resolver struct to pass to the graph
	h := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: &graph.Resolver{
		DB: database.DB,
	}}))

	return func(c *gin.Context) {
		h.ServeHTTP(c.Writer, c.Request)
	}
}

// playgroundHandler returns a Gin handler for the GraphQL Playground UI.
func playgroundHandler() gin.HandlerFunc {
	h := playground.Handler("GraphQL", "/query")

	return func(c *gin.Context) {
		h.ServeHTTP(c.Writer, c.Request)
	}
}

func (s *Server) registerRoutes() {
	// GraphQL endpoints
	s.router.POST("/graphql", graphqlHandler())
	s.router.GET("/graphiql", playgroundHandler())

	// Serve frontend files if enabled
	if {$this->getWithFrontendAsString()} {
		s.router.Use(static.Serve("/", static.LocalFile("./public", true)))
		s.router.NoRoute(func(c *gin.Context) { c.File("./public/index.html") })
	}
}
GO;
    }

    /**
     * Generates the database/database.go file for GORM initialization.
     *
     * @return string The content of database.go.
     */
    private function generateDatabaseGo()
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package database

import (
	"fmt"
	"log"
	"os"
	"strings"

	"{$moduleName}/models"
	"gorm.io/driver/mysql"
	"gorm.io/driver/postgres"
	"gorm.io/driver/sqlite"
	"gorm.io/driver/sqlserver"
	"gorm.io/gorm"
	"gorm.io/gorm/schema"
)

var DB *gorm.DB

// AutoMigrate runs GORM's auto-migration for all known models.
func AutoMigrate() {
	err := DB.AutoMigrate(
		// Add all your models here
{$this->generateAutoMigrateModels()}
	)
	if err != nil {
		log.Fatalf("Failed to auto-migrate database: %v", err)
	}
	log.Println("Database migration completed successfully.")
}

// Init initializes the database connection.
func Init() {
	var err error
	dialect := strings.ToLower(os.Getenv("DB_DIALECT"))
	user := os.Getenv("DB_USER")
	pass := os.Getenv("DB_PASS")
	host := os.Getenv("DB_HOST")
	port := os.Getenv("DB_PORT")
	dbname := os.Getenv("DB_NAME")
    dbfile := os.Getenv("DB_FILE") // For SQLite, DB_FILE is the file path
	sslmode := os.Getenv("DB_SSLMODE") // For PostgreSQL

	var dsn string
	var dialector gorm.Dialector

	switch dialect {
	case "postgres", "postgresql", "pgsql":
		dsn = fmt.Sprintf("host=%s user=%s password=%s dbname=%s port=%s sslmode=%s", host, user, pass, dbname, port, sslmode)
		dialector = postgres.Open(dsn)
	case "sqlite":
		dsn = dbfile
		if dsn == "" {
			// Fallback to DB_NAME if DB_FILE is not set
			dsn = dbname
		}
		dialector = sqlite.Open(dsn)
	case "sqlserver", "mssql":
		dsn = fmt.Sprintf("sqlserver://%s:%s@%s:%s?database=%s", user, pass, host, port, dbname)
		dialector = sqlserver.Open(dsn)
	case "mysql", "mariadb":
		fallthrough
	default:
		dsn = fmt.Sprintf("%s:%s@tcp(%s:%s)/%s?charset=utf8mb4&parseTime=True&loc=Local", user, pass, host, port, dbname)
		dialector = mysql.Open(dsn)
	}

	DB, err = gorm.Open(dialector, &gorm.Config{
		NamingStrategy: schema.NamingStrategy{
			SingularTable: true, // use singular table name, e.g., "user" instead of "users"
		},
	})

	if err != nil {
		log.Fatalf("Failed to connect to database: %v", err)
	}

	log.Println("Database connection established")
}
GO;
    }

    /**
     * Generates the list of model structs for GORM's AutoMigrate function.
     * This list is injected into the database.go file.
     *
     * @return string A string containing the list of models, e.g., "&models.User{},\n&models.Product{},\n".
     */
    private function generateAutoMigrateModels()
    {
        $modelsList = "";
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $ucCamelName = ucfirst($this->camelCase($tableName));
            $modelsList .= "		&models.{$ucCamelName}{},\n";
        }
        return rtrim($modelsList);
    }

    /**
     * Generates the Go model struct for a given table.
     *
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the model file.
     */
    private function generateModelStruct($tableName, $tableInfo)
    {
        $ucCamelName = ucfirst($this->camelCase($tableName));
        $fields = "";
        $imports = array();

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $goType = $this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']);
            $fieldName = ucfirst($this->camelCase($colName));

            if (strpos($goType, 'time.Time') !== false) {
                $imports['time'] = true;
            }

            $gormTags = "column:" . $colName;
            if ($colInfo['isPrimaryKey']) {
                $gormTags .= ";primaryKey";
            }
            if ($colInfo['isAutoIncrement']) {
                $gormTags .= ";autoIncrement";
            }

            $jsonTag = $colName;

            $fields .= "	" . $fieldName . " " . $goType . " `gorm:\"" . $gormTags . "\" json:\"" . $jsonTag . "\"`\n";

            // Handle foreign key relationships
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refUcCamelName = ucfirst($this->camelCase($refTableName));
                $refFieldName = $refUcCamelName;

                $fkTag = "foreignKey:" . $fieldName;
                $fields .= "	" . $refFieldName . " *" . $refUcCamelName . " `gorm:\"" . $fkTag . "\" json:\"" . $this->camelCaseToSnakeCase($refTableName) . "\"`\n";
            }
        }

        $importStr = "";
        if (!empty($imports)) {
            $importStr = "import (\n";
            foreach (array_keys($imports) as $pkg) {
                $importStr .= "	\"" . $pkg . "\"\n";
            }
            $importStr .= ")\n\n";
        }

        return <<<GO
package models

$importStr
// $ucCamelName represents the $tableName table.
type $ucCamelName struct {
$fields}
GO;
    }

    /**
     * Generates the main resolver.go file.
     *
     * @param string $implementations The generated query and mutation implementations.
     * @return string The content of resolver.go.
     */
    private function generateMainResolverGo($implementations)
    {
        $moduleName = $this->projectConfig['moduleName'];
        return <<<GO
package graph

import (
	"context"
	"{$moduleName}/graph/generated"
	"{$moduleName}/graph/model"
	"{$moduleName}/models"
	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"time"
)

// This file will not be regenerated automatically.
//
// It serves as dependency injection for your app, add any dependencies you require here.

type Resolver struct {
	DB *gorm.DB
}

// Mutation returns generated.MutationResolver implementation.
func (r *Resolver) Mutation() generated.MutationResolver {
	return &mutationResolver{r}
}

// Query returns generated.QueryResolver implementation.
func (r *Resolver) Query() generated.QueryResolver {
	return &queryResolver{r}
}

type mutationResolver struct{ *Resolver }

type queryResolver struct{ *Resolver }

$implementations
GO;
    }

    /**
     * Generates the resolver method implementations for a specific table.
     *
     * @param string $tableName
     * @param array $tableInfo
     * @return string
     */
    private function generateResolverImplementationForTable($tableName, $tableInfo)
    {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);
        $ucPluralCamelName = ucfirst($pluralCamelName);

        $pkInfo = $this->getPrimaryKeyInfo($tableInfo);
        $pkGoType = $this->mapDbTypeToGoType($pkInfo['type'], $pkInfo['length']);

        // --- Query: Get one item ---
        $getOne = <<<GO
func (r *queryResolver) {$ucCamelName}(ctx context.Context, id {$pkGoType}) (*models.{$ucCamelName}, error) {
	var result models.{$ucCamelName}
	if err := r.DB.Preload(clause.Associations).First(&result, "{$pkInfo['name']} = ?", id).Error; err != nil {
		return nil, err
	}
	return &result, nil
}

GO;

        // --- Query: Get list ---
        $getList = <<<GO
func (r *queryResolver) {$ucPluralCamelName}(ctx context.Context, limit *int, offset *int, orderBy []*model.SortInput, filter []*model.FilterInput) (*model.{$ucCamelName}Page, error) {
	var items []*models.{$ucCamelName}
	var total int64

	db := r.DB.Model(&models.{$ucCamelName}{})

	// Apply filters
	if filter != nil {
		for _, f := range filter {
			// Prevent SQL injection by checking against a whitelist of filterable fields if necessary
			// For this generator, we assume field names are safe as they come from the schema.
			operator := " = ?"
			value := f.Value
			if f.Operator != nil {
				switch *f.Operator {
				case model.FilterOperatorNotEquals: operator = " != ?"
				case model.FilterOperatorContains: operator = " LIKE ?"; value = "%" + f.Value + "%"
				case model.FilterOperatorGreaterThan: operator = " > ?"
				case model.FilterOperatorLessThan: operator = " < ?"
				}
			}
			db = db.Where(f.Field+operator, value)
		}
	}

	// Get total count
	if err := db.Count(&total).Error; err != nil {
		return nil, err
	}

	// Apply sorting
	if orderBy != nil {
		for _, o := range orderBy {
			direction := "ASC"
			if o.Direction != nil && *o.Direction == model.SortDirectionDesc {
				direction = "DESC"
			}
			db = db.Order(o.Field + " " + direction)
		}
	}

	// Apply pagination
	if limit != nil {
		db = db.Limit(*limit)
	}
	if offset != nil {
		db = db.Offset(*offset)
	}

	// Fetch items
	if err := db.Preload(clause.Associations).Find(&items).Error; err != nil {
		return nil, err
	}

	// Construct page result
	page := &model.{$ucCamelName}Page{
		Items: items,
		Total: int(total),
	}
	if limit != nil {
		page.Limit = *limit
	}
	if offset != nil && limit != nil && *limit > 0 {
		page.Page = (*offset / *limit) + 1
	}

	return page, nil
}

GO;

        // --- Mutation: Create ---
        $create = <<<GO
func (r *mutationResolver) Create{$ucCamelName}(ctx context.Context, input model.{$ucCamelName}Input) (*models.{$ucCamelName}, error) {
	item := &models.{$ucCamelName}{}

{$this->generateInputToModelMapping($tableInfo, "item", "input")}

	if err := r.DB.Create(item).Error; err != nil {
		return nil, err
	}
	return item, nil
}

GO;

        // --- Mutation: Update ---
        $update = <<<GO
func (r *mutationResolver) Update{$ucCamelName}(ctx context.Context, id {$pkGoType}, input model.{$ucCamelName}Input) (*models.{$ucCamelName}, error) {
	item := &models.{$ucCamelName}{}

	if err := r.DB.First(item, "{$pkInfo['name']} = ?", id).Error; err != nil {
		return nil, err // Not found
	}

{$this->generateInputToModelMapping($tableInfo, "item", "input")}

	if err := r.DB.Save(item).Error; err != nil {
		return nil, err
	}
	return item, nil
}

GO;

        // --- Mutation: Delete ---
        $delete = <<<GO
func (r *mutationResolver) Delete{$ucCamelName}(ctx context.Context, id {$pkGoType}) (bool, error) {
	if err := r.DB.Delete(&models.{$ucCamelName}{}, "{$pkInfo['name']} = ?", id).Error; err != nil {
		return false, err
	}
	return true, nil
}

GO;

        return $getOne . $getList . $create . $update . $delete;
    }

    /**
     * Generates the mapping code from a GraphQL input struct to a GORM model struct.
     *
     * @param array $tableInfo
     * @param string $modelVar
     * @param string $inputVar
     * @return string
     */
    private function generateInputToModelMapping($tableInfo, $modelVar, $inputVar)
    {
        $mapping = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isAutoIncrement']) {
                continue;
            }

            $fieldName = ucfirst($this->camelCase($colName));
            $goType = $this->mapDbTypeToGoType($colInfo['type'], $colInfo['length']);

            // For pointer types in input, we need to dereference them.
            if (substr($goType, 0, 1) === '*') {
                $mapping .= "	if {$inputVar}.{$fieldName} != nil {\n";
                $mapping .= "		{$modelVar}.{$fieldName} = {$inputVar}.{$fieldName}\n";
                $mapping .= "	}\n";
            } else {
                $mapping .= "	{$modelVar}.{$fieldName} = {$inputVar}.{$fieldName}\n";
            }
        }
        return $mapping;
    }

    /**
     * Generates the gqlgen.yml configuration file.
     *
     * @return string
     */
    private function generateGqlgenYml()
    {
        $moduleName = $this->projectConfig['moduleName'];
        $modelMappings = "";
        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $ucCamelName = ucfirst($this->camelCase($tableName));
            $modelMappings .= "    {$ucCamelName}: {$moduleName}/models.{$ucCamelName}\n";
        }

        return <<<YAML
# Where are all the schema files located?
schema:
  - graph/*.graphqls

# Where should the generated server code go?
exec:
  filename: graph/generated/generated.go
  package: generated

# Uncomment to enable federation
# federation:
#   filename: graph/generated/federation.go
#   package: generated

# Where should any generated models go?
model:
  filename: graph/model/models_gen.go
  package: model

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: graph
  package: graph

# Optional: turn on use of pointers for fields that are nullable
omit_slice_element_pointers: true

# Optional: set to speed up generation time by not performing a final validation pass.
# skip_validation: true

# gqlgen will search for any type names in the schema in these go packages
# if they match it will use them, otherwise it will generate them.
autobind:
  - "{$moduleName}/graph/model"

# This section tells gqlgen about the models. By default gqlgen will generate
# models based on the schema but we want to use our own GORM models.
models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Int:
    model:
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
{$modelMappings}
YAML;
    }

    /**
     * Generates the .env file with database credentials.
     *
     * @return string
     */
    private function generateEnvFile()
    {
        return <<<ENV
# Database Configuration
DB_HOST=127.0.0.1
DB_PORT=3306
DB_USER=your_username
DB_PASS=your_password
DB_NAME=your_database_name

# For SQLite, DB_NAME is used as the file path, e.g., gorm.db
DB_FILE=your_database_file.db

# For PostgreSQL, you can add sslmode (e.g., disable, require, verify-full)
# DB_SSLMODE=disable

# Supported dialects: mysql, postgres, sqlite, sqlserver
DB_DIALECT=mysql

# Server Configuration
SERVER_PORT=8080
ENV;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     *
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo)
    {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);
        $ucPluralCamelName = ucfirst($pluralCamelName);

        // Type fields
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $gqlType = $this->mapDbTypeToGqlType($colInfo['type'], $colInfo['length']);
            $fieldName = $colName; // Use original snake_case name
            $fields .= "    $fieldName: $gqlType\n";

            if ($colInfo['isForeignKey']) {
                $refUcCamelName = ucfirst($this->camelCase($colInfo['references']));
                $fields .= "    {$colInfo['references']}: $refUcCamelName\n";
            }
        }

        // Input fields
        $inputFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isAutoIncrement']) {
                continue; // Don't include auto-incrementing PK in create input
            }
            $gqlType = $this->mapDbTypeToGqlType($colInfo['type'], $colInfo['length']);
            $fieldName = $colName; // Use original snake_case name
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $pkInfo = $this->getPrimaryKeyInfo($tableInfo);
        $pkGqlType = $this->mapDbTypeToGqlType($pkInfo['type'], $pkInfo['length']);

        $types = <<<GQL
type $ucCamelName {
$fields}

input {$ucCamelName}Input {
$inputFields}

type {$ucCamelName}Page {
    items: [$ucCamelName!]
    total: Int!
    limit: Int
    page: Int
}
GQL;

        $queries = "    {$camelName}({$pkInfo['name']}: {$pkGqlType}!): $ucCamelName\n";
        $queries .= "    {$pluralCamelName}(limit: Int, offset: Int, orderBy: [SortInput], filter: [FilterInput]): {$ucCamelName}Page\n";

        $mutations = "    create{$ucCamelName}(input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    update{$ucCamelName}({$pkInfo['name']}: {$pkGqlType}!, input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    delete{$ucCamelName}({$pkInfo['name']}: {$pkGqlType}!): Boolean!\n";

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Combines all schema parts into a single GraphQL schema string.
     *
     * @param array $allSchemaParts Array of type definitions.
     * @param array $allQueryFields Array of query definitions.
     * @param array $allMutationFields Array of mutation definitions.
     * @return string The complete GraphQL schema.
     */
    private function generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)
    {
        $typesString = implode("\n", $allSchemaParts);
        $queriesString = implode("", $allQueryFields);
        $mutationsString = implode("", $allMutationFields);

        return <<<GQL
scalar Time

enum SortDirection {
    ASC
    DESC
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    operator: FilterOperator
    value: String!
}

$typesString

type Query {
$queriesString}

type Mutation {
$mutationsString}
GQL;
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# Go GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides setup instructions and examples for your generated Go GraphQL API.\r\n\r\n";

        $manualContent .= "## Prerequisites\r\n\r\n";
        $manualContent .= "- Go (version {$this->projectConfig['goVersion']} or newer)\r\n";
        $manualContent .= "- A running database (MySQL, PostgreSQL, SQLite, or SQL Server).\r\n\r\n";

        $manualContent .= "## Setup and Running the Application\r\n\r\n";
        $manualContent .= "1.  **Configure Environment:**\r\n";
        $manualContent .= "    Create a `.env` file in the root of the project (or rename the existing one) and fill in your database credentials:\r\n";
        $manualContent .= "    ```env\r\n";
        $manualContent .= "    DB_HOST=127.0.0.1\r\n";
        $manualContent .= "    DB_PORT=3306\r\n";
        $manualContent .= "    DB_USER=your_username\r\n";
        $manualContent .= "    DB_PASS=your_password\r\n";
        $manualContent .= "    DB_NAME=your_database_name\r\n";
        $manualContent .= "    DB_FILE=your_database_file.db\r\n";
        $manualContent .= "    DB_DIALECT=mysql # Can be mysql, postgres, sqlite, or sqlserver\r\n";
        $manualContent .= "    ```\r\n\r\n";

        $manualContent .= "2.  **Install Dependencies:**\r\n";
        $manualContent .= "    Open your terminal in the project root and run:\r\n";
        $manualContent .= "    ```sh\r\n";
        $manualContent .= "    go mod tidy\r\n";
        $manualContent .= "    ```\r\n\r\n";

        $manualContent .= "3.  **Generate GraphQL Code:**\r\n";
        $manualContent .= "    The project uses `gqlgen` to generate Go code from your GraphQL schema. Run the following command:\r\n";
        $manualContent .= "    ```sh\r\n";
        $manualContent .= "    go run github.com/99designs/gqlgen generate\r\n";
        $manualContent .= "    ```\r\n\r\n";

        $manualContent .= "4.  **Run the Server:**\r\n";
        $manualContent .= "    ```sh\r\n";
        $manualContent .= "    go run main.go\r\n";
        $manualContent .= "    ```\r\n\r\n";

        $manualContent .= "5.  **Access the API:**\r\n";
        $manualContent .= "    Open your browser and navigate to `http://localhost:8080/graphiql`. You will see the GraphQL Playground, where you can run queries and mutations.\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $ucCamelName = ucfirst($camelName);

            $manualContent .= "## " . $ucCamelName . "\r\n\r\n";

            // --- Get Fields for examples ---
            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true); // No relations for mutation return

            $pkInfo = $this->getPrimaryKeyInfo($tableInfo);

            // --- Query Examples ---
            $manualContent .= "### Queries\r\n\r\n";

            // Get Single Item
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $ucCamelName . " {\r\n";
            $manualContent .= "  " . $camelName . "({$pkInfo['name']}: \"your-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Get List
            $manualContent .= "#### Get a list of " . $pluralCamelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . ucfirst($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(\r\n    limit: 10, \r\n    offset: 0, \r\n    orderBy: [{field: \"{$pkInfo['name']}\", direction: DESC}]\r\n  ) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString); // Indent fields
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "    limit\r\n";
            $manualContent .= "    page\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // --- Mutation Examples ---
            $manualContent .= "### Mutations\r\n\r\n";

            list(, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            // Create
            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $ucCamelName . " {\r\n";
            $manualContent .= "  create" . $ucCamelName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Update
            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $ucCamelName . " {\r\n";
            $manualContent .= "  update" . $ucCamelName . "({$pkInfo['name']}: \"your-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Delete
            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "Returns `true` on success.\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $ucCamelName . " {\r\n";
            $manualContent .= "  delete" . $ucCamelName . "({$pkInfo['name']}: \"your-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        return $manualContent;
    }

    /**
     * Get project configuration.
     * @return array
     */
    public function getProjectConfig()
    {
        return $this->projectConfig;
    }

    /**
     * Get primary key information for a table.
     *
     * @param array $tableInfo
     * @return array
     */
    private function getPrimaryKeyInfo($tableInfo)
    {
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey']) {
                return [
                    'name' => $colName,
                    'type' => $colInfo['type'],
                    'length' => $colInfo['length']
                ];
            }
        }
        // Fallback, though a PK should always exist
        return [
            'name' => 'id',
            'type' => 'varchar',
            'length' => 255
        ];
    }

    /**
     * Get withFrontend as a string "true" or "false".
     *
     * @return string
     */
    private function getWithFrontendAsString()
    {
        return $this->withFrontend ? 'true' : 'false';
    }
}
