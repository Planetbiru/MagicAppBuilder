<?php

namespace AppBuilder;

use MagicObject\Util\PicoStringUtil;

/**
 * The `GraphQLGeneratorKotlin` class is a powerful tool designed to automatically generate a complete Spring Boot GraphQL API in Kotlin from a JSON file that defines database entities.
 * It inspects the schema to understand tables, columns, primary keys, and foreign key relationships.
 * Based on this analysis, it produces Kotlin code for entities, repositories, DTOs, and GraphQL controllers, along with GraphQL schema files, and a comprehensive API manual in Markdown format.
 * This class streamlines the process of scaffolding a GraphQL API, reducing manual effort and ensuring consistency between the database schema and the API.
 * 
 * @package AppBuilder
 */
class GraphQLGeneratorKotlin extends GraphQLGeneratorBase
{
    /**
     * @var array<string, string> Project configuration for build.gradle.kts and package structure.
     */
    private $projectConfig = array();

    /**
     * @var bool Whether to enable verbose logging in the generated application.
     */
    private $verboseLogging = false;

    /**
     * @var bool Whether the generated application should require login.
     */
    private $requireLogin = true;

    /**
     * Constructor.
     *
     * @param array $schema Decoded JSON schema.
     * @param array|null $reservedColumns Reserved column definitions.
     * @param array $backendHandledColumns Columns handled by the backend.
     * @param bool $useCache Whether to use in-memory caching for queries.
     * @param array $projectConfig Project configuration details.
     * @param bool $verboseLogging Whether to enable verbose logging.
     * @param bool $requireLogin Whether to require login.
     */
    public function __construct($schema, $reservedColumns = null, $backendHandledColumns = array(), $useCache = false, $projectConfig = array(), $verboseLogging = false, $requireLogin = true)
    {
        parent::__construct($schema, $reservedColumns, $backendHandledColumns, $useCache);

        $this->projectConfig = array_merge(array(
            'groupId' => 'io.magicapp.generated',
            'artifactId' => 'graphql-app',
            'version' => '0.0.1-SNAPSHOT',
            'name' => 'GraphQL App',
            'description' => 'GraphQL API generated by MagicAppBuilder',
            'javaVersion' => '21',
            'kotlinVersion' => '1.9.23',
            'packageName' => 'io.magicapp.generated.graphqlapp',
            'verboseLogging' => $verboseLogging,
            'requireLogin' => $requireLogin
        ), $projectConfig);

        $this->verboseLogging = $verboseLogging;
        $this->requireLogin = $requireLogin;
    }

    /**
     * Maps a database type to a Kotlin type.
     *
     * @param string $dbType The database column type (e.g., VARCHAR, INT, TIMESTAMP).
     * @param int|null $length The length of the column.
     * @return string The corresponding Kotlin type string.
     */
    private function mapDbTypeToKotlinType($dbType, $length = null)
    {
        $dbType = strtolower($dbType);
        if (strpos($dbType, 'varchar') !== false || strpos($dbType, 'text') !== false) {
            return 'String?';
        }
        if (strpos($dbType, 'timestamp') !== false || strpos($dbType, 'datetime') !== false) {
            return 'java.time.LocalDateTime?';
        }
        if (strpos($dbType, 'date') !== false) {
            return 'java.time.LocalDate?';
        }
        if (strpos($dbType, 'decimal') !== false || strpos($dbType, 'float') !== false || strpos($dbType, 'double') !== false) {
            return 'Double?';
        }
        if ((strpos($dbType, 'tinyint') !== false && isset($length) && $length == '1') || strpos($dbType, 'bool') !== false || strpos($dbType, 'bit') !== false) {
            return 'Boolean?';
        }
        if (strpos($dbType, 'int') !== false) {
            return 'Int?';
        }
        return 'String?'; // Default fallback
    }

    /**
     * Maps a Kotlin type to a GraphQL type.
     *
     * @param string $kotlinType The Kotlin type.
     * @return string The corresponding GraphQL type.
     */
    private function mapKotlinTypeToGqlType($kotlinType)
    {
        $baseType = str_replace('?', '', $kotlinType);
        switch ($baseType) {
            case 'Int':
                return 'Int';
            case 'Double':
            case 'Float':
                return 'Float';
            case 'Boolean':
                return 'Boolean';
            case 'String':
            case 'java.time.LocalDate':
            case 'java.time.LocalDateTime':
                return 'String'; // Or custom scalars
            default:
                return 'String';
        }
    }

    /**
     * Main function to generate all files for the Spring Boot project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();
        $packagePath = 'src/main/kotlin/' . str_replace('.', '/', $this->projectConfig['packageName']);

        // 1. Gradle build files
        $files[] = ['name' => 'build.gradle.kts', 'content' => $this->generateBuildGradleKts()];
        $files[] = ['name' => 'settings.gradle.kts', 'content' => $this->generateSettingsGradleKts()];

        // 2. Main Application Class
        $files[] = ['name' => $packagePath . '/' . $this->pascalCase($this->projectConfig['artifactId']) . 'Application.kt', 'content' => $this->generateMainAppClass()];

        // 3. GraphQL Schema, Entities, Repositories, DTOs, Controllers
        $allSchemaParts = array();
        $allQueryFields = array();
        $allMutationFields = array();

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            // Generate individual Kotlin files
            $files[] = ['name' => $packagePath . '/model/entity/' . ucfirst($this->camelCase($tableName)) . '.kt', 'content' => $this->generateEntityClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/repository/' . ucfirst($this->camelCase($tableName)) . 'Repository.kt', 'content' => $this->generateRepositoryInterface($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/dto/' . ucfirst($this->camelCase($tableName)) . 'Input.kt', 'content' => $this->generateDtoClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/controller/' . ucfirst($this->camelCase($tableName)) . 'Controller.kt', 'content' => $this->generateControllerClass($tableName, $tableInfo)];

            // Collect schema parts to be merged later
            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];
        }

        // 4. Utility classes
        $files[] = ['name' => $packagePath . '/util/SpecificationBuilder.kt', 'content' => $this->generateSpecificationBuilder()];
        $files[] = ['name' => $packagePath . '/util/FilterCriteria.kt', 'content' => $this->generateFilterCriteria()];
        $files[] = ['name' => $packagePath . '/util/SearchOperation.kt', 'content' => $this->generateSearchOperation()];
        $files[] = ['name' => $packagePath . '/util/GenericSpecification.kt', 'content' => $this->generateGenericSpecification()];

        // 5. DTOs for GraphQL inputs
        $files[] = ['name' => $packagePath . '/model/dto/FilterInput.kt', 'content' => $this->generateFilterInputDto()];
        $files[] = ['name' => $packagePath . '/model/dto/SortInput.kt', 'content' => $this->generateSortInputDto()];

        // 6. Combined GraphQL schema file
        $files[] = ['name' => 'src/main/resources/graphql/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        // 7. Security and Auth files
        $files[] = ['name' => $packagePath . '/config/SecurityConfig.kt', 'content' => $this->generateSecurityConfig()];
        $files[] = ['name' => $packagePath . '/config/CorsConfig.kt', 'content' => $this->generateCorsConfig()];
        $files[] = ['name' => $packagePath . '/config/Sha1PasswordEncoder.kt', 'content' => $this->generateSha1PasswordEncoder()];
        $files[] = ['name' => $packagePath . '/service/JpaUserDetailsService.kt', 'content' => $this->generateUserDetailsService()];
        $files[] = ['name' => $packagePath . '/model/entity/Admin.kt', 'content' => $this->generateAdminEntity()];
        $files[] = ['name' => $packagePath . '/model/repository/AdminRepository.kt', 'content' => $this->generateAdminRepository()];

        // 8. Auth and App Controllers
        $files[] = ['name' => $packagePath . '/controller/dto/LoginRequest.kt', 'content' => $this->generateLoginRequestDto()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginResponse.kt', 'content' => $this->generateLoginResponseDto()];
        $files[] = ['name' => $packagePath . '/controller/AuthController.kt', 'content' => $this->generateAuthController()];

        return $files;
    }

    /**
     * Generates the application.properties file.
     * @return string The content of application.properties.
     */
    public function generateApplicationProperties()
    {
        $requireLoginValue = $this->requireLogin ? 'true' : 'false';
        return <<<PROPERTIES
spring.application.name={$this->projectConfig['name']}

# Database Configuration (Please update with your details)
app.security.require-login=$requireLoginValue

# CORS Configuration (Cross-Origin Resource Sharing)
app.security.cors.enabled=true
app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:8080

spring.datasource.url={DB_URL}
spring.datasource.username={DB_USER}
spring.datasource.password={DB_PASS}
spring.datasource.driver-class-name={DB_DRIVER_CLASS}

# JPA/Hibernate Configuration
spring.jpa.show-sql=true
spring.jpa.properties.hibernate.dialect={DB_DIALECT}

# Use database column names directly without converting to camelCase
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# GraphQL Configuration
spring.graphql.graphiql.enabled=true
spring.graphql.schema.locations=classpath:graphql/
spring.graphql.schema.file-extensions=.graphqls

PROPERTIES;
    }

    /**
     * Generates the build.gradle.kts file.
     * @return string The content of the build.gradle.kts file.
     */
    private function generateBuildGradleKts()
    {
        $config = $this->projectConfig;
        return <<<GRADLE
import org.jetbrains.kotlin.gradle.tasks.KotlinCompile

plugins {
	id("org.springframework.boot") version "3.2.5"
	id("io.spring.dependency-management") version "1.1.4"
	kotlin("jvm") version "{$config['kotlinVersion']}"
	kotlin("plugin.spring") version "{$config['kotlinVersion']}"
	kotlin("plugin.jpa") version "{$config['kotlinVersion']}"
}

group = "{$config['groupId']}"
version = "{$config['version']}"

java {
	sourceCompatibility = JavaVersion.VERSION_{$config['javaVersion']}
}

repositories {
	mavenCentral()
}

dependencies {
	implementation("org.springframework.boot:spring-boot-starter-data-jpa")
	implementation("org.springframework.boot:spring-boot-starter-graphql")
	implementation("org.springframework.boot:spring-boot-starter-security")
	implementation("org.springframework.boot.boot-starter-web")
	implementation("com.fasterxml.jackson.module:jackson-module-kotlin")
	implementation("org.jetbrains.kotlin:kotlin-reflect")

	// Database Drivers
	runtimeOnly("com.mysql:mysql-connector-j")
    runtimeOnly("org.mariadb.jdbc:mariadb-java-client")
    runtimeOnly("org.postgresql:postgresql")
    runtimeOnly("com.microsoft.sqlserver:mssql-jdbc")
    runtimeOnly("org.xerial:sqlite-jdbc")

	testImplementation("org.springframework.boot:spring-boot-starter-test")
	testImplementation("org.springframework:spring-webflux")
	testImplementation("org.springframework.graphql:spring-graphql-test")
	testImplementation("org.springframework.security:spring-security-test")
}

tasks.withType<KotlinCompile> {
	kotlinOptions {
		freeCompilerArgs += "-Xjsr305=strict"
		jvmTarget = "{$config['javaVersion']}"
	}
}

tasks.withType<Test> {
	useJUnitPlatform()
}

GRADLE;
    }

    /**
     * Main function to generate all files for the Spring Boot project.
     *
     * @return array An array of file definitions, each with 'name' and 'content'.
     */
    public function generate()
    {
        $files = array();
        $packagePath = 'src/main/kotlin/' . str_replace('.', '/', $this->projectConfig['packageName']);

        // 1. Gradle build files
        $files[] = ['name' => 'build.gradle.kts', 'content' => $this->generateBuildGradleKts()];
        $files[] = ['name' => 'settings.gradle.kts', 'content' => 'rootProject.name = "' . $this->projectConfig['artifactId'] . '"'];
        //$files[] = ['name' => 'mvnw.cmd', 'content' => $this->generateMvnwCmd()];

        // 2. Main Application Class
        $files[] = ['name' => $packagePath . '/' . $this->pascalCase($this->projectConfig['artifactId']) . 'Application.kt', 'content' => $this->generateMainAppClass()];

        // 3. GraphQL Schema, Entities, Repositories, DTOs, Controllers
        $allSchemaParts = array();
        $allQueryFields = array();
        $allMutationFields = array();

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $pascalName = $this->pascalCase($tableName);
            $files[] = ['name' => $packagePath . '/model/entity/' . $pascalName . '.kt', 'content' => $this->generateEntityClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/repository/' . $pascalName . 'Repository.kt', 'content' => $this->generateRepositoryInterface($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/model/dto/' . $pascalName . 'Input.kt', 'content' => $this->generateDtoClass($tableName, $tableInfo)];
            $files[] = ['name' => $packagePath . '/controller/' . $pascalName . 'Controller.kt', 'content' => $this->generateControllerClass($tableName, $tableInfo)];

            $schemaParts = $this->getSchemaPartsForTable($tableName, $tableInfo);
            $allSchemaParts[] = $schemaParts['types'];
            $allQueryFields[] = $schemaParts['queries'];
            $allMutationFields[] = $schemaParts['mutations'];
        }
        
        // 4. Utility and DTO classes (converted to Kotlin)
        // Note: The original Java generator has many utility classes. Each needs a Kotlin equivalent.
        // For brevity, I'm showing the conversion pattern with a few key files.
        $files[] = ['name' => $packagePath . '/model/dto/FilterInput.kt', 'content' => $this->generateFilterInputDtoKt()];
        $files[] = ['name' => $packagePath . '/model/dto/SortInput.kt', 'content' => $this->generateSortInputDtoKt()];
        $files[] = ['name' => $packagePath . '/util/SpecificationBuilder.kt', 'content' => $this->generateSpecificationBuilderKt()];
        $files[] = ['name' => $packagePath . '/util/FilterCriteria.kt', 'content' => $this->generateFilterCriteriaKt()];
        $files[] = ['name' => $packagePath . '/util/SearchOperation.kt', 'content' => $this->generateSearchOperationKt()];
        $files[] = ['name' => $packagePath . '/util/GenericSpecification.kt', 'content' => $this->generateGenericSpecificationKt()];
        $files[] = ['name' => $packagePath . '/util/QueryUtil.kt', 'content' => $this->generateQueryUtilKt()];
        $files[] = ['name' => $packagePath . '/util/AuditTrailUtil.kt', 'content' => $this->generateAuditTrailUtilKt()];
        $files[] = ['name' => $packagePath . '/util/ValueUtil.kt', 'content' => $this->generateValueUtilKt()];
        $files[] = ['name' => $packagePath . '/util/ScalarValueUtil.kt', 'content' => $this->generateScalarValueUtilKt()];

        // 5. Combined GraphQL Schema
        $files[] = ['name' => 'src/main/resources/graphql/schema.graphqls', 'content' => $this->generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)];

        // 6. Security and Auth files (converted to Kotlin)
        $files[] = ['name' => $packagePath . '/config/SecurityConfig.kt', 'content' => $this->generateSecurityConfigKt()];
        $files[] = ['name' => $packagePath . '/config/CorsConfig.kt', 'content' => $this->generateCorsConfigKt()];
        $files[] = ['name' => $packagePath . '/config/Sha1PasswordEncoder.kt', 'content' => $this->generateSha1PasswordEncoderKt()];
        $files[] = ['name' => $packagePath . '/config/ObjectScalar.kt', 'content' => $this->generateObjectScalarKt()];
        $files[] = ['name' => $packagePath . '/config/GraphQlConfig.kt', 'content' => $this->generateGraphQlConfigKt()];
        $files[] = ['name' => $packagePath . '/model/entity/core/Admin.kt', 'content' => $this->generateAdminEntityKt()];
        $files[] = ['name' => $packagePath . '/model/repository/core/AdminRepository.kt', 'content' => $this->generateAdminRepositoryKt()];
        $files[] = ['name' => $packagePath . '/service/JpaUserDetailsService.kt', 'content' => $this->generateUserDetailsServiceKt()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginRequest.kt', 'content' => $this->generateLoginRequestDtoKt()];
        $files[] = ['name' => $packagePath . '/controller/dto/LoginResponse.kt', 'content' => $this->generateLoginResponseDtoKt()];
        $files[] = ['name' => $packagePath . '/controller/core/AuthController.kt', 'content' => $this->generateAuthControllerKt()];

        return $files;
    }

    private function generateMvnwCmd()
    {
        return <<<CMD
<# : batch portion
@REM ----------------------------------------------------------------------------
@REM Licensed to the Apache Software Foundation (ASF) under one
@REM or more contributor license agreements.  See the NOTICE file
@REM distributed with this work for additional information
@REM regarding copyright ownership.  The ASF licenses this file
@REM to you under the Apache License, Version 2.0 (the
@REM "License"); you may not use this file except in compliance
@REM with the License.  You may obtain a copy of the License at
@REM
@REM    http://www.apache.org/licenses/LICENSE-2.0
@REM
@REM Unless required by applicable law or agreed to in writing,
@REM software distributed under the License is distributed on an
@REM "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
@REM KIND, either express or implied.  See the License for the
@REM specific language governing permissions and limitations
@REM under the License.
@REM ----------------------------------------------------------------------------

@REM ----------------------------------------------------------------------------
@REM Apache Maven Wrapper startup batch script, version 3.3.2
@REM
@REM Optional ENV vars
@REM   MVNW_REPOURL - repo url base for downloading maven distribution
@REM   MVNW_USERNAME/MVNW_PASSWORD - user and password for downloading maven
@REM   MVNW_VERBOSE - true: enable verbose log; others: silence the output
@REM ----------------------------------------------------------------------------

@IF "%__MVNW_ARG0_NAME__%"=="" (SET __MVNW_ARG0_NAME__=%~nx0)
@SET __MVNW_CMD__=
@SET __MVNW_ERROR__=
@SET __MVNW_PSMODULEP_SAVE=%PSModulePath%
@SET PSModulePath=
@FOR /F "usebackq tokens=1* delims==" %%A IN (`powershell -noprofile "& {\$scriptDir='%~dp0'; \$script='%__MVNW_ARG0_NAME__%'; icm -ScriptBlock ([Scriptblock]::Create((Get-Content -Raw '%~f0'))) -NoNewScope}"`) DO @(
  IF "%%A"=="MVN_CMD" (set __MVNW_CMD__=%%B) ELSE IF "%%B"=="" (echo %%A) ELSE (echo %%A=%%B)
)
@SET PSModulePath=%__MVNW_PSMODULEP_SAVE%
@SET __MVNW_PSMODULEP_SAVE=
@SET __MVNW_ARG0_NAME__=
@SET MVNW_USERNAME=
@SET MVNW_PASSWORD=
@IF NOT "%__MVNW_CMD__%"=="" (%__MVNW_CMD__% %*)
@echo Cannot start maven from wrapper >&2 && exit /b 1
@GOTO :EOF
: end batch / begin powershell #>

\$ErrorActionPreference = "Stop"
if (\$env:MVNW_VERBOSE -eq "true") {
  \$VerbosePreference = "Continue"
}

# calculate distributionUrl, requires .mvn/wrapper/maven-wrapper.properties
\$distributionUrl = (Get-Content -Raw "\$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionUrl
if (!\$distributionUrl) {
  Write-Error "cannot read distributionUrl property in \$scriptDir/.mvn/wrapper/maven-wrapper.properties"
}

switch -wildcard -casesensitive ( \$(\$distributionUrl -replace '^.*/','') ) {
  "maven-mvnd-*" {
    \$USE_MVND = \$true
    \$distributionUrl = \$distributionUrl -replace '-bin\.[^.]*\$',"-windows-amd64.zip"
    \$MVN_CMD = "mvnd.cmd"
    break
  }
  default {
    \$USE_MVND = \$false
    \$MVN_CMD = \$script -replace '^mvnw','mvn'
    break
  }
}

# apply MVNW_REPOURL and calculate MAVEN_HOME
# maven home pattern: ~/.m2/wrapper/dists/{apache-maven-<version>,maven-mvnd-<version>-<platform>}/<hash>
if (\$env:MVNW_REPOURL) {
  \$MVNW_REPO_PATTERN = if (\$USE_MVND) { "/org/apache/maven/" } else { "/maven/mvnd/" }
  \$distributionUrl = "\$env:MVNW_REPOURL\$MVNW_REPO_PATTERN\$(\$distributionUrl -replace '^.*'+\$MVNW_REPO_PATTERN,'')"
}
\$distributionUrlName = \$distributionUrl -replace '^.*/',''
\$distributionUrlNameMain = \$distributionUrlName -replace '\.[^.]*\$','' -replace '-bin\$',''
\$MAVEN_HOME_PARENT = "\$HOME/.m2/wrapper/dists/\$distributionUrlNameMain"
if (\$env:MAVEN_USER_HOME) {
  \$MAVEN_HOME_PARENT = "\$env:MAVEN_USER_HOME/wrapper/dists/\$distributionUrlNameMain"
}
\$MAVEN_HOME_NAME = ([System.Security.Cryptography.MD5]::Create().ComputeHash([byte[]][char[]]\$distributionUrl) | ForEach-Object {\$_.ToString("x2")}) -join ''
\$MAVEN_HOME = "\$MAVEN_HOME_PARENT/\$MAVEN_HOME_NAME"

if (Test-Path -Path "\$MAVEN_HOME" -PathType Container) {
  Write-Verbose "found existing MAVEN_HOME at \$MAVEN_HOME"
  Write-Output "MVN_CMD=\$MAVEN_HOME/bin/\$MVN_CMD"
  exit \$?
}

if (! \$distributionUrlNameMain -or (\$distributionUrlName -eq \$distributionUrlNameMain)) {
  Write-Error "distributionUrl is not valid, must end with *-bin.zip, but found \$distributionUrl"
}

# prepare tmp dir
\$TMP_DOWNLOAD_DIR_HOLDER = New-TemporaryFile
\$TMP_DOWNLOAD_DIR = New-Item -Itemtype Directory -Path "\$TMP_DOWNLOAD_DIR_HOLDER.dir"
\$TMP_DOWNLOAD_DIR_HOLDER.Delete() | Out-Null
trap {
  if (\$TMP_DOWNLOAD_DIR.Exists) {
    try { Remove-Item \$TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
    catch { Write-Warning "Cannot remove \$TMP_DOWNLOAD_DIR" }
  }
}

New-Item -Itemtype Directory -Path "\$MAVEN_HOME_PARENT" -Force | Out-Null

# Download and Install Apache Maven
Write-Verbose "Couldn't find MAVEN_HOME, downloading and installing it ..."
Write-Verbose "Downloading from: \$distributionUrl"
Write-Verbose "Downloading to: \$TMP_DOWNLOAD_DIR/\$distributionUrlName"

\$webclient = New-Object System.Net.WebClient
if (\$env:MVNW_USERNAME -and \$env:MVNW_PASSWORD) {
  \$webclient.Credentials = New-Object System.Net.NetworkCredential(\$env:MVNW_USERNAME, \$env:MVNW_PASSWORD)
}
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
\$webclient.DownloadFile(\$distributionUrl, "\$TMP_DOWNLOAD_DIR/\$distributionUrlName") | Out-Null

# If specified, validate the SHA-256 sum of the Maven distribution zip file
\$distributionSha256Sum = (Get-Content -Raw "\$scriptDir/.mvn/wrapper/maven-wrapper.properties" | ConvertFrom-StringData).distributionSha256Sum
if (\$distributionSha256Sum) {
  if (\$USE_MVND) {
    Write-Error "Checksum validation is not supported for maven-mvnd. `nPlease disable validation by removing 'distributionSha256Sum' from your maven-wrapper.properties."
  }
  Import-Module \$PSHOME\Modules\Microsoft.PowerShell.Utility -Function Get-FileHash
  if ((Get-FileHash "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -Algorithm SHA256).Hash.ToLower() -ne \$distributionSha256Sum) {
    Write-Error "Error: Failed to validate Maven distribution SHA-256, your Maven distribution might be compromised. If you updated your Maven version, you need to update the specified distributionSha256Sum property."
  }
}

# unzip and move
Expand-Archive "\$TMP_DOWNLOAD_DIR/\$distributionUrlName" -DestinationPath "\$TMP_DOWNLOAD_DIR" | Out-Null
Rename-Item -Path "\$TMP_DOWNLOAD_DIR/\$distributionUrlNameMain" -NewName \$MAVEN_HOME_NAME | Out-Null
try {
  Move-Item -Path "\$TMP_DOWNLOAD_DIR/\$MAVEN_HOME_NAME" -Destination \$MAVEN_HOME_PARENT | Out-Null
} catch {
  if (! (Test-Path -Path "\$MAVEN_HOME" -PathType Container)) {
    Write-Error "fail to move MAVEN_HOME"
  }
} finally {
  try { Remove-Item \$TMP_DOWNLOAD_DIR -Recurse -Force | Out-Null }
  catch { Write-Warning "Cannot remove \$TMP_DOWNLOAD_DIR" }
}

Write-Output "MVN_CMD=\$MAVEN_HOME/bin/\$MVN_CMD"
CMD;
    }

    /**
     * Generates the application.properties file.
     * @return string The content of application.properties.
     */
    public function generateApplicationProperties() {
        $requireLoginValue = $this->requireLogin ? 'true' : 'false';
        return <<<PROPERTIES
spring.application.name={$this->projectConfig['name']}

# Database Configuration (Please update with your details)
app.security.require-login=$requireLoginValue

# Default language for i18n
app.i18n.default-language=en

# Session Management
spring.session.store-type=none # Default to none, uncomment below to use Redis
# spring.session.store-type=redis
# spring.data.redis.host=localhost
# spring.data.redis.port=6379
# spring.session.timeout=30m

# Session and Cookie Lifetime
# Set session timeout. e.g., 30m for 30 minutes, 1h for 1 hour.
server.servlet.session.timeout=30m
server.servlet.session.cookie.max-age=30m

# CORS Configuration (Cross-Origin Resource Sharing)
app.security.cors.enabled=true
app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:4000,http://127.0.0.1:4000,http://127.0.0.1:3000,http://localhost:8080

spring.datasource.url={DB_URL}
spring.datasource.username={DB_USER}
spring.datasource.password={DB_PASS}
spring.datasource.driver-class-name={DB_DRIVER_CLASS}

# JPA/Hibernate Configuration
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.dialect={DB_DIALECT}

# Use database column names directly without converting to camelCase
spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl

# GraphQL Configuration
spring.graphql.graphiql.enabled=true
spring.graphql.schema.locations=classpath:graphql/
spring.graphql.schema.file-extensions=.graphqls

# Caching (optional)
# spring.cache.type=caffeine
PROPERTIES;
    }

    /**
     * Generates the main Spring Boot application class in Kotlin.
     * @return string The content of the main application class.
     */
    private function generateMainAppClass()
    {
        $className = $this->pascalCase($this->projectConfig['artifactId']) . 'Application';
        $packageName = $this->projectConfig['packageName'];
        $cachingAnnotation = $this->useCache ? "@EnableCaching" : "";

        $useCaseImport = $this->useCache ? "import org.springframework.cache.annotation.EnableCaching\n" : "";

        return <<<KOTLIN
package $packageName

import org.springframework.boot.autoconfigure.SpringBootApplication
import org.springframework.boot.runApplication
{$useCaseImport}
$cachingAnnotation
@SpringBootApplication
class $className

fun main(args: Array<String>) {
	runApplication<$className>(*args)
}
KOTLIN;
    }

    /**
     * Generates the Kotlin entity data class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the entity class.
     */
    private function generateEntityClass($tableName, $tableInfo)
    {
        $className = ucfirst($this->camelCase($tableName));
        $package = $this->projectConfig['packageName'];

        $imports = "import jakarta.persistence.*\nimport java.io.Serializable\n";
        $fields = "";
        $importSet = array();

        $nCols = count($tableInfo['columns']);
        $i = 0;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);

            if (strpos($kotlinType, 'LocalDateTime') !== false) $hasLdt = true;
            if (strpos($kotlinType, 'LocalDate') !== false) $hasLd = true;

            $annotations = "";
            if ($colInfo['isPrimaryKey']) {
                $annotations .= "    @Id\n";
                if ($colInfo['isAutoIncrement']) {
                    if($colInfo['primaryKeyValue'] == 'autogenerated') {
                        $fields .= "    @GeneratedValue(strategy = GenerationType.IDENTITY)\n";
                    }
                }
            }
            
            if ($colInfo['isForeignKey']) {
                $importSet['JsonIgnore'] = "import com.fasterxml.jackson.annotation.JsonIgnore";
                $importSet['NotFound'] = "import org.hibernate.annotations.NotFound";
                $importSet['NotFoundAction'] = "import org.hibernate.annotations.NotFoundAction";
                
                $refTableName = $colInfo['references'];
                $refClassName = $this->pascalCase($refTableName);
                $refFieldName = $this->camelCase($refTableName);

                // Foreign key column
                $fields .= "    @Column(name = \"$colName\")\n";
                $fields .= "    var $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null,\n\n";
                
                // Relationship
                $fields .= "    @JsonIgnore\n";
                $fields .= "    @ManyToOne(fetch = FetchType.LAZY)\n";
                $fields .= "    @NotFound(action = NotFoundAction.IGNORE)\n";
                $fields .= "    @JoinColumn(name = \"$colName\", insertable = false, updatable = false)\n";
                $fields .= "    var $refFieldName: $refClassName? = null,\n\n";
                continue;
            } else if ($fieldName !== $colName) {
                $fields .= "    @Column(name = \"$colName\")\n";
            }
            
            $fields .= "    var $fieldName: " . basename(str_replace('\\', '/', $kotlinType)) . "? = null";
            $i++;
            if( $i < $nCols ) {
                $fields .= ",";
            }
            $fields .= "\n\n";
            
            
        }
        
        $imports .= implode("\n", $importSet);

        // Use 'class' instead of 'data class' if there are no fields to avoid compilation errors.
        $classType = !empty(trim($fields)) ? 'data class' : 'class';
        $fields = rtrim($fields);

        return <<<KOTLIN
package $package.model.entity

$imports
@Entity
@Table(name = "$tableName")
data class $className(
$fields) : Serializable
KOTLIN;
    }

    /**
     * Generates the Kotlin repository interface for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the repository interface.
     */
    private function generateRepositoryInterface($tableName, $tableInfo)
    {
        $className = ucfirst($this->camelCase($tableName));
        $package = $this->projectConfig['packageName'];
        $pkKotlinType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkKotlinType = str_replace('?', '', $this->mapDbTypeToKotlinType($col['type'], $col['length']));
                break;
            }
        }

        $imports = "import org.springframework.data.jpa.repository.JpaRepository\n";
        $imports .= "import org.springframework.data.jpa.repository.JpaSpecificationExecutor\n";
        $imports .= "import $package.model.entity.$className\n";
        if ($this->useCache) {
            $imports .= "import org.springframework.cache.annotation.Cacheable\n";
        }
        $imports .= "import java.util.Optional\n";

        $findByIdMethod = "override fun findById(id: $pkKotlinType): Optional<$className>";
        if ($this->useCache) {
            $findByIdMethod = "@Cacheable(value = \"{$this->camelCase($tableName)}\", key = \"#id\")\n    " . $findByIdMethod;
        }

        return <<<KOTLIN
package $package.model.repository

$imports
import org.springframework.stereotype.Repository

@Repository
interface {$className}Repository : JpaRepository<$className, $pkKotlinType>, JpaSpecificationExecutor<$className> {
    $findByIdMethod
}
KOTLIN;
    }

    /**
     * Generates the DTO data class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the DTO class.
     */
    private function generateDtoClass($tableName, $tableInfo)
    {
        $className = ucfirst($this->camelCase($tableName)) . "Input";
        $package = $this->projectConfig['packageName'];

        $imports = "";
        $fields = "";
        $hasLdt = false;
        $hasLd = false;

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $fieldName = $this->camelCase($colName);
            if (strpos($kotlinType, 'LocalDateTime') !== false) $hasLdt = true;
            if (strpos($kotlinType, 'LocalDate') !== false) $hasLd = true;
            $fixedKotlinType = basename(str_replace(['\\', '.'], '/', $kotlinType));
            $fields .= "    var $fieldName: $fixedKotlinType = null,\n";
        }

        if ($hasLdt) $imports .= "import java.time.LocalDateTime\n";
        if ($hasLd) $imports .= "import java.time.LocalDate\n";
        $field = rtrim($fields, ",\n");
        return <<<KOTLIN
package $package.model.dto

$imports
data class $className(
$field
)
KOTLIN;
    }

    /**
     * Generates the Controller class for a given table.
     * @param string $tableName The name of the database table.
     * @param array $tableInfo The information about the table's columns.
     * @return string The content of the Controller class.
     */
    private function generateControllerClass($tableName, $tableInfo)
    {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);
        $package = $this->projectConfig['packageName'];
        $pkKotlinType = 'String';
        foreach ($tableInfo['columns'] as $col) {
            if ($col['isPrimaryKey']) {
                $pkKotlinType = str_replace('?', '', $this->mapDbTypeToKotlinType($col['type'], $col['length']));
                break;
            }
        }

        return <<<KOTLIN
package $package.controller

import $package.model.dto.FilterInput
import $package.model.dto.SortInput
import $package.model.dto.{$ucCamelName}Input
import $package.model.entity.$ucCamelName
import $package.model.repository.{$ucCamelName}Repository
import $package.util.QueryUtil
import org.springframework.beans.BeanUtils
import org.springframework.data.domain.Page
import org.springframework.graphql.data.method.annotation.Argument
import org.springframework.graphql.data.method.annotation.MutationMapping
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.stereotype.Controller

@Controller
class {$ucCamelName}Controller(private val {$camelName}Repository: {$ucCamelName}Repository) {

    @QueryMapping
    fun {$camelName}(@Argument id: $pkKotlinType): $ucCamelName? {
        return {$camelName}Repository.findById(id).orElse(null)
    }

    @QueryMapping
    fun {$pluralCamelName}(
        @Argument limit: Int?,
        @Argument offset: Int?,
        @Argument page: Int?,
        @Argument size: Int?,
        @Argument orderBy: List<SortInput>?,
        @Argument filter: List<FilterInput>?
    ): Map<String, Any> {
        val pageable = QueryUtil.createPageable(limit, offset, page, size, orderBy)
        val specification = QueryUtil.createSpecification<$ucCamelName>(filter)
        val resultPage: Page<$ucCamelName> = {$camelName}Repository.findAll(specification, pageable)
        return QueryUtil.createPageResultMap(resultPage)
    }

    @MutationMapping
    fun create{$ucCamelName}(@Argument input: {$ucCamelName}Input): $ucCamelName {
        val entity = $ucCamelName()
        BeanUtils.copyProperties(input, entity)
        // Additional logic for creation can be added here
        return {$camelName}Repository.save(entity)
    }

    @MutationMapping
    fun update{$ucCamelName}(@Argument id: $pkKotlinType, @Argument input: {$ucCamelName}Input): $ucCamelName {
        val entity = {$camelName}Repository.findById(id)
            .orElseThrow { RuntimeException("$ucCamelName not found with id \$id") }
        BeanUtils.copyProperties(input, entity)
        // Additional logic for update can be added here
        return {$camelName}Repository.save(entity)
    }

    @MutationMapping
    fun delete{$ucCamelName}(@Argument id: $pkKotlinType): Boolean {
        {$camelName}Repository.deleteById(id)
        return true
    }
}
KOTLIN;
    }

    /**
     * Generates the GraphQL schema parts for a given table.
     * @param string $tableName The name of the table.
     * @param array $tableInfo The table information.
     * @return array An array containing 'types', 'queries', and 'mutations' strings.
     */
    private function getSchemaPartsForTable($tableName, $tableInfo)
    {
        $camelName = $this->camelCase($tableName);
        $ucCamelName = ucfirst($camelName);
        $pluralCamelName = $this->pluralize($camelName);

        // Type fields
        $fields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $gqlType = $this->mapKotlinTypeToGqlType($kotlinType);
            $fieldName = $this->camelCase($colName);
            $fields .= "    $fieldName: $gqlType\n";
        }

        // Input fields
        $inputFields = "";
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated')) {
                continue;
            }
            $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
            $gqlType = $this->mapKotlinTypeToGqlType($kotlinType);
            $fieldName = $this->camelCase($colName);
            $inputFields .= "    $fieldName: $gqlType\n";
        }

        $types = <<<GQL
type $ucCamelName {
$fields}

input {$ucCamelName}Input {
$inputFields}

type {$ucCamelName}Page {
    items: [$ucCamelName],
    total: Int,
    limit: Int,
    page: Int,
    totalPages: Int,
    hasNext: Boolean,
    hasPrevious: Boolean
}
GQL;

        $pkKotlinType = $this->mapDbTypeToKotlinType($tableInfo['columns'][$tableInfo['primaryKey']]['type'], $tableInfo['columns'][$tableInfo['primaryKey']]['length']);
        $pkGqlType = $this->mapKotlinTypeToGqlType($pkKotlinType);

        $queries = "    {$camelName}(id: {$pkGqlType}!): $ucCamelName\n";
        $queries .= "    {$pluralCamelName}(limit: Int, offset: Int, page: Int, size: Int, orderBy: [SortInput], filter: [FilterInput]): {$ucCamelName}Page\n";

        $mutations = "    create{$ucCamelName}(input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    update{$ucCamelName}(id: {$pkGqlType}!, input: {$ucCamelName}Input!): $ucCamelName\n";
        $mutations .= "    delete{$ucCamelName}(id: {$pkGqlType}!): Boolean\n";

        return [
            'types' => $types,
            'queries' => $queries,
            'mutations' => $mutations
        ];
    }

    /**
     * Combines all schema parts into a single GraphQL schema string.
     * @param array $allSchemaParts Array of type definitions.
     * @param array $allQueryFields Array of query definitions.
     * @param array $allMutationFields Array of mutation definitions.
     * @return string The complete GraphQL schema.
     */
    private function generateCombinedSchema($allSchemaParts, $allQueryFields, $allMutationFields)
    {
        $typesString = implode("\n", $allSchemaParts);
        $queriesString = implode("", $allQueryFields);
        $mutationsString = implode("", $allMutationFields);

        return <<<GQL
enum SortDirection {
    ASC
    DESC
}

enum FilterOperator {
    EQUALS
    NOT_EQUALS
    CONTAINS
    GREATER_THAN
    GREATER_THAN_OR_EQUALS
    LESS_THAN
    LESS_THAN_OR_EQUALS
    IN
    NOT_IN
}

input SortInput {
    field: String!
    direction: SortDirection
}

input FilterInput {
    field: String!
    value: String
    operator: FilterOperator
}

$typesString

type Query {
$queriesString}

type Mutation {
$mutationsString}
GQL;
    }

    /**
     * Generates a markdown manual with examples for all queries and mutations.
     *
     * @return string The markdown content.
     */
    public function generateManual()
    {
        $manualContent = "# Kotlin GraphQL API Manual\r\n\r\n";
        $manualContent .= "This document provides examples for all available queries and mutations for your Spring Boot application.\r\n\r\n";

        $manualContent .= "## Dependencies\r\n\r\n";
        $manualContent .= "All required dependencies are defined in the `build.gradle.kts` file. Gradle will handle downloading them automatically.\r\n\r\n";

        $manualContent .= "## Database Connection\r\n\r\n";
        $manualContent .= "This API requires a database connection. You must configure the `src/main/resources/application.properties` file. Here is an example for connecting to a MySQL database:\r\n\r\n";
        $manualContent .= "```properties\r\n";
        $manualContent .= "spring.application.name=YourAppName\r\n\r\n";
        $manualContent .= "# Database Configuration (Please update with your details)\r\n";
        $manualContent .= "app.security.require-login=true\r\n\r\n";
        $manualContent .= "# CORS Configuration (Cross-Origin Resource Sharing)\r\n";
        $manualContent .= "app.security.cors.enabled=true\r\n";
        $manualContent .= "app.security.cors.allowed-origins=http://localhost,http://127.0.0.1,http://localhost:3000,http://localhost:8080\r\n\r\n";
        $manualContent .= "spring.datasource.url=jdbc:mysql://localhost:3306/your_database_name\r\n";
        $manualContent .= "spring.datasource.username=your_username\r\n";
        $manualContent .= "spring.datasource.password=your_password\r\n";
        $manualContent .= "spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\r\n\r\n";
        $manualContent .= "# JPA/Hibernate Configuration\r\n";
        $manualContent .= "spring.jpa.hibernate.ddl-auto=update\r\n";
        $manualContent .= "spring.jpa.show-sql=true\r\n";
        $manualContent .= "spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQLDialect\r\n";
        $manualContent .= "spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\r\n\r\n";
        $manualContent .= "# GraphQL Properties\r\n";
        $manualContent .= "spring.graphql.graphiql.enabled=true\r\n";
        $manualContent .= "spring.graphql.schema.locations=classpath:graphql/\r\n";
        $manualContent .= "spring.graphql.schema.file-extensions=.graphqls\r\n";
        $manualContent .= "```\r\n\r\n";
        $manualContent .= "Make sure to replace `your_database_name`, `your_username`, and `your_password` with your actual database credentials.\r\n\r\n";

        $manualContent .= "---\r\n\r\n";

        foreach ($this->analyzedSchema as $tableName => $tableInfo) {
            $camelName = $this->camelCase($tableName);
            $pluralCamelName = $this->pluralize($camelName);
            $ucCamelName = ucfirst($camelName);

            $manualContent .= "## " . $ucCamelName . "\r\n\r\n";

            // --- Get Fields for examples ---
            $fieldsString = $this->getFieldsForManual($tableInfo, false);
            $mutationFieldsString = $this->getFieldsForManual($tableInfo, true); // No relations for mutation return

            // --- Query Examples ---
            $manualContent .= "### Queries\r\n\r\n";

            // Get Single Item
            $manualContent .= "#### Get a single " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . $ucCamelName . " {\r\n";
            $manualContent .= "  " . $camelName . "(id: \"your-" . $camelName . "-id\") {\r\n";
            $manualContent .= $fieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Get List
            $manualContent .= "#### Get a list of " . $pluralCamelName . " (with filter & sort)\r\n\r\n";
            $manualContent .= "Supports `limit`, `offset`, `orderBy`, and `filter`.\r\n\r\n";

            $filterField = $this->camelCase($tableInfo['primaryKey']);
            $filterValue = '"your-' . $camelName . '-id"';
            $filterOperator = 'EQUALS';

            foreach ($tableInfo['columns'] as $columnName => $columnInfo) {
                if (($columnName === 'name' || $columnName === 'title') && !$columnInfo['isForeignKey']) {
                    $filterField = $this->camelCase($columnName);
                    $filterValue = '"some-text"';
                    $filterOperator = 'CONTAINS';
                    break;
                }
            }

            $manualContent .= "```graphql\r\n";
            $manualContent .= "query Get" . ucfirst($pluralCamelName) . " {\r\n";
            $manualContent .= "  " . $pluralCamelName . "(\r\n    limit: 10, \r\n    offset: 0, \r\n    orderBy: [{field: \"" . $this->camelCase($tableInfo['primaryKey']) . "\", direction: DESC}],\r\n    filter: [{field: \"" . $filterField . "\", value: " . $filterValue . ", operator: " . $filterOperator . "}]\r\n  ) {\r\n";
            $manualContent .= "    items {\r\n";
            $manualContent .= preg_replace('/^/m', '      ', $fieldsString); // Indent fields
            $manualContent .= "    }\r\n";
            $manualContent .= "    total\r\n";
            $manualContent .= "    limit\r\n";
            $manualContent .= "    page\r\n";
            $manualContent .= "    totalPages\r\n";
            $manualContent .= "    hasNext\r\n";
            $manualContent .= "    hasPrevious\r\n";
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // --- Mutation Examples ---
            $manualContent .= "### Mutations\r\n\r\n";

            list(, $inputExampleString) = $this->getInputFieldsForManual($tableInfo);

            // Create
            $manualContent .= "#### Create a new " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Create" . $ucCamelName . " {\r\n";
            $manualContent .= "  create" . $ucCamelName . "(input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Update
            $manualContent .= "#### Update an existing " . $camelName . "\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Update" . $ucCamelName . " {\r\n";
            $manualContent .= "  update" . $ucCamelName . "(id: \"your-" . $camelName . "-id\", input: {\r\n" . $inputExampleString . "  }) {\r\n";
            $manualContent .= $mutationFieldsString;
            $manualContent .= "  }\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";

            // Delete
            $manualContent .= "#### Delete a " . $camelName . "\r\n\r\n";
            $manualContent .= "Returns `true` on success.\r\n\r\n";
            $manualContent .= "```graphql\r\n";
            $manualContent .= "mutation Delete" . $ucCamelName . " {\r\n";
            $manualContent .= "  delete" . $ucCamelName . "(id: \"your-" . $camelName . "-id\")\r\n";
            $manualContent .= "}\r\n";
            $manualContent .= "```\r\n\r\n";
        }

        // --- API Reference Guide ---
        $manualContent .= "## API Reference Guide\r\n\r\n";
        $manualContent .= "This section provides a reference for common arguments used in list queries.\r\n\r\n";

        // Filtering
        $manualContent .= "### Filtering (`filter`)\r\n\r\n";
        $manualContent .= "The `filter` argument allows you to narrow down results based on field values. It accepts a list of filter objects, which are combined with `AND` logic.\r\n\r\n";
        $manualContent .= "| Operator       | Description                                      | Example                                                |\r\n";
        $manualContent .= "|----------------|--------------------------------------------------|--------------------------------------------------------|\r\n";
        $manualContent .= "| `EQUALS`       | Finds records where the field exactly matches the value. | `{field: \"status\", value: \"published\"}`                |\r\n";
        $manualContent .= "| `NOT_EQUALS`   | Finds records where the field does not match the value. | `{field: \"status\", value: \"archived\", operator: NOT_EQUALS}` |\r\n";
        $manualContent .= "| `CONTAINS`     | Finds records where the text field contains the value (`LIKE '%value%'`). | `{field: \"title\", value: \"love\", operator: CONTAINS}` |\r\n";
        $manualContent .= "| `GREATER_THAN_OR_EQUALS` | Finds records where the numeric/date field is greater than or equal to the value. | `{field: \"price\", value: \"99.99\", operator: GREATER_THAN_OR_EQUALS}` |\r\n";
        $manualContent .= "| `GREATER_THAN` | Finds records where the numeric/date field is greater than the value. | `{field: \"price\", value: \"100\", operator: GREATER_THAN}` |\r\n";
        $manualContent .= "| `LESS_THAN_OR_EQUALS`    | Finds records where the numeric/date field is less than or equal to the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN_OR_EQUALS}`   |\r\n";
        $manualContent .= "| `LESS_THAN`    | Finds records where the numeric/date field is less than the value. | `{field: \"stock\", value: \"10\", operator: LESS_THAN}`   |\r\n";
        $manualContent .= "| `IN` / `NOT_IN` | Finds records where the field value is in (or not in) a comma-separated list of values. | `{field: \"categoryId\", value: \"1,2,3\", operator: IN}` |\r\n\r\n";

        // Sorting
        $manualContent .= "### Sorting (`orderBy`)\r\n\r\n";
        $manualContent .= "The `orderBy` argument sorts the results. It accepts a list of sort objects.\r\n\r\n";
        $manualContent .= "- `field`: The name of the field to sort by (e.g., `\"name\"`).\r\n";
        $manualContent .= "- `direction`: The sort direction. Can be `ASC` (ascending) or `DESC` (descending). Defaults to `ASC`.\r\n\r\n";
        $manualContent .= "**Example:** `orderBy: [{field: \"releaseDate\", direction: DESC}]`\r\n\r\n";

        // Pagination
        $manualContent .= "### Pagination (`limit` & `offset` or `page` & `size`)\r\n\r\n";
        $manualContent .= "- `limit` / `size`: Specifies the maximum number of records to return.\r\n";
        $manualContent .= "- `offset` / `page`: Specifies the starting point of the records.\r\n\r\n";
        $manualContent .= "**Example:** To get the second page of 10 items: `limit: 10, offset: 10` or `page: 2, size: 10`\r\n\r\n";

        return $manualContent;
    }

    //<editor-fold desc="Utility and Config Generators">

    public function getProjectConfig()
    {
        return $this->projectConfig;
    }

    private function generateSpecificationBuilder()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import org.springframework.data.jpa.domain.Specification

class SpecificationBuilder<T> {
    private val params: MutableList<FilterCriteria> = mutableListOf()

    fun with(key: String, operation: SearchOperation, value: Any): SpecificationBuilder<T> {
        params.add(FilterCriteria(key, operation, value))
        return this
    }

    fun build(): Specification<T>? {
        if (params.isEmpty()) {
            return null
        }

        val specs = params.map { GenericSpecification<T>(it) }
        var result = specs[0]

        for (i in 1 until params.size) {
            result = Specification.where(result).and(specs[i])
        }
        return result
    }
}
KOTLIN;
    }

    private function generateFilterCriteria()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

data class FilterCriteria(
    val key: String,
    val operation: SearchOperation,
    val value: Any?
)
KOTLIN;
    }

    private function generateSearchOperation()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

enum class SearchOperation {
    EQUALS,
    NOT_EQUALS,
    CONTAINS,
    GREATER_THAN,
    GREATER_THAN_OR_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUALS,
    IN,
    NOT_IN
}
KOTLIN;
    }

    private function generateGenericSpecification()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.CriteriaQuery
import jakarta.persistence.criteria.Predicate
import jakarta.persistence.criteria.Root
import org.springframework.data.jpa.domain.Specification

class GenericSpecification<T>(private val criteria: FilterCriteria) : Specification<T> {

    override fun toPredicate(root: Root<T>, query: CriteriaQuery<*>, builder: CriteriaBuilder): Predicate? {
        val key = criteria.key
        val value = criteria.value
        val fieldType = root.get<Any>(key).javaType

        val typedValue = value?.let {
            val stringValue = it.toString()
            when (fieldType) {
                Integer::class.java, Int::class.java -> stringValue.toIntOrNull()
                Long::class.java, Long::class.java -> stringValue.toLongOrNull()
                Double::class.java, Double::class.java -> stringValue.toDoubleOrNull()
                Float::class.java, Float::class.java -> stringValue.toFloatOrNull()
                Boolean::class.java, Boolean::class.java -> stringValue.toBoolean()
                else -> stringValue
            }
        }

        return when (criteria.operation) {
            SearchOperation.EQUALS -> builder.equal(root.get<Any>(key), typedValue)
            SearchOperation.NOT_EQUALS -> builder.notEqual(root.get<Any>(key), typedValue)
            SearchOperation.GREATER_THAN -> builder.greaterThan(root.get(key), typedValue.toString())
            SearchOperation.GREATER_THAN_OR_EQUALS -> builder.greaterThanOrEqualTo(root.get(key), typedValue.toString())
            SearchOperation.LESS_THAN -> builder.lessThan(root.get(key), typedValue.toString())
            SearchOperation.LESS_THAN_OR_EQUALS -> builder.lessThanOrEqualTo(root.get(key), typedValue.toString())
            SearchOperation.CONTAINS -> if (fieldType == String::class.java) builder.like(root.get(key), "%\$typedValue%") else builder.equal(root.get(key), typedValue)
            SearchOperation.IN -> root.get<Any>(key).`in`(typedValue as? Collection<*>)
            SearchOperation.NOT_IN -> builder.not(root.get<Any>(key).`in`(typedValue as? Collection<*>))
        }
    }

    fun <T> createSpecification(filter: List<FilterInput>?): Specification<T>? {
        if (filter.isNullOrEmpty()) {
            return null
        }
        val builder = SpecificationBuilder<T>()
        filter.forEach { f -> builder.with(f.field, SearchOperation.valueOf(f.operator.uppercase()), f.value) }
        return builder.build()
    }
}
KOTLIN;
    }

    private function generateFilterInputDto()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.dto

data class FilterInput(
    val field: String,
    val value: String?,
    val operator: String?
)
KOTLIN;
    }

    private function generateSortInputDto()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.dto

data class SortInput(
    val field: String,
    val direction: String = "ASC"
)
KOTLIN;
    }

    //</editor-fold>

    //<editor-fold desc="Security and Auth Generators">

    private function generateSecurityConfig()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import $package.service.JpaUserDetailsService
import org.springframework.beans.factory.annotation.Value
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.http.HttpStatus
import org.springframework.security.config.annotation.web.builders.HttpSecurity
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity
import org.springframework.security.config.http.SessionCreationPolicy
import org.springframework.security.web.SecurityFilterChain
import org.springframework.security.web.authentication.HttpStatusEntryPoint

@Configuration
@EnableWebSecurity
class SecurityConfig {

    @Value("\${app.security.require-login:true}")
    private val requireLogin: Boolean = true

    @Bean
    fun passwordEncoder(): Sha1PasswordEncoder {
        return Sha1PasswordEncoder()
    }

    @Bean
    @Throws(Exception::class)
    fun securityFilterChain(http: HttpSecurity): SecurityFilterChain {
        http {
            csrf { disable() }
            logout { disable() }

            if (!requireLogin) {
                authorizeRequests {
                    anyRequest.permitAll()
                }
                sessionManagement {
                    sessionCreationPolicy = SessionCreationPolicy.STATELESS
                }
            } else {
                authorizeRequests {
                    listOf(
                        "/login", "/logout", "/", "/index.html", "/assets/**", "/favicon.ico",
                        "/graphiql/**", "/vendor/**"
                    ).forEach { authorize(it, permitAll) }
                    anyRequest.authenticated()
                }
                // Additional session/filter configuration would go here
            }
        }

        return http.build()
    }
}

@Configuration
@ConditionalOnProperty(name = "spring.session.store-type", havingValue = "redis")
@EnableRedisHttpSession
class RedisSessionConfig {
    // This class is intentionally empty.
    // Its purpose is to conditionally enable Redis session management
    // based on the application properties.
}
KOTLIN;
    }

    private function generateCorsConfig()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import org.springframework.beans.factory.annotation.Value
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.web.servlet.config.annotation.CorsRegistry
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer

@Configuration
@Configuration
class CorsConfig {

    @Value("$"."{app.cors.origins:*}")
    private lateinit var origins: String

    @Bean
    @ConditionalOnProperty(name = "app.security.cors.enabled", havingValue = "true")
    fun corsConfigurer(): WebMvcConfigurer {
        return object : WebMvcConfigurer {
            override fun addCorsMappings(registry: CorsRegistry) {
                registry.addMapping("/**") // Apply to all endpoints
                        .allowedOrigins(*allowedOrigins)
                        .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                        .allowedHeaders("*")
                        .allowCredentials(true)
            }
        }
    }
}
KOTLIN;
    }

    private function generateSha1PasswordEncoder()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import org.springframework.security.crypto.password.PasswordEncoder
import java.math.BigInteger
import java.security.MessageDigest

class Sha1PasswordEncoder : PasswordEncoder {

    override fun encode(rawPassword: CharSequence): String {
        return sha1(sha1(rawPassword.toString()))
    }

    override fun matches(rawPassword: CharSequence, encodedPassword: String): Boolean {
        return encodedPassword == encode(rawPassword)
    }

    fun sha1(input: String): String {
        val md = MessageDigest.getInstance("SHA-1")
        val messageDigest = md.digest(input.toByteArray())
        val no = BigInteger(1, messageDigest)
        var hashtext = no.toString(16)
        while (hashtext.length < 40) {
            hashtext = "0\$hashtext"
        }
        return hashtext
    }
}
KOTLIN;
    }

    private function generateUserDetailsService()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.service

import $package.model.repository.AdminRepository
import org.springframework.security.core.userdetails.User
import org.springframework.security.core.userdetails.UserDetails
import org.springframework.security.core.userdetails.UserDetailsService
import org.springframework.security.core.userdetails.UsernameNotFoundException
import org.springframework.stereotype.Service

@Service
class JpaUserDetailsService(private val adminRepository: AdminRepository) : UserDetailsService {

    override fun loadUserByUsername(username: String): UserDetails {
        val admin = adminRepository.findByUsername(username)
            .orElseThrow { UsernameNotFoundException("Username not found: $username") }

        return User.withUsername(admin.username!!)
            .password(admin.password!!)
            .authorities("USER").build()
    }
}
KOTLIN;
    }

    private function generateAdminEntity()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.entity

import jakarta.persistence.Column
import jakarta.persistence.Entity
import jakarta.persistence.Id
import jakarta.persistence.Table

@Entity
@Table(name = "admin")
data class Admin(
    @Id
    @Column(name = "admin_id")
    var adminId: String? = null,
    var username: String? = null,
    var password: String? = null,
    var name: String? = null,
    var email: String? = null,
    var phone: String? = null,
    @Column(name = "admin_level_id")
    var adminLevelId: String? = null
)
KOTLIN;
    }

    private function generateAdminRepository()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.model.repository

import $package.model.entity.Admin
import org.springframework.data.jpa.repository.JpaRepository
import java.util.Optional

interface AdminRepository : JpaRepository<Admin, String> {
    fun findByUsername(username: String): Optional<Admin>
}
KOTLIN;
    }

    private function generateLoginRequestDto()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.dto

data class LoginRequest(
    val username: String,
    val password: String
)
KOTLIN;
    }

    private function generateLoginResponseDto()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.dto

data class LoginResponse(
    val success: Boolean,
    val message: String
)
KOTLIN;
    }

    private function generateUserProfileController()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller.core

import $package.model.repository.AdminRepository
import jakarta.servlet.http.HttpSession
import org.springframework.graphql.data.method.annotation.QueryMapping
import org.springframework.security.access.prepost.PreAuthorize
import org.springframework.stereotype.Controller

data class UserProfile(val username: String)

@Controller
class UserProfileController(private val adminRepository: AdminRepository) {

    @QueryMapping
    @PreAuthorize("isAuthenticated()")
    fun userProfile(session: HttpSession): UserProfile? {
        val username = session.getAttribute("username") as? String
        if (username != null) {
            val adminOptional = adminRepository.findByUsername(username)
            if (adminOptional.isPresent) {
                val admin = adminOptional.get()
                return UserProfile(username = admin.username!!)
            }
        }
        return null
    }

    @QueryMapping
    fun me(session: HttpSession): Map<String, Any?> {
        return mapOf("username" to session.getAttribute("username"))
    }
}
KOTLIN;

    }

    private function generateAuthController()
    {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.controller

import $package.config.Sha1PasswordEncoder
import $package.controller.dto.LoginResponse
import $package.model.repository.AdminRepository
import jakarta.servlet.http.HttpServletRequest
import jakarta.servlet.http.HttpSession
import org.springframework.beans.factory.annotation.Value
import org.springframework.http.HttpStatus
import org.springframework.http.ResponseEntity
import org.springframework.web.bind.annotation.*

@RestController
class AuthController(
    private val adminRepository: AdminRepository,
    private val passwordEncoder: Sha1PasswordEncoder
) {

    @Value("$"."{app.security.require-login:true}")
    private val requireLogin: Boolean = true

    @PostMapping("/login")
    fun login(@RequestParam username: String, @RequestParam password: String, session: HttpSession): ResponseEntity<LoginResponse> {
        if (!requireLogin) {
            return ResponseEntity.ok(LoginResponse(true, "Success"))
        }

        val singleHashedPassword = passwordEncoder.sha1(password)
        return adminRepository.findByUsername(username)
            .filter { admin -> passwordEncoder.matches(password, admin.password) }
            .map { admin ->
                session.setAttribute("username", admin.username)
                session.setAttribute("password", singleHashedPassword)
                session.setAttribute("adminId", admin.adminId)
                ResponseEntity.ok(LoginResponse(true, "Login successful"))
            }
        }

        return ResponseEntity.status(HttpStatus.UNAUTHORIZED)
            .body(LoginResponse(false, "Invalid credentials"))
    }

    @RequestMapping(value = ["/logout"], method = [RequestMethod.GET, RequestMethod.POST])
    fun logout(request: HttpServletRequest): ResponseEntity<LoginResponse> {
        request.session?.invalidate()
        return ResponseEntity.ok(LoginResponse(true, "Logout successful"))
    }
}
KOTLIN;
    }

    // The following methods are placeholders for the full conversion.
    // The original Java generator has many more files it creates (Admin entities, Auth controllers, etc.).
    // Each would need a corresponding `generate...Kt()` method here.

    /**
     * Get whether to enable verbose logging in the generated application.
     *
     * @return bool True if verbose logging is enabled, false otherwise.
     */ 
    public function getVerboseLogging()
    {
        return $this->verboseLogging;
    }

    private function findPrimaryKeyInfo($tableInfo)
    {
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colInfo['isPrimaryKey']) {
                return array_merge($colInfo, ['name' => $colName]);
            }
        }
        return null;
    }

    private function generateDtoToEntityMappingKt($tableName, $tableInfo, $entityVar, $dtoVar, $action) {
        $mappingCode = "";

        $backendHandledColumnNames = $this->getBackendHandledColumnNames();

        if ($action == 'create') {
            $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
            if ($pkInfo && !$pkInfo['isAutoIncrement'] && $pkInfo['primaryKeyValue'] != 'autogenerated') {
                $pkCamelCase = $this->camelCase($pkInfo['name']);
                $mappingCode .= "        if (dtoInput.$pkCamelCase.isNullOrBlank()) {\n";
                $mappingCode .= "            throw RuntimeException(\"Invalid input: $pkCamelCase is required\")\n";
                $mappingCode .= "        }\n";
            }
        }

        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            if ($colName === $tableInfo['primaryKey'] && ($colInfo['isAutoIncrement'] || $colInfo['primaryKeyValue'] == 'autogenerated' || $action == 'update')) {
                continue;
            }
            if (in_array($colName, $backendHandledColumnNames)) {
                continue;
            }
            
            $camelColName = $this->camelCase($colName);
            $mappingCode .= "        dtoInput.$camelColName?.let { $entityVar.$camelColName = it }\n";
        }

        $hasTimeEdit = false;
        $hasAdminEdit = false;
        $hasIpEdit = false;

        foreach($this->backendHandledColumns as $key => $col) {
            if ($action == 'create' && $key == 'timeCreate') {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = java.time.LocalDateTime.now()\n";
            }
            if ($action == 'create' && $key == 'adminCreate') {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = AuditTrailUtil.getUserId()\n";
            }
            if ($action == 'create' && $key == 'ipCreate') {
                $mappingCode .= "        $entityVar.".$this->camelCase($col['columnName'])." = AuditTrailUtil.getUserIp()\n";
            }
            if ($key == 'timeEdit') {
                $hasTimeEdit = true;
            }
            if ($key == 'adminEdit') {
                $hasAdminEdit = true;
            }
            if ($key == 'ipEdit') {
                $hasIpEdit = true;
            }
        }

        if ($hasTimeEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['timeEdit']['columnName'])." = java.time.LocalDateTime.now()\n";
        if ($hasAdminEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['adminEdit']['columnName'])." = AuditTrailUtil.getUserId()\n";
        if ($hasIpEdit) $mappingCode .= "        $entityVar.".$this->camelCase($this->backendHandledColumns['ipEdit']['columnName'])." = AuditTrailUtil.getUserIp()\n";

        return $mappingCode;
    }

    private function generateToggleActiveMutationKt($tableName, $tableInfo)
    {
        if (!$tableInfo['hasActiveColumn']) {
            return "";
        }

        $camelName = $this->camelCase($tableName);
        $ucCamelName = $this->pascalCase($tableName);
        $activeField = $this->activeField;
        $ucActiveField = $this->pascalCase($activeField);
        
        $pkInfo = $this->findPrimaryKeyInfo($tableInfo);
        $pkKotlinType = $pkInfo ? $this->mapDbTypeToKotlinType($pkInfo['type'], $pkInfo['length']) : 'String';

        $mappingCode = "";
        if (isset($this->backendHandledColumns['timeEdit'])) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['timeEdit']['columnName'])." = java.time.LocalDateTime.now()\n";
        }
        if (isset($this->backendHandledColumns['adminEdit'])) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['adminEdit']['columnName'])." = AuditTrailUtil.getUserId()\n";
        }
        if (isset($this->backendHandledColumns['ipEdit'])) {
            $mappingCode .= "        entity.".$this->camelCase($this->backendHandledColumns['ipEdit']['columnName'])." = AuditTrailUtil.getUserIp()\n";
        }

        return <<<KOTLIN

    @MutationMapping
    @Transactional
    fun toggle{$ucCamelName}Active(@Argument id: $pkKotlinType, @Argument(name = "$activeField") $activeField: Boolean): $ucCamelName {
        val entity = {$camelName}Repository.findById(id)
                .orElseThrow { RuntimeException("{$ucCamelName} not found with id \$id") }
        entity.$ucActiveField = $activeField
$mappingCode
        return {$camelName}Repository.save(entity)
    }
KOTLIN;
    }

    private function generateFieldResolversKt($tableName, $tableInfo) {
        $resolvers = "";
        $ucCamelTableName = $this->pascalCase($tableName);
        $camelTableName = $this->camelCase($tableName);
    
        foreach ($tableInfo['columns'] as $colName => $colInfo) {
            $camelColName = $this->camelCase($colName);
            $ucCamelColName = $this->pascalCase($colName);
    
            if ($colName !== $camelColName) {
                $kotlinType = $this->mapDbTypeToKotlinType($colInfo['type'], $colInfo['length']);
                $baseKotlinType = basename(str_replace('\\', '/', $kotlinType));

                $returnValue = "$camelTableName.$camelColName";

                if(strpos($baseKotlinType, 'LocalDateTime') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localDateTimeToString($returnValue)";
                }
                else if(strpos($baseKotlinType, 'LocalDate') !== false) {
                    $baseKotlinType = 'String?';
                    $returnValue = "ScalarValueUtil.localDateToString($returnValue)";
                }

                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$colName\")\n";
                $resolvers .= "    fun get{$ucCamelColName}($camelTableName: $ucCamelTableName): $baseKotlinType {\n";
                $resolvers .= "        return $returnValue\n";
                $resolvers .= "    }\n";
            }
    
            if ($colInfo['isForeignKey']) {
                $refTableName = $colInfo['references'];
                $refCamelName = $this->camelCase($refTableName);
                $refUcCamelName = $this->pascalCase($refTableName);

                $resolvers .= "\n    @SchemaMapping(typeName = \"$ucCamelTableName\", field = \"$refTableName\")\n";
                $resolvers .= "    fun get".ucfirst($refCamelName)."($camelTableName: $ucCamelTableName): $refUcCamelName? {\n";
                $resolvers .= "        return $camelTableName.$refCamelName\n";
                $resolvers .= "    }\n";
            }
        }
    
        return $resolvers;
    }

    private function generateSpecificationBuilderKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import org.springframework.data.jpa.domain.Specification

class SpecificationBuilder<T> {
    private val params: MutableList<FilterCriteria> = mutableListOf()

    fun with(key: String, operation: SearchOperation, value: Any?): SpecificationBuilder<T> {
        params.add(FilterCriteria(key, operation, value))
        return this
    }

    fun build(): Specification<T>? {
        if (params.isEmpty()) {
            return null
        }
        val specs = params.map { GenericSpecification<T>(it) }
        var result = specs[0]
        for (i in 1 until specs.size) {
            result = result.and(specs[i])
        }
        return result
    }
}
KOTLIN;
    }

    private function generateFilterCriteriaKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

data class FilterCriteria(
    val key: String,
    val operation: SearchOperation,
    val value: Any?
)
KOTLIN;
    }

    private function generateSearchOperationKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

enum class SearchOperation {
    EQUALS,
    NOT_EQUALS,
    CONTAINS,
    GREATER_THAN,
    GREATER_THAN_OR_EQUALS,
    LESS_THAN,
    LESS_THAN_OR_EQUALS,
    IN,
    NOT_IN
}
KOTLIN;
    }

    private function generateGenericSpecificationKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import jakarta.persistence.criteria.CriteriaBuilder
import jakarta.persistence.criteria.CriteriaQuery
import jakarta.persistence.criteria.Predicate
import jakarta.persistence.criteria.Root
import org.springframework.data.jpa.domain.Specification

class GenericSpecification<T>(private val criteria: FilterCriteria) : Specification<T> {

    override fun toPredicate(root: Root<T>, query: CriteriaQuery<*>, builder: CriteriaBuilder): Predicate? {
        val key = criteria.key
        val value = criteria.value
        val fieldType = root.get<Any>(key).javaType

        val typedValue = value?.let {
            val stringValue = it.toString()
            when (fieldType) {
                Integer::class.java, Int::class.java -> stringValue.toIntOrNull()
                Long::class.java, Long::class.java -> stringValue.toLongOrNull()
                Double::class.java, Double::class.java -> stringValue.toDoubleOrNull()
                Float::class.java, Float::class.java -> stringValue.toFloatOrNull()
                Boolean::class.java, Boolean::class.java -> stringValue.toBoolean()
                else -> stringValue
            }
        }

        return when (criteria.operation) {
            SearchOperation.EQUALS -> builder.equal(root.get<Any>(key), typedValue)
            SearchOperation.NOT_EQUALS -> builder.notEqual(root.get<Any>(key), typedValue)
            SearchOperation.GREATER_THAN -> builder.greaterThan(root.get(key), typedValue.toString())
            SearchOperation.GREATER_THAN_OR_EQUALS -> builder.greaterThanOrEqualTo(root.get(key), typedValue.toString())
            SearchOperation.LESS_THAN -> builder.lessThan(root.get(key), typedValue.toString())
            SearchOperation.LESS_THAN_OR_EQUALS -> builder.lessThanOrEqualTo(root.get(key), typedValue.toString())
            SearchOperation.CONTAINS -> if (fieldType == String::class.java) builder.like(root.get(key), "%\$typedValue%") else builder.equal(root.get(key), typedValue)
            SearchOperation.IN -> root.get<Any>(key).`in`(typedValue as? Collection<*>)
            SearchOperation.NOT_IN -> builder.not(root.get<Any>(key).`in`(typedValue as? Collection<*>))
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the AuditTrailUtil object in Kotlin.
     * @return string The Kotlin code for AuditTrailUtil.kt.
     */
    private function generateAuditTrailUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import jakarta.servlet.http.HttpServletRequest
import org.springframework.web.context.request.RequestContextHolder
import org.springframework.web.context.request.ServletRequestAttributes

object AuditTrailUtil {

    /**
     * Retrieves the client's IP address from the current request.
     * It checks for the 'X-FORWARDED-FOR' header first.
     */
    fun getUserIp(): String? {
        val request = (RequestContextHolder.getRequestAttributes() as? ServletRequestAttributes)?.request ?: return null
        var remoteAddr = request.getHeader("X-FORWARDED-FOR")
        if (remoteAddr.isNullOrEmpty()) {
            remoteAddr = request.remoteAddr
        } else {
            remoteAddr = remoteAddr.split(",")[0].trim()
        }
        return remoteAddr
    }

    /**
     * Retrieves the ID of the currently authenticated admin user from the session.
     */
    fun getUserId(): String? {
        val request = (RequestContextHolder.getRequestAttributes() as? ServletRequestAttributes)?.request ?: return null
        val session = request.getSession(false)
        return session?.getAttribute("adminId") as? String
    }
}
KOTLIN;
    }

    /**
     * Generates the ValueUtil object in Kotlin for handling naming conversions and map-to-DTO conversions.
     * @return string The content of the ValueUtil class.
     */
    private function generateValueUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import com.fasterxml.jackson.databind.DeserializationFeature
import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule
import com.fasterxml.jackson.module.kotlin.registerKotlinModule

object ValueUtil {

    private val MAPPER: ObjectMapper = ObjectMapper().apply {
        registerKotlinModule()
        registerModule(JavaTimeModule())
        configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false)
        configure(DeserializationFeature.ACCEPT_FLOAT_AS_INT, true)
    }

    /**
     * Converts a Map with snake_case keys directly to a target DTO.
     */
    fun <T> convertSnakeCaseToDto(snakeCaseMap: Map<String, Any>?, targetClass: Class<T>): T {
        val camelCaseMap = convertSnakeToCamelCase(snakeCaseMap)
        return MAPPER.convertValue(camelCaseMap, targetClass)
    }

    /**
     * Converts the keys of a Map from snake_case to camelCase.
     */
    private fun convertSnakeToCamelCase(snakeCaseMap: Map<String, Any>?): Map<String, Any> {
        if (snakeCaseMap == null) {
            return emptyMap()
        }
        return snakeCaseMap.mapKeys { toCamelCase(it.key) }
    }

    /**
     * Converts a single snake_case string to camelCase.
     */
    fun toCamelCase(snakeCase: String): String {
        return snakeCase.split('_').reduceIndexed { index, acc, part ->
            if (index == 0) part else acc + part.replaceFirstChar { it.uppercase() }
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the `ScalarValueUtil` object in Kotlin.
     * @return string The content of the `ScalarValueUtil` class.
     */
    private function generateScalarValueUtilKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.util

import java.time.LocalDate
import java.time.LocalDateTime
import java.time.format.DateTimeFormatter

object ScalarValueUtil {

    private const val DATE_TIME_FORMAT = "yyyy-MM-dd HH:mm:ss"
    private const val DATE_FORMAT = "yyyy-MM-dd"

    private val dateTimeFormatter = DateTimeFormatter.ofPattern(DATE_TIME_FORMAT)
    private val dateFormatter = DateTimeFormatter.ofPattern(DATE_FORMAT)

    fun localDateTimeToString(datetime: LocalDateTime?): String? {
        return datetime?.format(dateTimeFormatter)
    }

    fun localDateToString(date: LocalDate?): String? {
        return date?.format(dateFormatter)
    }

    fun stringToLocalDateTime(datetime: String?): LocalDateTime? {
        return if (datetime.isNullOrEmpty()) null else LocalDateTime.parse(datetime, dateTimeFormatter)
    }

    fun stringToLocalDate(date: String?): LocalDate? {
        return if (date.isNullOrEmpty()) null else LocalDate.parse(date, dateFormatter)
    }
}
KOTLIN;
    }

    /**
     * Generates the ObjectScalar class for GraphQL custom scalar type in Kotlin.
     * @return string The Java code for ObjectScalar.java.
     */
    private function generateObjectScalarKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import graphql.language.*
import graphql.schema.Coercing
import graphql.schema.CoercingParseLiteralException
import graphql.schema.CoercingParseValueException
import graphql.schema.CoercingSerializeException

class ObjectScalar : Coercing<Any, Any> {

    @Throws(CoercingSerializeException::class)
    override fun serialize(dataFetcherResult: Any): Any {
        return dataFetcherResult
    }

    @Throws(CoercingParseValueException::class)
    override fun parseValue(input: Any): Any {
        return input
    }

    @Throws(CoercingParseLiteralException::class)
    override fun parseLiteral(input: Value<*>): Any? {
        return when (input) {
            is StringValue -> input.value
            is IntValue -> input.value
            is FloatValue -> input.value
            is BooleanValue -> input.isValue
            is ArrayValue -> input.values.map { parseLiteral(it) }
            is ObjectValue -> input.objectFields.associate { it.name to parseLiteral(it.value) }
            else -> null
        }
    }
}
KOTLIN;
    }

    /**
     * Generates the GraphQlConfig class for GraphQL configuration in Kotlin.
     * @return string The Java code for GraphQlConfig.java.
     */
    private function generateGraphQlConfigKt() {
        $package = $this->projectConfig['packageName'];
        return <<<KOTLIN
package $package.config

import graphql.schema.GraphQLScalarType
import org.springframework.context.annotation.Bean
import org.springframework.context.annotation.Configuration
import org.springframework.graphql.execution.RuntimeWiringConfigurer

@Configuration
class GraphQlConfig {

    @Bean
    fun runtimeWiringConfigurer(): RuntimeWiringConfigurer {
        val objectScalar = GraphQLScalarType.newScalar()
            .name("Object")
            .description("A custom scalar that can represent any JSON-like object.")
            .coercing(ObjectScalar())
            .build()

        return RuntimeWiringConfigurer { builder ->
            builder.scalar(objectScalar)
        }
    }
}
KOTLIN;
    }

    
}